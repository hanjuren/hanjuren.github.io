{"pages":[],"posts":[{"title":"blog 복구","text":"블로그 초기화…블로그에 포스팅을 조금 해놓고 노트북이 고장이 나서 밀어버렸더니… 깃에 올라가있겠지라고.. 생각하고 백업을 안했다.깃에 있는건 배포될 html파일들만 있는것인데 생각도 못했다. 비록 복사해서 다시 잘 넣었지만 너무 고난이였다. 항상 백업을 생활화 하자.. 그래서 이번에는 블로그 배포 파일 레파지토리 말고도 로컬 작업 폴더를 깃에 올려두었다. 까먹지말고 항상 올려주자..","link":"/2021/09/09/blog-%EB%B3%B5%EA%B5%AC/"},{"title":"Ec2 Codedeploy시 겪었던 에러들 그리고 해결했던 방법들","text":"자동배포를 진행하며 발생한 에러들과 해결했던 내용 기록 MySQL Server 자동 종료 인스턴스 접속을 끊고 나면 mysql 서버가 자동으로 종료되어 실행이 되지 않는 문제가 있었다. 프로젝트 내에서 TypeORM을 통해 mysql과 연결을 해야 하는데 서버가 꺼져있으니 연결이 되지 않아 프로젝트가 실행되지 않는 문제였다.이 문제는 인스턴스에 연결 시 자동으로 mysql server가 자동으로 실행 되도록 설정을 해주는 방법으로 해결을 했다. 1 systemctl 해당 명령어를 통해 서버 부팅 시 실행되는 프로그램들의 목록을 확인 할 수 있다. 이 목록에 mysqld를 추가해 주면 된다. 1 sudo systemctl enable mysqld 다시 목록을 확인해보면 프로그램이 등록된것을 확인 할 수 있다. Ec2인스턴스 메모리 부족 프리티어로 사용중인 EC2 t2.micro에 mysql을 설치하여 구동하니 mysql이 메모리를 상당히 잡아 먹는 다는 것을 알게되었다… 자동으로 swap 영역을 지정해주지 않는 다는 것… 또한 메모리가 1GB인데 모두 사용하지 않는다는 것 이문제를 해결해보고자 swqp구성을 직접 해주었다. 1234 dd if=/dev/zero of=/swapfile bs=1M count=1024mkswap /swapfileswapon /swapfileecho &quot;/swapfile swap swap defaults 0 0&quot; &gt;&gt; /etc/fstab 위의 명령어들은 swqp영역을 직접 할당해주는 명령어들이다. free -m 명령어를 실행해보면 swap 영역 할당 전에는 swqp영역의 메모리가 0인데 할당 시 지정 한 만큼 늘어난 것을 확인할 수 있다. 배포 무한 로딩… 배포 단계시 무한 Pendding 상태가 지속되는 경우가 발생했다.. 그래서 또 무한 구글링…찾아낸 해결법은 그냥 인스턴스에서 codedeploy-agent를 재실행 하라고 한다. 물론 이방법으로 해결이 안되면 다른 방법을 찾아야 겠지만 이방법으로 해결을 했다. 먼저 codedeploy-agent를 중지해준다. 1 sudo systemctl stop codedeploy-agent 이후 다시 시작해주면 된다. 이렇게 간단? 1 sudo systemctl start codedeploy-agent 그리고나서 다시 실행 상태를 확인해주면 끝!","link":"/2021/09/09/aws/Ec2-Codedeploy%EC%8B%9C-%EA%B2%AA%EC%97%88%EB%8D%98-%EC%97%90%EB%9F%AC%EB%93%A4-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%ED%95%B4%EA%B2%B0%ED%96%88%EB%8D%98-%EB%B0%A9%EB%B2%95%EB%93%A4/"},{"title":"Ec2 접속하기","text":"AWS Ec2 접속하기 aws ec2에 접속하기 위해서는 인스턴스 생성시 생성한 키페어를 통해 접속을 할 수 있다. 먼저 인스턴스를 열기 위해 터미널을 열고 생성된 키페어가 있는 디렉토리로 이동한다. 이과정에서 윈도우 cmd나 powershell이 실행이 안되는 문제가 조금 있어서 git설치시 설치된 git bash 를 통해 인스턴스로 접속했다. 접속할 인스턴스를 선택 후 연결 버튼 클릭 연결 할 때 사용할 스크립트 복사. shell을 통해 복사한 키를 붙여넣고 접속 시 다음과 같은 화면이 나오면 성공적으로 인스턴스에 접속이 된것이다.","link":"/2021/09/09/aws/Ec2-%EC%A0%91%EC%86%8D%ED%95%98%EA%B8%B0/"},{"title":"aws Ec2인스턴스 생성","text":"AWS Ec2 인스턴스 생성 AWS란? AWS는 아마존 닷컴의 클라우딩 컴퓨터 서비스이고 컴퓨터의 기능을 AWS를 이용해 서버 또는 컴퓨터를 구매하지 않고 이용할 수 있는 서비스이다. AWS Ec2 인스턴스 생성하기 기본적으로 aws에서 회원가입을 진행하고 나서 이후의 과정을 실행해야한다. aws는 회원가입시 이용요금을 결제할 카드를 등록해야 한다. 해외 결제가 가능한 카드를 준비해야 하며 등록 후 다음의 과정을 진행 하면 된다. 먼저 인스턴스 탭을 클릭하여 인스턴스를 볼 수 있는 화면으로 이동 후 좌측 상단의 인스턴스 시작버튼을 클릭한다.클릭 시 다음과 같은 화면이 보여지며 인스턴스 생성을 시작할 수 있다. 1. 인스턴스 종류 선택 해당 과정에서는 aws에서 제공하는 linux를 이용할 것이다. 대부분 Amazon Linux 2 AMI 또는 Ubuntu Server 18.04 LTS 리눅스를 많이 이용한다. 2. 인스턴스 유형 선택 기본으로 선택되어있는 인스턴스 유형을 선택한다. 이정도의 사양도 테스트 용으로는 충분하며 최초 회원가입시 1년간의 프리티어로 무제한 이용히 가능하다는 장점이 있으므로 해당 유형을 선택하여 진행한다. 3. 인스턴스 세부정보 구성 세부 정보 구성은 별도로 수정할 것은 딱히 없지만 서브넷 주소정도는 선택해도 무방하다. 여기서는 a2서브넷 구성을 사용한다. 4. 태그 추가 세부정보 구성 이후 스토리지 추가 등의 과정은 추가할 필요없이 계속 다음으로 진행한다.이후 태그추가를 할수있는 화면에서 해당 인스턴스를 인식할 수 있는 태그를 추가한다.이 태그는 이후 자동 배포시 사용하게 된다. 5. 인스턴스 보안 그룹 생성 보안 그룹은 해당 인스턴스를 접속할 수 있는 IP주소를 등록하는 곳이다.사용자 지정 ip를 통해 해당 ip만 접속을 하게끔 할 수도 있고 모두가 접속하도록 설정 할 수도 있다. 여기서는 ec2서버에 등록될 앱의 포트번호인 3000포트도 추가했다. 6. 키페어 등록 및 생성 인스턴스를 접속 할수 있는 키를 생성하는 곳이다. 기존의 키가 있어서 기존 키를 사용했지만 키가 없거나 처음 생성하는 경우 새로운 키를 생성하여 분실하지 않도록 관리하면 된다. 7. 인스턴스 생성 후 설정 진행중 모든 과정을 마치고 생성된 인스턴스가 설정중인 모습이다. 8. 인스턴스 생성 완료 및 실행중 설정을 마치고 우리의 인스턴스가 실행중이다. 해당 인스턴스를 접속하여 이후 자신의 서비스를 등록하거나 이용하면 된다.","link":"/2021/09/09/aws/aws-Ec2%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EC%83%9D%EC%84%B1/"},{"title":"git action AWS Ec2 배포하기 1","text":"Git Action Ec2 Codedeploy 자동배포 하기 1. git action을 통해 ec2인스턴스에 자동으로 나의 코드를 배포하는 과정을 진행할 것이다.우리의 서비스가 ec2에 배포를 진행하고 나면 우리의 서비스가 수정되고 새로운 기능이 생길 때마다 ec2에 접속해서 새로 빌드를 해야하는데 이러한 과정을 git action과 aws에서 대신 진행주는 서비스가 있다. 해당 과정은 개발중이거나 개발된 깃 레파지토리, Ec2인스턴스, Codedeploy, IAM Role, IAM User, S3버킷을 통해 이뤄지며 해당 과정을 순서대로 정리한 글이다. 먼저 개발중인 레파지토리를 이용할 것이며 각자의 프로젝트를 이용하거나 테스트 앱을 클론하여 진행해도 무방하다. 배포할 앱은 Node.js 기반의 서비스이고 mysql 데이터베이스를 사용할 예정이다. 과정 aws 인스턴스 생성 인스턴스 접속 후 codedeploy agent 설치 및 node.js mysql 설치 iam 역할 생성 및 유저 생성 codedepoly app생성 및 배포그룹 생성 git 워크플로우 작성 셸 스크립트 작성 다음의 과정을 하나씩 포스팅을 통해 진행 하도록 해보자. Ec2 Codedeploy Agent 설치 인스턴스 생성은 기존의 인스턴스 생성 포스팅을 참고하여 생성해도 무방하다. 인스턴스 생성 후의 자동배포를 위한 패키지들을 설치하고 기본 설정을 진행한다. 인스턴스 접속 후 명령어들을 차례대로 실행한다. 1234567 sudo yum updatesudo yum install rubysudo yum install wgetcd /home/ec2-userwget https://aws-codedeploy-ap-northeast-2.s3.amazonaws.com/latest/installchmod +x ./installsudo ./install auto 리눅스 패키지 업데이트를 진행해주고 ruby, wget 패키지를 install해준다. 이후 codedeploy agent를 설치해주면 된다. 설치를 마치고 인스턴스에서 codedeploy가 정상적으로 실행 중인지 보기 위해서는 다음의 명령어를 통해 확인이 가능하다. 1 sudo service codedeploy-agent status “The AWS CodeDeploy agent is running as PID 4323”과 같은 메지지가 출력된다면 성공적으로 설치가 된것이다. 우리가 설치한것을 통해 인스턴스가 자동으로 코드 배포가 진행 되도록 해줄 것이다. NodeJS 설치 node.js 환경의 프로젝트를 인스턴스를 통해 배포하기 위해서는 인스턴스 서버내에 node.js를 설치해 주어야 한다. 루트로 설치하기 위해서는 root로 사용자전환을 해야하는데 처음 인스턴스를 생성시 root 패스워드를 설정해주지 않았기 때문에 “sudo passwd” 명령어를 통해 비밀번호를 설정해준다. 비밀번호 설정 후 root사용자로 전환하면 된다. 사용자 전환 명령어는 su 사용자이름 으로 root전환시에는 su 만 입력해줘도 전환이 된다. 1234 curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash. ~/.nvm/nvm.shnvm install node -&gt; 최신 버전 설치node -v 설치 이후 node -v 명령어를 통해 노드의 버전을 확인해보고 설치가 되었는지 확인 할 수 있다. MySQL 설치 프로젝트에서 사용하는 데이터베이스는 mysql이므로 동일하게 리눅스 환경에도 mysql을 설치해주어야 한다. mysql을 설치하는 과정은 다음과 같다. 123 sudo yum install https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpmsudo yum install mysql-community-server 두가지 과정으로 mysql 서버를 다운받고 실행을 통해 상태를 확인해주면 돤다. 실행과 상태 확인 명령어는 다음과 같다. 12 sudo systemctl start mysqldsudo systemctl status mysqld 명령어를 실행하고 정상적으로 설치 실행이 되고있다면 다음과 같은 화면이 나올 것이다. 추가적으로 데이터베이스의 기본 설정과 포트번호 확인은 mysql명령어나 mysql의 파일이 있는 디렉토리에서 추가적으로 확인이 가능하고 수정이 가능하다. 이때 수정은 root권한으로만 수정이 되니 유저에게 권한을 부여하거나 root사용자로 수정을 해주면 될듯 하다. MySQL 접속 mysql에 접속하는 과정은 다른 OS에서 접속하는 것과 똑같이 진행된다. 다만 리눅스는 GUI환경을 제공하지 않기때문에 터미널로 접속을 하면 된다.먼저 mysql의 root유저의 비밀번호을 자신이 원하는 비밀번호로 수정하고 접속을 해야한다. 초기 비밀번호는 설치시 로그 파일 어딘가 남아있는데 다음 명령어를 통해 초기 비밀번호를 찾아준다. 1 sudo grep 'temporary password' /var/log/mysqld.log 로그파일에서 비밀번호를 찾아보면 화면에 다믕과 같이 표시가 된다. 1 2021-08-28T04:03:24.500883Z 6 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: VnWiZOKof1+g 나에게 부여된 임시 패스워드는 VnWiZOKof1+g 이부분이며 요것을 가지고 새로운 비밀번호를 생성 해주면된다.비밀번호를 새롭게 세팅해보도록 하자. 1 sudo mysql_secure_installation -p'VnWiZOKof1+g' 이렇게 명령어를 입력하면 새로운 비밀번호를 생성하라는 문구가 나오고 원하는 비밀번호를 입력해주면 된다. 이후 mysql에 정상적으로 비밀번호를 입력하여 접속할 수 있다. 성공적으로 Ec2 인스턴스에 Codedeploy agent와 mysql, nodejs를 설치해보았다. 다음은 aws에서 작업해야 하는 것들에 대해 알아보자.","link":"/2021/09/09/aws/git-action-AWS-Ec2-%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B0-1/"},{"title":"git action AWS Ec2 배포하기 2","text":"Git Action Ec2 Codedeploy 자동배포 하기 2. 지난 포스팅에서 Ec2 인스턴스에서 기본적인 환경 설정을 완료 하였고 이번에는 자동 배포를 위한 AWS 설정을 진행한다. 설정을 진행해야하는 과정은 다음과 같다. IAM 역할 만들기 IAM 유저 만들기 Codedeploy App 만들기 Codedeploy App deploy Group 생성 S3 버킷 생성 Ec2 인스턴스에 IAM역할 부여하기 진행해보도록 하자. IAM 역할 생성 및 유저 생성 역할 생성하기 2가지의 역할을 생성해 주어야 한다. Ec2에대한 역할 그리고 Codedeploy에 대한 역할 생성이다.먼저 Ec2에대한 역할을 생성해준다. 새로운 역할 만들기를 클릭하여 새로운 역할을 생성할 수 있다. Ec2를 선택 다음 과정을 진행하기를 클릭한다. 두가지의 역할을 부여해주어야 하는데 AWSCodeDeployFullAccess와 AmazonS3FullAccess를 찾아서 클릭해준다. 여기서 각각 두가지를 생성하는 것이 아니라 두가지를 한번에 선택하여 생성해 주어야 한다. 이름을 입력해주고 생성을 누르면 Ec2에 대한 역할이 생성된다. 그다음은 codedeploy에 대한 역할 생성을 진행한다. 동일하게 새로운 역할을 생성하기를 클릭하면 된다. codedeploy를 선택하고 이후 자동으로 부여되어있는 역할을 그대로 사용해주면된다. 역할의 이름을 입력하고 생성해준다. 사용자 만들기 새로운 사용자를 만들어주기 위해 사용자 만들기를 클릭한다. 이름을 지정하고 프로그래밍 엑세스 방식을 선택하고 다음을 진행한다. Ec2역할 만들때 지정했던 AWSCodeDeployFullAccess와 AmazonS3FullAccess를 찾아서 지정해준다. 이후 생성과정을 진행하다보면 클라이언트 키와 시크릿 키를 발급받게 되는데 csv파일을 다운받거나 키를 복사하여 어딘가에 잘 저장 해두어야한다. 이 키를 통해 유저를 인증할 수 있다. Codedeploy 애플리케이션 생성 애플리케이션을 생성하는 것은 너무나도 간단하다. Codedeploy서비스 탭에 들어가 애플리케이션 생성을 클릭하고 애플리케이션 이름과 Ec2온프로그래미스를 선택하여 애플리케이션을 생성해주면된다. 배포 그룹 생성하기 다음의 과정을 진행하여 배포 그룹을 생성해주도록 한다. S3버킷 생성하기 S3 탭에 들어가 버킷 생성을 진행한다. 특별히 설정 부분이 없어 이름만 지정 후 생성해주면 된다. 인스턴스 IAM역할 수정 인스턴스를 선택하여 역할 수정을 클릭해준다. 그리고 이전에 생성했던 Ec2역할을 부여해주고 적용해 주도록 한다. AWS에서 진행해야하는 모든 설정을 진행했다. 이제 git action을 통해 ec2에 자동 배포를 할 수 있도록 해주는 과정에대해 알아보도록 하자.","link":"/2021/09/09/aws/git-action-AWS-Ec2-%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B0-2/"},{"title":"git action AWS Ec2 배포하기 4","text":"Git Action Ec2 Codedeploy 자동배포 하기 4. 이전의 과정들을 거친이후 실제로 배포가 되는지 테스트를 진행해보도록하자.테스트 과정은 비교적 간단하다. 로컬 환경에서 작업한 코드를 깃 레파지토리에 올리기만 하면 배포가 실행될 것이다. 로컬환경 작업코드를 깃 레파지토리에 올리기전 실행이 되는지 테스트를 진행해준다. 코드의 내용은 간단히 인사말을 출력해주는 구성으로 진행했다. 실행결과 정삭적으로 화면에 글이 보여진다. 실행이 되는것을 확인했으니 메인 브랜치로 push를 해주면 우리가 작성한 workflow가 실행될것이다. push를 해주고 레파지토리로 들어가 action탭으로 가면 커밋메시지의 이름으로 실행중인 워크플로우를 확인 할 수 있다. AWS workflow를 통해 S3에 프로젝트를 업로드하고 Codedeploy가 배포를 정상적으로 실행하는지 확인을 해보자. 새로운 배포 목록이 보이고 진행중이라는 상태를 확인할 수 있다. 해당 내용을 클릭하여 과정을 상세하게 볼 수 있으니 확인해보면 좋다. 또한 배포 실패시 에러또한 상세정보에서 확인이 가능하니 참고하면 좋을 것 같다. 상세정보 화면이다. 모든 과정이 성공적으로 완료 되었고 이제 Ec2에 내용이 있는지 실행중인지 확인 후 접속을 하면 마무리 된다.ㅠㅠ Ec2 프로젝트 디렉토리가 생겼고 내부 파일도 정상적으로 생성이 되었다. pm2 list명령어는 pm2로 실행중인 프로젝트의 목록을 확인 할 수 있는 명령어이다. 정상적으로 실행중이라는 상태가 확인이 돠었으니 접속을 하면 된다. IPv4 퍼블릭 IP를 통해 접속을 하면 된다. 프로젝트에서 설정한 포트를추가하여 접속을 한면 정상적으로 배포가 된것을 확인 할 수 있다. 수정내용 배포 테스트 일단 처음 배포를 하고 실행해보니 정상적인 상태인 것을 확인 했다. 이제 코드 내용을 수정하여 다시 배포를 진행해서 수정사항이 반영이 되는지 테스트를 진행해보자.과정은 위에서 진행한 내용과 똑같으니 수정 내용과 결과를 통해 확인하면 될 것 같다. 코드를 수정하고 다시 메인 브랜치로 push를 해준다. 이후 잠시 기다렸다가 다시 접속을 하여 수정사항이 반영되었는지 확인을 해보자. 수정사항까지 정상적으로 반영이 되었고 자동배포를 할 수 있게 되었다. 모든 과정을 마치고 테스트를 진행하며 겪은 수많은 실패들에 대해 해결했던 방안을 따로 정리하도록 하겠다.모든 것이 처음부터 잘될 수는 없으니 차근차근 진행해보는 것이 정답인듯 하다. 👍","link":"/2021/09/09/aws/git-action-AWS-Ec2-%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B0-4/"},{"title":"NodeJs Router","text":"Node.js Router 알아보기.라우팅이란라우팅은 애플리케이션 엔드 포인트(URI)의 정의, 그리고 URI가 클라이언트 요청에 응답하는 방식을 의미하고 있습니다.예를 들어 다음과 같은 라우터가 있다면 1234567const express = require('express');const app = express();// respond with &quot;hello world&quot; when a GET request is made to the homepageapp.get('/', function(req, res) { res.send('hello world');}); 루트 “/“ 엔트포인트로 접근 시 hello word라는 문자열을 브라우저에 띄워 줄 것 입니다. 라우트 메소드라우트 메소드는 HTTP 메소드 중 하나로부터 파생되며, express 클래스의 인스턴스에 연결됩니다. 다음 코드는 앱의 루트에 대한 GET 및 POST 메소드에 대해 정의된 라우트의 예입니다. 123456789// GET method routeapp.get('/', function (req, res) { res.send('GET request to the homepage');});// POST method routeapp.post('/', function (req, res) { res.send('POST request to the homepage');}); express는 HTTP메서드에 해당하는 다음과 같은 목록에 해당하는 메서드를 지원합니다.get, post, put, head, delete, options, trace, copy, lock, mkcol, move, purge, propfind, proppatch, unlock, report, mkactivity, checkout, merge, m-search, notify, subscribe, unsubscribe, patch, search 및 connect. 다양한 HTTP메서드를 사용하여 express에서 라우팅을 생성 할 수 있다.","link":"/2021/09/09/nodejs/NodeJs-Router/"},{"title":"NodeJs express","text":"Node.Js를 알게 된지 반년이 넘어가는데 이제야 깃 블로그를 시작한 본인이 너무 바보 같지만 지금까지 공부한 것들을 블로그를 통해 기록하려한다.. 너무 많은게 문제지만 하나하나정리해 나가야 겠다. NodeJs express 시작하기npm init 명령어 실행 후 터미널에서 express 패키지를 install 한다. 1npm install express\\ 그리고 app.js에 다음과 같이 코드를 작성해준다. 1234567891011const express = require('express')const app = express()const port = 3000app.get('/', (req, res) =&gt; { res.send('Hello World!')})app.listen(port, () =&gt; { console.log(`Example app listening at http://localhost:${port}`)}) 작성을 하고 터미널에서 node app.js 명령어를 통해 app..js파일을 실행한다. 브라우저를 통해 localhost:3000 포트로 접속 하니 Hello world 라는 문구가 보인다. 이렇게 간단하게 서버를 하나 열 수 있게 되었다.","link":"/2021/09/09/nodejs/NodeJs-express/"},{"title":"Nodejs Middleware","text":"Node.js Middleware 알아보기 👉Middleware란? 미들웨어란 요청(req), 응답(res)의 사이에서 목적에 맞게 구현한 함수를 실행하게 되는 거쳐가는 함수라는 의미이다.docs에서는 미들웨어를 다음과 같이 정의하고 있다. Middleware functions are functions that have access to the request object (req), the response object (res), and the next function in the application’s request-response cycle. 쉽게 이해하기 위해 예를 들면 클라이언트의 요청이 들어오면 console을 찍는 함수를 미들웨어로 구현한다고 생각을 해보자요청이 들어오고 서버는 콘솔을 찍은 후 요청에대한 응답을 다시 클라이언트로 보내줄 것이다. 이것이 중간에서 실행되는 함수 즉 미들웨어의 개념이라고 생각하면 쉽다. 👉Middleware 사용법 기본적으로 미들웨어는 app.use와 함께 사용한다고 docs에서는 알려주고 있다. 모든 요청에서 콘솔을 찍는 미들웨어를 작성하여 요청과 응답의 중간에서 실행시켜보자. 12345678910111213141516 const express = require('express')const app = express()const port = 3000app.use((req, res, next) =&gt; { console.log('요청의 중간에서 실행되었습니다.'); next();})app.get('/', (req, res) =&gt; { res.send('Hello World!')})app.listen(port, () =&gt; { console.log(`Example app listening at http://localhost:${port}`)}) console을 기록하는 미들웨어를 작성해주었다. app.use는 모든 요청에서 실행하겠다는 의미이다. 이제 3000포트로 접속시 로그가 남는지 확인을 해보자. 서버에 접속 후 터미널을 확인해보았다. 작성한 로그가 잘 찍힌것을 확인할 수 있다.👍 👉next메서드 미들웨어에서는 함수를 살행 후 다음 미들웨어를 실행하기 위해서 next메서드를 필수적으로 호출해야 한다. 이유는 next를 호출하지 않는다면 다음 미들웨어로 넘어가지 않기 때문인데 아까 만들었던 미들웨어에 next를 호출하지 않고 다시 실행을 해보도록 하겠다. 12345678910111213141516 const express = require('express')const app = express()const port = 3000app.use((req, res, next) =&gt; { console.log('요청의 중간에서 실행되었습니다.'); // next 호출 안함})app.get('/', (req, res) =&gt; { res.send('Hello World!')})app.listen(port, () =&gt; { console.log(`Example app listening at http://localhost:${port}`)}) 3000포트로 접속을 하면 “Hello World”라는 문구가 화면에 보여져야 하지만 화면이 넘어가지 않는다. 하지만 콘솔을 남기는 미들웨어는 그대로 실행이 된것을 볼 수 있다. 이처럼 미들웨어는 다음미들웨어로 넘어가기 위해서 next 메서드를 필수적으로 호출을 해줘야한다. 👉함수로 구현하기 app.use를 활용하여 모든 라우터에서 미들웨어를 실행할 수 있지만 특정 라우터에서만 실행 하고자 하는 미들웨어가 있을 수 있다. 이럴때는 함수로 만들어서 중간에 넣어주는 방법도 있다.예시를 위해 로그를 남기는 미들웨어를 특정 라우터에서만 실행해보도록 하겠다. 1234567891011121314151617181920 const express = require('express')const app = express()const port = 3000const middleware = (req, res, next) =&gt; { console.log('/mypage 에서만 실행됩니다.'); next();}app.get('/', (req, res) =&gt; { res.send('Hello World!')})app.get('/mypage', middleware ,(req, res) =&gt; { res.send('My Page!!');})app.listen(port, () =&gt; { console.log(`Example app listening at http://localhost:${port}`)}) middleware라는 함수를 만들고 “/mypage”라는 라우터의 중간에 넣어주었다. 이제 로그를 남기는 함수는 “/mypage” 요청의 중간에서 실행 될 것이다. 아무런 로그가 기록되지 않는다. “/mypage”로 요청을 보내보자. 로그를 기록하는 미들웨어가 정상적으로 작동을 했다. 이런식으로 특정 라우터에서만 실행하고자 하는 미들웨어도 작성이 가능하다. 👉Middleware가 실행되는 경우 미들웨어가 실행되는 경우 app.use(미들웨어) 모든요청에서 미들웨어 실행 app.use(‘/abc’, 미들웨어) abc로 시작하는 요청에서 미들웨어 실행 app.post(‘/abc’, 미들웨어) abc로 시작하는 POST 요청에서 미들웨어 실행 app.get(‘/def’, 미들웨어) def로 시작하는 GET 요청에서 미들웨어 실행","link":"/2021/09/09/nodejs/Nodejs-Middleware/"},{"title":"Passport(passport-local)","text":"👍Passport 사용해보기 passport는 Node.js의 인증 미들웨어로 요청에 대한 인증을 위한 패키지이다. 소셜네트워크 서비스의 발전으로 인해 OAuth 인증 방식의 사용이 보편화 되면서 API를 이용하기 위한 방식을 구축해주는 패키지이다. 👍passport-local passport의 전략중 가장 일반적인 로컬 로그인을 구현해보도록 하자. 소셜 로그인을 사용하기전 가장 기본인 로컬을 사용해보며 passport가 어떤 방식으로 구동되는지 확인해보겠다. 먼저 passport는 요청을 인증하기 위해 전략이라는 것을 사용한다. 우리는 local 전략을 구현하여 local인증에서 요청을 passport에게 전달 할 것이다. 먼저 필요한 패키지를 다운로드 한다.npm i passport passport-local 패키지 다운로드 후 local 전략 파일을 구성해준다. 전략이라는 것은 곧 우리가 로그인을 처리할 과정을 나열하는 것과 같다. 12345678910111213141516171819202122232425262728293031 const passport = require('passport');const LocalStrategy = require('passport-local').Strategy;const bcrypt = require('bcrypt');const User = require('../models/user');module.exports = () =&gt; { // passport.authenticate('local' ...에서이동해서 밑의 로직이 실행된다. passport.use(new LocalStrategy({ usernameField: 'email', // req.body.email 필드와 req 값이 일치해야됨 passwordField: 'password', // req.body.password }, async (email, password, done) =&gt; { try { const exUser = await User.findOne({ where: {email} }); // 이메일이 있나 확인 if(exUser){ // 이메일이 있다면 const result = await bcrypt.compare(password, exUser.password); // 받아온 비번이랑 디비 비번이랑 비교 if(result) { // 비밀번호 일치 done(null, exUser); } else { // 비밀번호 다름 done(null, false, { message: '비밀번호가 일치하지 않습니다.'}); } } else { // 가입된 이메일이 없다면 done(null, false, { message: '가입되지 않은 회원입니다.'}); } // done함수 호출 후 passport.authenticate 나머지 실행 } catch (error) { console.log(error); done(error); } }));}; 전략파일의 구성은 다음과 같다. 로그인시 사용자에게 받는 아이디 비밀번호 정보를 username, password필드에 값을 넣어준다. 기본 필드값은 username, password이므로 서비스에서 body에 담는 정보의 이름과 기본값이 다르면 값을 넣어주면 된다. 이후 데이터베이스에서 유저를 찾고 있다면 비밀번호를 비교하고 일치하면 해당 유저를 리턴해준다.해당 과정에서 done이라는 콜백 메서드가 사용되는데 done메서드에 들어가는 인자값은 **done(err, data)**이다.코드를 살펴보면 입력받은 정보에 일치하는 유저가 있을때는 첫 번째 인자값은 null로 error가 없다는 것을 의미한다.이러한 방식으로 유저의 정보가 데이터베이스와 일치하는지 아닌지 조회 후 성공시 유저 데이터 없을 시 에러를 done함수에 전달해 리턴해주면 된다. 이렇게 유저의 정보를 조회하고 리턴한 값을 passport에서는 세션으로 생성해준다.👍👍👍 👍세션 생성 12345678910111213 passport.serializeUser((user, done ) =&gt; { done(null, user.id ); // 세션에 user.id만 저장 }); // 세션에 저장된 id를 통해 사용자 정보 객체를 불러온다. // deserializeUser의 id 매개변수는 serializeUser에서 done에 담았던 두번째 인수가 오게된다. // 결과값 done의 user는 req.user로 조회할 수 있다. passport.deserializeUser((id, done) =&gt; { User.findOne({ where: { id } }) .then(user =&gt; done(null, user)) .catch(err =&gt; done(err)); }); serialize, deserialize 함수는 passport에서 세션을 생성하고 생성된 세션값을 통한 유저의 정보를 조회하는 함수로 이해하면 된다.serialize 함수는 전략 파일에서 리턴한 값을 받아 유저의 정보를 세션으로 담아 생성해준다. 아주 편리하게 세션을 생성해주는 기능이다. 👍세션 설정 passport에서 세션을 생성해준다. 하지만 express에서 passport가 생성한 세션을 사용하기 위해서는 몇가지 설정이 필요하다.설정은 app.js 에서 다음과 같이 이루어진다. 123456789101112 app.use(session({ resave: false, saveUninitialized: false, secret: process.env.COOKIE_SECRET, cookie: { httpOnly: true, secure: false, }, }));app.use(passport.initialize()); //passportapp.use(passport.session()); // passport express에 passport를 사용하고 passport가 세션을 이용한다는 설정을 해주면 된다.이제 local전략이 구성되었으니 테스트를 진행해보자. ✅테스트 테스트는 클론코딩을 진행중이던 프로젝트에서 진행 하였다. 로그인을 위한 정보를 입력하고 로그인을 진행한다. 요청이 200 StatusCode와 함께 성공적으로 완료가 되었다. 네트워크 탭을 통해 세션까지 성공적으로 생성된 것을 확인 할 수 있다.이렇게 passport의 local전력을 실행해 보았다. 이후 소셜로그인 API를 통해 passport전략을 구축하는 과정까지 알아보도록 하자.","link":"/2021/09/09/nodejs/Passport-passport-local/"},{"title":"javascript 객체 리터럴","text":"객체 리터럴자바스크립트는 객체기반 프로그래밍 언어이며 자바스크립트를 구성하는 거의 대부분이 원시값을 제외한 객체이다. 원시타입은 단 하나의 값을 나타내지만 객체 타입은 다양한 타입의 값을 하나의 단위로 가지고있는 복합적 자료구조이다. 원시 타입의 값은 변경이 불가능 하지만 객체 타입의 값 즉 객체는 변경이 가능한 값이다. 객체 : 0개이상의 프로퍼티로 구성된 집합이며 키와 값으로 구성된다. 12345var person = { // key: value age: 25, name: 'han',}; 자바스크립트에서 사용할 수 있는 모든 값은 프로퍼티가 될 수 있다. 프로퍼티의 값이 함수일 경우 일반 함수와 구분하기 위해 메서드라고 부른다. 123456var person = { age: 25, // 프로퍼티 increase: function() { // 메서드 this.age++; }} 프로퍼티와 메서드의 역할 프로퍼티 : 객체의 상태를 나타내는 값 메서드 : 프로퍼티를 참조하고 조작할 수 있는 동작 ✔ 객체와 함수 자바스크립트는 함수로 객체를 생성하기도 하고 함수 자체가 객체이기도 하다. 객체 리터럴에 의한 객체 생성C, JAVA같은 클래스 기반 객체지향 언어는 클래스를 정의하고 new 연산자와 생성자를 호출하여 객체를 생성하는 방식이다. 자바스크립트에서는 프로토타입 기반 객체지향 언어로서 여러가지의 객체 생성 방식을 지원한다. 객체 리터럴 Object생성자 함수 생성자 함수 Object.create메서드 클래스 이 방법들중 가장 많이 사용하는 객체 리터럴 방법은 객체를 생성하기 위한 표기법중 하나이다. 객체 생성해보기123456789var person = { name = 'lee', sayHello: function() { console.log(`Hello My Name is ${this.name}`); }};console.log(typeof personn); // objectconsole.log(person); // { name: 'lee', sayHello: f } 프로퍼티객체는 프로퍼티의 집합이며 프로퍼티는 키와 값으로 구성된다. 123456var person = { // 프로퍼티 키는 name, 값은 'Lee' name: 'Lee', // 프로퍼티 키는 age, 값은 '20 age: 20,}; 프로퍼티를 나열할 때는 쉼표로 구분한다. 일반적으로 마지막 프로퍼티에는 쉼표를 사용하지 않지만 해도 무방하다. 문자열 또는 문자열로 평가할 수 있는 표현식을 사용하여 프로퍼티 키를 동적으로 생성할 수 있다. 이때는 키로 사용할 표현식을 대괄호[]로 묶어줘야 한다. 123456var obj = {};var key = 'hello';obj[key] = 'world';console.log(obj); // { hello: 'world' } 프로퍼티 키 네이밍 빈문자열로 생성해도 에러는 발생하지 않는다 하지만 키로서의 의미를 갖지 못한다. 문자열이나 심벌값 외의 값을 사용하면 암묵적 타입 변환으로 문자열이 된다. 예약어를 사용해도 에러는 발생하지 않느다 하지만 예상치 못한 에러가 발생할 수 있다. 중복선언시 나중에 선언한 프로퍼티가 기존의 값을 덮어씌운다. 메서드자바스크립트에서 함수는 일급 객체이다. 즉 함수는 값으로 취급이 되기때문에 프로퍼티 값으로 사용할 수 있다.프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위해 메서드라 부른다. 12345678910var circle = { radius: 5, // 프로퍼티 // 원의 지름을 구하는 함수 getDiameter: function () { // 메서드 return 2 * this.radius; // this는 circle을 가르킨다. },};console.log(circle.getDiameter()); // 10 프로퍼티 접근프로퍼티에 접근하는 방법은 다음과 같이 두 가지다. 마침표 프로퍼티 접근 연산자를 사용하는 법 대괄호 프로퍼티 접근 연산자를 사용하는 법 프로퍼티 키가 식별자 네이밍 규칙을 준수하는 이름이라면 두가지 방법을 모두 사용할 수 있다. 프로퍼티 접근해보기12345678var person = { name: 'Han', age: 25,};console.log(person.name); // Hanconsole.log(person.age); // 25 이때 대괄호 표기법으로 프로퍼티에 접근시 접근 연산자 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싸줘야 한다. 프로퍼티 값 갱신이미 존재하는 프로퍼티 값에 새로운 값을 할당하면 값이 갱신된다. 1234567var person = { name: 'lee',};person.name = 'han';console.log(person); // { name: 'han' } 프로퍼티 동적 생성존재한지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당 된다. 1234567var person = { name: 'Lee',};person.age = 20;v 프로퍼티 삭제delete 연산자는 객체의 프로퍼티를 삭제한다. 이때 delete 연산자의 피연산자가 프로퍼티에 접근이 가능한 표현식이여야 한다. 12345678910var person = { name: 'Lee',};person.age = 20;console.log(person); // { name: 'Lee', age: 20 }delete person.age;console.log(person); // { name: 'Lee' } ES6에서 추가된 객체 리터럴의 확장 기능프로퍼티 축약 표현123456789// es5var x = 1, y = 2;var obj = { x: x, y: y,};console.log(obj); // { x: 1, y: 2 } ES6에서는 프로퍼티 키와 값으로 변수를 사용할때 둘의 이름이 동일하다면 키를 생략할 수 있다. 12345let x = 1, y = 2;const obj = { x, y };console.log(obj); // { x: 1, y: 2 } 계산된 프로퍼티 이름문자열 또는 문자열로 타입 변활할 수 있는 값으로 평가되는 표현식을 사용해 키를 동적으로 생성하기 위해서는 대괄호 표현식으로 묶어줘야 한다. 이를 계산된 프로퍼티 이름이라고 한다. ES5에서는 계산된 프로퍼티 이름으로 키를 생성하려면 객체 리터럴 외부에서 대괄호 표기번을 사용해야 했다. 12345678910var pre = 'prop';var i = 0;var obj = {};obj[pre = '-' + ++i] = i;obj[pre = '-' + ++i] = i;obj[pre = '-' + ++i] = i;console.log(obj); // { prop-1: 1, prop-2: 2, prop-3: 3 } ES6에서는 객체 리터럴 내부에서도 계산된 프로퍼티 이름으로 프로퍼티 키를 동적 생성할 수 있다. 12345678910const pre = 'prop';let i = 0;const obj = { [`${prop}-${++i}`]: i, [`${prop}-${++i}`]: i, [`${prop}-${++i}`]: i,};console.log(obj); // { prop-1: 1, prop-2: 2, prop-3: 3 } 메서드 축약 표현ES5에서 메서드를 정의하기 위해서는 프로퍼티 값으로 함수를 할당한다. 12345678var obj = { name: 'Lee', sayHi: function () { console.log('Hi ' + this.name); },};obj.sayHi(); // Hi Lee ES6에서 메서드를 정의할 때 function 키워드를 생략하는 축약 표현이 가능하다. 12345678const obj = { name: 'Lee', sayHi() { console.log(`Hi ${this.name}`); },};obj.sayHi(); // Hi Lee","link":"/2021/09/15/js/javascript-%EA%B0%9D%EC%B2%B4-%EB%A6%AC%ED%84%B0%EB%9F%B4/"},{"title":"javascript 데이터타입","text":"데이터 타입데이터 타입은 값의 종류를 말한다. 자바스크립트의 모든 값은 데이터 타입을 갖는다. 자바스크립트에서는 데이터 타입으로 7가지를 제공한다. 원시 타입 숫자 타입 : 숫자, 정수와 실수 구분없이 하나의 숫자 타입만 존재 문자열타입 : 문자열 불리언타입 : 논리타입 true or false undefined : var 키워드로 선언된 변수에 암묵적으로 할당되는 값 null : 값이 없다는 것을 명시하기 위해 사용하는 값 심벌 타입 : ES6 에서 추가된 7번째 타입 객체 타입 객체, 함수, 배열 등 데이터 타입의 필요성값은 메모리에 저장하고 참조 할 수 있어야 한다. 메모리에 값을 저장하기 위해서는 먼저 메모리의 공간을 확보하고 크기를 결정해야한다. score라는 변수에 100이라는 값을 할당하기 위해서 자바스크립트 엔진은 데이터 타입에 따라 메모리의 크기를 결정하고 공간을 확보한 후 값을 저장해준다. 이렇게 값이 저장된 메모리의 값을 참조하는 경우는 식별자 score를 통해 값 100이 저장되있는 메모리의 공간을 찾아야한다. 이때 값을 참조하기 위해서는 읽어 들여야하는 메모리의 크기를 알아야 한다.이때 자바스크립트가 변수에는 숫자 타입의 값이 할당되어있는 것을 보고 타입에 맞는 단위로 메모리에 저장된 값을 읽어들인다. 이렇게 읽어온 2진수의 데이터를 해석하는 과정에서는 데이터의 타입을 자바스크립트가 알고 있으므로 해당 타입의 값으로 해석을 하게 된다. 이러한 이유로 데이터 타입의 중요성에 대해 정리하자면 다음과 같다. 값을 저장할 때 확보해야 하는 메모리의 크기를 결정하기 위해 값을 참조할 때 한번에 읽어 들여야 할 메모리의 크기를 결정하기 위해 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해 숫자 타입자바스크립트에서는 하나의 숫자형 타입만 존재한다. 자바스크립트에서는 모든 수를 실수로 처리하며 정수만 표현하기위한 데이터 타입은 존재하지 않는다. 123var integer = 10; // 정수var double = 10.12 // 실수var negative = -20 // 음의 정수 위의 값은 모두 숫자 타입이다. 이러한 특징으로 인해 자바스크립트에서 숫자형은 표기하는 방식만 다를뿐 모두 같은 값을 가질 수 있다는 것을 의미한다. 문자열 타입문자열 타입은 텍스트 데이터를 나타내는 데 사용한다. 문자열은 0개 이상의 16비트 유니코드 문자의 집합으로 대부분의 문자 표현이 가능하다. 문자열은 작은따옴표, 큰따옴표 또는 백틱으로 텍스트를 감싼다. 자바스크립트에서 가장 일반적인 표기법은 작은따옴표를 사용하는 것이다. 1var string = 'String'; 템플릿 리터럴템플릿 리터럴은 멀티라인 문자열, 표현식 삽입, 태그드 템플릿 등 편리한 문자열 처리 기능을 제공한다. 멀티라인 문자열일반 문자열 내에서는 줄바꿈이 혀용되지 않는다. 일반 문자열 내에서 줄바꿈을 하려면 \\ 로 시작하는 이스케이프 시퀸스를 따라야한다. 이스케이스 시퀀스 의미 \\0 Null \\b 백스페이스 \\f 폼피드, 프린터로 출력할경우 다음 페이지의 시작 지점으로 이동한다. \\n 개행, 다음 행으로 이동 \\r 개행, 커서를 처음으로 이동 \\t 탭(수평) \\v 탭(수직) \\uXXXX 유니코드 ' 작은따옴표 &quot; 큰따옴표 \\ 백슬래쉬 123var templete = '&lt;ul&gt;\\n\\t&lt;li&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;\\a&gt;&lt;/li&gt;\\n&lt;/ul&gt;';console.log(templete); result 123&lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 표현식 삽입문자열은 + 기호를 사용해 연결할 수 있다. + 기호는 피연산자 중 하나 이상이 문자열일 때 문자연결 연산자로 통한다. 12345var first = 'Han';var last = 'Ju Ryeon';console.log('My Name is '+ first + ' ' + last);// My Name is Han Ju Ryeon 기호를 사용하여 문자열을 연결 할 수 있으며 템플릿 리터럴 내에서 표현식을 삽입하는 방식도 있다. 12345var first = 'Han';var last = 'Ju Ryeon;console.log(`My Name is ${first} ${lase}`);// My Name is Han Ju Ryeon 표현식을 삽입하기 위해서 ${}로 감싸면 된다. 불리언 타입불리언 타입의 값은 논리적 참, 거짓을 나타내는 true, false만 존재한다. 12345var foo = true;console.log(foo); // truefoo = false;console.log(foo); // false undefined 타입undefined 타입의 값은 undefined가 유일하다. var 키워드로 선언한 변수는 암묵적으로 undefined로 초기화가 된다. 이러한 이유로 값이 할당되지 않은 변수를 참조시 undefined가 출력된다. 12var foo;console.log(foo); // undefined undefined는 개발자가 의도적으로 할당하기 위한 값이 아니라 자바스크립트 엔진이 변수에 할당하는 것이므로 개발자가 직접 할당하는 것은 undefined의 취지에 어긋나며 혼란을 줄 수 있게되므로 권장하지 않는다. null 타입null 타입의 값은 null이 유일하다. 자바스크립트는 대소문자를 구분하므로 null, Null NULL은 모두 다르다.null은 변수에 값이 없다는 것을 의도적으로 명시 할 때 사용한다. 12345var foo = 'Lee';foo = null;// 이전 참조를 제거// foo 변수는 더이상 Lee 를 참조하지 않는다. 심벌 타입심벌은 ES6에서 추가된 타입으로 변경이 불가능한 원시적인 타입이다. 다른 값과 중복 되지 않는 유일한 값이기 때문에 주로 충돌 가능성이 없는 유일한 프로퍼티 키 값을 만들 때 주로 사용하게 된다. Symbol 함수를 호출하여 생성한다. 이때 생성된 값은 외부에 노출되지 않으며 다른 값과 중복되지 않는 값이다. 12var key = Symbol('key');console.log(type of key); // symbol","link":"/2021/09/10/js/javascript-%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%83%80%EC%9E%85/"},{"title":"javascript-렉시컬환경","text":"javascript 책 공부중 렉시컬 환경? 이라는 단어를 보고 이게 어떤것을 의미하는지 궁금하여 알아보았다. 역시 처음들어보는 생소한 의미였고 새로운것을 배웠다.렉시컬 환경에 대해 알아보자. 👍렉시컬 환경javascript에서 실행중인 함수, 코드 블록 { }, 스크립트는 렉시컬 환경이라 불리는 내부 숨김 연관 객체를 갖는다. 렉시컬 환경은 두가지로 나뉜다. 환경 레코드: 모든 지역변수를 프로퍼티로 저장하고 있는 객체. 외부 렉시컬 환경에 대한 참조: 외부 코드와 연관 환경 레코드 모든 지역변수를 프로퍼티로 저장하는 객체 this 값과 같은 기타 정보도 저장된다. 변수는 특수 내부 객체인 환경 레코드의 프로퍼티의 의미일 뿐이다. 변수를 가져오거나 변경하는 것은 환경 레코드의 프로퍼티를 가져오거나 변경하는 것이다. 외부 렉시컬 환경 외부 코드와 연결된다. 전역 렉시컬 환경1let a = 'hello'; 위와 같이 선언된 변수는 코드 전체와 관련된 변수로 전역 렉시컬 환경이라고 부른다. 스크립트 전체와 관련된 전역 렉시컬 환경은 외부 참조를 가지지 않는다. 함수의 렉시컬 환경함수는 선언과 동시에 렉시컬 환경이 만들어지는 즉시 사용히 가능하다.함수를 선언하면 함수는 젼역 렉시컬 환경이 된다. 이후 함수를 호출할때 함수를 위한 내부 렉시컬 환경과 내부 렉시컬 환경이 가르키는 외부 렉시컬 환경을 갖게 된다. 12345678let a = 'hello';function say (name) { // 함수 내부에서 내부 렉시컬 환경이 만들어짐 // 함수 호출시 내부 렉시컬 환경에는 name이라는 프로퍼티가 생성됨 // 또한 외부 렉시컬 환경을 참조한다. console.log(`${a} ${name}`);}say('jone'); 함수가 호출되고 내부 렉시컬 환경에 name이라는 프로퍼티를 생성하고 전역 렉시컬 환경을 외부 렉시컬 환경으로 참조한다.이 후 함수는 변수에 접근할때 내부 렉시컬 환경에서 변수에 먼저 접근하고 내부 렉시컬 환경에 해당하는 변수를 찾지 못하면 참조하고 있는 외부 렉시컬 환경으로 넘어가 변수를 찾는다. 이 과정은 전역 렉시컬 환경으로 확장 될 때까지 반복된다. 따라서 say함수는 a와 name변수를 찾아야한다. 이때 내부에서 먼저 name이라는 변수를 찾고 내부 렉시컬 환경에 존재하지 않는 a변수를 찾기위해 외부 렉시컬 환경에서 찾아 값을 참조하는 방식으로 진행된다. 함수를 반환하는 경우의 렉시컬 환경12345678function makeCounter() { let count = 0; return function () { return count++; }}let counter = makeCounter(); makeCounter함수가 호출되면 함수의 새로운 렉시컬 환경이 생성된다.makeCounter함수의 내부 렉시컬 환경에는 count라는 변수와 중첩함수가 만들어진다. 이때 생성한 중첩함수는 생성된 곳의 렉시컬 환경을 기억한다. 함수는 [[Environment]]이라는 숨김 프로퍼티를 가지는데 이것이 함수가 만들어진 곳의 렉시컬 환경에 대한 참조가 저장된다. 따라서 이 함수를 호출시 makeCounter의 내부 렉시컬 환경이 구성되고 내부의 중첩 함수는 자신이 생성된 외부 함수의 렉시컬 환경을 참조한다. 외부 함수의 내부 렉시컬 환경에 count라는 변수가 생성되고 중첩함수가 실행되는데 중첩 함수에서는 먼저 내부 렉시컬 환경에서 count라는 변수를 찾고 없기때문에 자신이 참조하는 외부 렉시컬 환경인 외부 함수의 렉시컬 환경에서 count변수를 찾아 증가시킨다.이러한 방식으로 인해 makeCounter함수가 호출 될때마다 count의 값은 증가한다.","link":"/2021/10/11/js/javascript-%EB%A0%89%EC%8B%9C%EC%BB%AC%ED%99%98%EA%B2%BD/"},{"title":"javascript-생성자 함수를 사용하여 객체 생성하기","text":"생성자 함수에 대한 객체 생성생성자 함수를 사용하여 객체를 생성 방식에는 Object 생성자 함수를 사용하는 방법이 있다. Object 생성자 함수를 사용하는 방법 new 연산자와 함께 Object 생성자 함수를 호출하여 빈 객체를 생성한다.이때 객체를 생성하고 프로퍼티나 메서드를 추가하여 객체를 완성시키면 된다. 12345678910111213const person = new Object();// new Object 함수를 호출하면 빈객체가 생성된다.console.log(person); // {}// 빈객체에 프로퍼티를 추가한다.person.name = 'hanjuren';person.getName = function () { console.log(`Hello My Name is ${this.name}`);};console.log(person); // { name: 'hanjuren', getName: f }console.log(person.getName()); // Hello My Name is hanjuren 생성자 함수에 의해 생성된 객체를 인스턴스라고 부른다. 생성자 함수의 종류는 다음과 같다. String Number Boolean Function Array Date RegExp Promise 생성자 함수를 호출하여 객체를 생성하는 것은 객체 리터럴을 사용하여 생성하는 것보다는 비효율적이므로 필요한 상황이 아니라면 바람직 한 생성방식은 아니다. 생성자 함수생성자 함수를 사용한 객체 생성 방식의 장점 동일한 구조를 가진 객체를 여러개 생성할떄 효율 적이다. 예를 들어 원의 반지름을 가진 객체를 두개 이상 생성해야 할 때 원하는 만큼 객체 리터럴을 사용하여 하나하나 생성을 해주어야 한다. 12345678910111213const circle1 = { radius: 5, getDiameter() { return 2 * this.radius; },};const circle2 = { radius: 10, getDiameter() { return 2 * this.radius; },} 두 객체의 반지름은 5와 10으로 각각 다른 값을 가지지만 지름을 반환하는 메서드는 동일한 내용을 포함한다.동일한 메서드나 구조를 가진 객체를 다수 생성할 때 생성자 함수를 통해 객체를 생성하는 것은 효율적인 방식으로 작동하게 된다. 1234567891011121314151617// 동일한 구조를 가진 객체를 생성자 함수로 여러개 생성하기function Circle(radius) { this.radius = radius; this.getDiameter = function() { return 2 * this.radius; };};const circle1 = new Circle(5); // 반지름이 5인 객체를 생성const circle2 = new Circle(10); // 반지름이 10인 객체를 생성console.log(circle1); // Circle { radius: 5, getDiameter: [Function (anonymous)] }console.log(circle2); // Circle { radius: 10, getDiameter: [Function (anonymous)] }console.log(circle1.getDiameter()); // 10console.log(circle2.getDiameter()); // 10 내부 메서드 [[Call]], [[Construct]]함수 객체는 일반 객체가 가지고 있는 내부슬롯, 내부 메서드를 모두 가지고 있기 때문에 일반 객체와 동일하게 작동이 가능하다.하지만 객체는 호출이 불가능 하고 함수는 호출이 가능하다. 그 이유는 함수는 함수로서 동작하기 위한 내부 슬롯과 내부 메서드를 가지고 있기 때문이다. 함수가 동작하기 위한 내부슬롯 [[Environment]] [[FormalParameters]] … 내부 메서드 [[Call]] [[Construct]] 함수가 호출되어 동작하기 위해 [[Call]] 내부 메서드를 가진 함수를 callable이라 부르며 [[Construct]] 내부 메서드를 가진 함수를 constructor 없는 함수를 non-constructor이라고 부른다. constructor 함수 : 생성자 함수로서 호출이 가능한 함수non-constructor 함수 : 생성자 함수로서 호출이 불가능한 함수 constructor와 non-constructor을 구분하는 방식은 자바스크립트 엔진이 함수 정의를 평가하여 구분지어준다. constructor : 함수 선언문, 함수 표현식, 클래스 non-constructor : 화살표 함수, 메서드(Es6 메서드 축약 표현) constructor 123456789function foo() {};const joo = function() {};const boo = { x: function() {},};console.log(new foo());console.log(new joo());console.log(new boo.x()); non-constructor 1234567const aoo = () =&gt; {};const noo = { x() {},};console.log(new aoo()); // Type Errorconsole.log(new noo.x()); // Type Error","link":"/2021/11/06/js/javascript-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%EA%B0%9D%EC%B2%B4-%EC%83%9D/"},{"title":"javascript-스코프","text":"스코프스코프 (유효범위)는 javascript를 포함한 모든 프로그래밍 언어의 기본적이고 중요한 개념이다. 123456789function add (x, y) { // 매개변수는 함수 몸체 내에서만 참조가 가능하다. // 따라서 매개변수의 스코프는 함수 내부다. console.log(x, y); return x + y;}add (1, 2);console.log(x, y); // Error 스코프 유효범위를 벗어남 변수는 코드의 가장 바깥쪽에 함수 내부에 또는 코드블록에서 선언될 수 있다. 이렇게 선언된 변수는 변수가 선언된 위치에 따라서 스코프가 결정된다. 모든 식별자가 자신의 선언된 위치에서 스코프를 결정한다. 123456789var x = 'global';function foo () { var x = 'local'; console.log(x); // local}foo();console.log(x); // global 위의 예제를 보면 동일한 이름을 가진 변수 x를 선언했고 함수내부, 외부에서 각각 참조를 한다. 이때 자바스크립트 엔진은 같은 두이름 중 어떤 것을 참조할지 결정한다. 이를 식별자 결정이라고 한다. 이때 엔진은 스코프를 규칙으로 삼아 참조할 변수를 결정한다. 즉 스코프는 식별자를 검색할 때 사용하는 규칙이라고도 할 수 있다. 코드의 문맥과 환경코드가 어디서 실행되는지 주변에 어떤 코드가 있는지를 렉시컬 환경이라고 부른다. 스코프의 종류코드는 전역과 지역으로 구분할 수 있다. 구분 설명 스코프 변수 전역 코드의 가장 바깥 영역 전역 스코프 전역 변수 지역 함수의 몸체 내부 지역 스코프 지역 변수 전역과 지역 스코프123456789101112131415161718192021222324var x = 'global 1';var y = 'global 2';function outer () { var z = 'inner 1'; console.log(x); console.log(y); console.log(z); function inner () { var x = 'inner 2'; console.log(x); console.log(y); console.log(z); } inner();}outer();console.log(x);console.log(y);console.log(z); 전역이란 코드의 가장 바깥 부분을 말한다. 해당 스크립트에서 전역 변수는 1,2줄에서 선언된 x,y 변수이다. 이렇게 전역으로 선언된 전역 변수는 어디에서든 참조가 가능하다.따라서 outer()함수 inner()함수에서도 참조가 가능하여 해당 값이 출력된다.outer함수내부에 선언된 z변수는 함수내부의 지역 변수이고 이 변수는 함수 몸체 내부에서만 참조가 가능하다. 코드의 마지막 줄에서 참조한 z라는 변수는 전역으로 선언되지 않았기 때문에 참조 에러가 난다.inner함수또한 지역 변수로 x를 선언한다. inner함수에서 콘솔로 출력하는 x는 내부에 선언된 지역 변수 x를 출력하고 내부에 선언되진 않는 값들을 외부에서 찾아 출력한다.이때 변수를 찾는 방식이 렉시컬 환경에 의해 내부 렉시컬 환경에서부터 전역 렉시컬 환경까지 확장되어 순차적으로 변수를 참조하게 된다. 스코프 체인함수는 전역, 함수 몸체 내부에서 모두 선언이 가능하다. 함수는 중첩이 가능하므로 함수의 스코프 또한 중첩이 가능하다. 이는 스코프가 계층적 구조를 갖는다는 의미이다.모든 스코프는 하나의 계층적 구조로 연결되며 최상위 스코프는 전역 스코프다. 이러한 구조를 스코프 체인이라 한다. 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프부터 상위 스코프 방향으로 이동하여 변수를 검색한다. 스코프 체인에 의한 변수 검색위에서 선언한 스크립트를 보면 전역 스코프로 선언한 변수를 지역 스코프에서 참조가 가능하지만 지역 스코프로 선언된 변수를 상위 스코프에서는 참조가 불가능하다.계층적 구조를 갖는 스코프는 상위 스코프를 하위 스코프에서 참조하는 것은 가능하지만 하위 스코프에서 선언된 변수를 상위 스코프에서는 참조가 불가능 하다는 것을 의미한다. 스코프 체인에 의한 함수 검색12345678910111213// 전역 함수function foo () { console.log('global function');}function bar () { // 중첩 함수 function foo () { console.log('local function'); } foo();}bar(); bar함수에서 호출하는 foo함수는 전역으로 선언된 foo함수를 호출하는 것이 아닌 내부에 있는 foo함수를 먼저 호출하게 된다. 이는 변수와 마찬가지로 함수또한 식별자에 해당하기 때문에 스코프를 갖는다는 의미이다. 렉시컬 스코프123456789101112var x = 1;function foo() { var x = 10; bar();}function bar () { console.log(x);}foo();bar(); 위 스크립트의 상위스코프를 예측해보면 두가지 패턴이 예측된다. 함수를 호출한 곳에서 상위스코프를 결정 함수를 정의한 곳에서 상위 스코프를 결정 첫 번째 방식은 동적 스코프라고 부른다. 함수가 호출된 곳에서 상위 스코프를 결정한다면 bar함수가 호출된 foo함수가 bar함수의 상위 스코프가 될것이다.두 번째 방식을 렉시컬 스코프, 정적 스코프라고 한다. 이는 함수가 정의되어 평가되는 시점에 스코프를 결정하는 방식이다. 대부분의 프로그래밍 언어는 렉시컬 스코프 방식을 따르고 있다. 따라서 해당 스크립트를 실행하면 전역 스코프로 선언된 변수의 값이 1이 두번 출력된다.foo함수를 호출하면 젼역으로 선언한 함수인 bar함수를 호출하고 bar함수는 x라느 변수를 참조하기 위해 내부에서 검색한후 외부 스코프의 x를 참조하기 때문이다.","link":"/2021/10/11/js/javascript-%EC%8A%A4%EC%BD%94%ED%94%84/"},{"title":"javascript 연산자","text":"연산자.연산자란 하나이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행하여 하나의 값을 만드는 행위이다.이때 연산의 대상을 피연산자라 한다. 피연산자는 값으로 평가될 수 있는 표현식이여야 한다. 그리고 피연산자와 연산자의 조합으로 이루어진 연산자 표현식도 값으로 평가될 수 있는 표현식이다. 1234567891011121314151617// 산술 연산자5 * 4 //20// 문자열 연결 연산자'Hello' + 'World' // Hello World// 할당 연산자color = 'red' // -&gt; red// 비교 연산자3 &gt; 5 // false// 논리 연산자true &amp;&amp; false // false// 타입 연산자typeof 'Hi' // string 산술 연산자산술 연산자는 피연산자를 대상으로 수학적 계산을 수행하여 새로운 숫자 값을 만든다. 산술 연산이 불가능한 경우 NaN을 반환해준다. 이항 산술 연산자이항 산술 연산자는 2개의 피연산자를 산술 연산하여 값을 만들어낸다.이항 산술 연산자는 어떤 산술 연산을 해도 피연산자의 값이 바뀌지 않고 새로운 값을 만들어 낸다. 즉 부수효과가 없다. 이항 산술 연산자 의미 부수효과 + 덧셈 X - 뺼셈 X * 곱셈 X / 나누기 X % 나머지 X 단항 산술 연산자단항 산술 연산자는 1개의 피연산자를 산술 연산하여 값을 만든다. 단항 산술 연산자 의미 부수효과 ++ 증가 O – 감소 O + 어떠한 효과도 없음 X - 양수를 음수로 음수를 양수로 반전한 값을 반환 X 12345678var x = 1;// ++ 연산자는 피연산자의 값을 증가시킨다.++x;console.log(x); // 2// -- 연산자는 피연산자의 값을 감소시킨다--x;console.log(x); // 1 문자열 연결 연산자+ 연산자는 피연산자 중 하나 이상이 문자열인 경우에 문자열 연결 연산자로 작동한다. 123456789101112131415161718// 문자열 연결 연산자'1' + 2; // 121 + '2'; // 12// 산술 연산자1 + 2; // 3// true는 1로 타입 변환 된다.1 + true; // 2// false는 0 으로 타입 반환 된다.1 + false; // 1// null은 0으로 타입 변환 된다.1 + null; // 1// undefinde는 숫자로 타입 변환 되지 않는다.+undefinde; // NaN 위의 과정에서 중요한것은 자바스크립트 엔진에 의해 의도와 상관없이 타입이 변환 된다는 것이다. true가 1로 변환되는 것 처럼 말이다.이를 암묵적 타입 변환 또는 타입 강제 변환 이라고 한다. 할당 연산자할당 연산자는 우항에 있는 피연산자의 평과 결과를 좌항에 있는 변수에 할당해준다. 할당 연산자는 좌항의 변수에 값을 할당하여 값이 변하므로 부수 효과가 있다. 할당 연산자 예 동일 표현 부수효과 = x = 5 x = 5 O += x += 5 x = x + 5 O -= x -= 5 x = x - 5 O *= x *= 5 x = x * 5 O /= x /= 5 x = x / 5 O %= x %= 5 x = x % 5 O 표현식은 값으로 평가 될 수 있는 문이고 문에는 표현식인 문과 표현식이 아닌 문이 있다 12var x;console.log(x + 10); // 10 할당문은 변수에 값을 할당하므로 갑으로 평가되는 표현식인 문으로서 할당된 값으로 평가된다. 이러한 특징으로 인해 동일한 값을 여러 변수에 연쇄 할당이 가능하다. 비교 연산자비교 연산자는 좌항 우하의 피연산자를 비교하여 결과를 불리언 타입으로 반환한다. 동등/일치 비교 연산자동등 비교연산자와 일치 비교 연산자는 좌항과 우항의 피연산자가 같은 값으로 평가되는지 비교한다. 비교연산자 의미 사례 설명 부수효과 == 동등 비교 x == y x와 y의 값이 같음 X === 일치 비교 x === y x와 y의 값과 타입이 같음 X !== 부동등 비교 x != y x와 y의 값이 다름 X !=== 불일치 비교 x !=== y x와 y의 값과 타입이 다름 X 동등 비교 연산자는 좌항과 우항의 피연산자를 비교할 때 먼저 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교한다.따라서 동등 비교 연산자는 타입이 다르더라도 같은 값일 경우 true를 반환한다. 1235 == 5; // true5 == '5'; // true 동등 비교연산자는 예측하기 어려운 결과를 만들어 낼 가능성이 높으므로 일치 비교연산자를 사용하는 것이 좋다.일치 비교 연산자는 좌항과 우항의 피연산자가 타입도 같고 값도 같은 경우에 한해 true를 반환한다 1235 === 5; // true5 === '5'; // false 대소 비교 연산자대소 비교 연산자는 피연산자의 크기를 비교하여 불리언 값을 반환한다. 12345 &gt; 0; // true5 &lt; 0; // false5 &lt;= 0 // false5 &gt;= 0 // true 삼항 조건 연산자삼항 조건 연산자는 조건식의 평가 결과에 따라 반환할 값을 결정한다. 자바스크립트의 유일한 삼항 연산자이며 다음과 같이 사용한다. 1조건식 ? 조건식이 true 일때 반환할 값 : 조건식이 false 일때 반환할 값; 삼항 조건 연산자는 첫 번째 피연산자가 true 일때는 두번째 피연산자를 반환 false 일때는 세번째 피연산자를 반환한다. 삼항 조건 연산자는 if else문과 비슷하게 사용하지만if else문은 표현식이 아닌 문이라는 차이점이 있다. if 문의 결과를 값으로 사용할 수 없는 것과 삼항 조건연산자의 반환 값을 값으로 사용할 수 있다는 차이가 있다. 논리 연산자논리 연산자는 우항과 좌항의 피연산자를 논리 연산한다. 논리 연산자 의미 부수효과 || 논리합(OR) X %% 논리곱 X ! 부정 X 123456789101112131415// 논리합 연산자true || true; // truetrue || false; // truefalse || true; // truefalse || false // false// 논리곱 연산자true &amp;&amp; true; // truetrue &amp;&amp; false; // falsefalse &amp;&amp; true; // falsefalse &amp;&amp; false; // false// 논리 부정 연산자!true; // false!false; // true 논리 부정 연산자는 언제나 불리언 타입을 반환하며 피연산자가 불리언 값이 아닐경우 암묵적 타입 변환을 하여 비교를 한다. 쉼표 연산자쉼표 (,) 연산자는 왼쪽 부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환 한다. 그룹 연산자소괄호로 () 피연산자를 감싸는 경우 자신의 피연산자인 표현식을 가장 먼저 평가한다. 12310 * 2 + 3; //2310 * (2 + 3); // 50 type of 연산자typeof 연산자는 피연산자의 데이터 타입을 반환한다. 반환하는 타입은 number, string, boolean, undefined, symbol, object, function중 하나를 반환하며 null을 반환하지 않는다. typeof 연산자로 null을 평가하면 object 타입으로 반환된다. 이는 자바스크립트 초기 버그이며 기존 코드에 영향을 미칠 수 있어 고쳐지지 않았다. 지수 연산자ES7에서 도입된 지수 연산자는 좌항의 피연산자를 밑으로 우항의 피연산자를 지수로 거듭 제곱하여 숫자값을 반환해준다. 12342 ** 2; // 42 ** 2.5; //5.6568..2 ** 0; // 12 ** -2; //0.25 연산자의 우선순위 우선순위 연산자 1 () 2 new(매개변수의 존재), . , [](프로퍼티의 접근), ()(함수 호출), ? .(옵셔널 체이닝 연산자) 3 new(매개변수의 미존재) 4 x++, x– 5 !x, +x, -x, –x, typeof, delete 6 **(이항 연산자중에서 가장 높다) 7 *, /, % 8 +, - 9 &lt;, &lt;=, &gt;, &gt;=, ㅑㅜ, instanceof 10 ==, !=, ===, !== 11 ??(null 병합 연산자) 12 &amp;&amp; 13 14 ? … : … 15 할당 연산자 16 ,","link":"/2021/09/12/js/javascript-%EC%97%B0%EC%82%B0%EC%9E%90/"},{"title":"javascript 원시값과 객체의 비교","text":"원시값과 객체의 비교원시 타입과 객체 타입의 차이점 원시 타입의 값은 변경 불가능한 값이다. 객체 타입의 값은 변경가능한 값이다. 원시 값을 변수에 할당하면 변수에는 실제 값이 저장된다. 객체를 변수에 할당하면 변수에는 참조 값이 저장된다. 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달된다. 이를 값에 의한 전달이라 한다. 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 참조에 의한 전달이라 한다. 원시 값변경 불가능한 값원시타입 : 변경 불가능한 값변경이 불가능한 값이라는 것은 변수란 값을 저장하기 위한 메모리의 공간 자체 또는 공간을 식별하기 위한 이름이고 값은 저장된 데이터이다. 즉 변경 불가능하다는 것은 변수가 아닌 값에대한 이야기이다. 변경이 불가능한것은 상수와 같은 맥락이긴 하지만 원시값은 재할당시 값이 바뀌지 않고 새로운 공간에 값을 저장하지만 상수는 재할당이 안되므로 둘의 개념이 완벽히 일치하는 것은 아니다. 12345const a = {};a.first = 1;// const 키워드를 사용하여 선언한 변수에 할당한 값은 변경이 불가능하다.// 하지만 const 키워드를 사용한 변수에 할당한 객체는 변경이 가능하다. 변수에 할당한 값은 원시 값으로 한번 할당하면 그 값의 변경이 불가능하다. 변수에 값을 재할당시 기존에 값이 저장되어있던 메모리 주소에 새로운 값을 갱신하는 것이 아닌 새로운 메모리 공간에 저장하고 그 메모리 주소를 가리키게 되는데 값의 이러한 특성을 불변성이라고 한다. 문자열과 불변성자바스크립트에서 문자열은 원시타입으로 제공된다. 문자열 타입은 원시 타입이며 변경이 불가능하다. 이것은 문자열이 생성된 이후에는 변경이 불가능하다는 것이다. 12var str = 'hello';str = 'world'; 위의 코드는 str이라는 변수를 생성하고 hello라는 값을 할당하여 str이 hello가 저장된 메모리공간을 참조하게 된다. 이후 str에 world라는 값을 재할당시 str은 새로 할당한 값의 주소를 가리키게 된다. 문자열은 유사 배열 객체로도 사용이 가능하다.유사 배열 객체란 배열처럼 인덱스로 프로퍼티에 접근이 가능하며 length프로퍼티를 가지는 객체를 의미한다. 12345var str = 'hello';console.log(str.length); // 5console.log(str[0]); // h 이처럼 각 인덱스로 프로퍼티에 접근이 가능하다. 하지만 문자열은 원시 값이기 때문에 프로퍼티의 값을 변경 할 수 없다. 오로지 재할당으로만 값을 변경할 수 있는것이다. 값에 의한 전달12345678910var a = 80;var b = a;console.log(a);console.log(b);a = 100;console.log(a);console.log(b); a라는 변수에 80을 할당하고 b에 a가 참조하는 값을 할당해준다. a와 b는 모두 80이라는 값을 가진 변수가 된다. 이후 a의 값을 100으로 재할당시 a는 100의 값을 가지고 b는 80값을 그대로 유지한다.할당되는 변수의 값이 원시 값이기 때문에 새로 할당하는 모든 값들은 각각 다른 메모리 공간에 저장되며 참조하기 때문이다.a와 b가 같은 80의 값을 가지더라도 두 변수가 가리키는 메모리의 주소는 다르다는 의미이다. 또다른 의미로는 변수에 값이 전달되는 것이 아닌 메모리 주소가 전달된다라고 볼 수도 있다. 12var a = 100;var b = a; a에 100이라는 값을 할당하고 a는 100이 저잗되어있는 메모리 주소를 가리킨다.b에 a가 가리키는 메모리 주소를 전달하여 b도 a가 가리키는 메모리 주소를 같이 공유한다.이렇게 되면 두 변수의 값이 재할당 되는 시점 전까지는 두 변수는 각자의 식별자를 통해 한 곳의 메모리 주소를 가리키게 되어 값이 같다. 이처럼 값에 의한 전달도 값을 전달하는 것이 아니라 메모리 주소를 전달한다 단 전달된 메모리 주소를 통해서 메모리 공간에 접근하여 값을 참조한다. 객체자바스크립트의 객체 관리 방식객체는 프로퍼티 키를 인덱스로 사용하는 해시 테이블이라고 생각하면된다. 자바스크립트에서는 높은 성능을 위해 일반적인 해시테이블보다 나은 방법으로 객체를 구현해낸다. 해시테이블이란 키 값으로 데이터를 저장하는 자료구조중 하나이다. 변경 가능한 값객체 타입의 값은 변경이 가능한 값이다. 123var person = { name: 'Lee',}; 객체를 변수에 할당하면 변수가 기억하는 메모리의 주소를 통해 접근하면 참조 값에 의해 객체에 접근이 가능해진다.원시값을 할당한 변수를 참조하게 될때 메모리에 저장되어있는 참조 값을 통해 실제 객체에 접근하게 되는 것이다. 1234567// 할당이 이루어 지는 시점에 객체 리터럴이 생성되고 그 결과로 객체가 생성된다.var person = { name: 'Lee',};// person 변수에 저장되어있는 참조 값으로 객체에 접근한다.console.log(person); // { name: 'Lee' } 원시값은 재할당 외에는 변경할 수 있는 방법이 없다. 하지만 객체는 재할당없이 객체를 직접 변경할 수 있다. 1234567891011var person = { name: 'Lee'};// 프로퍼티 값 변경person.name = 'Kim';// 프로퍼티 동적 생성person.address = 'seoul';console.log(person); // { name: 'Kim', address: 'seoul' } 객체는 메모리의 효율적인 사용을 위해 값을 변경이 가능하게 설계가 되어있다. 하지만 이러한 객체의 단점은 여러 식별자가 하나의 객체를 공유 할 수 있다는 것이다. 앝은 복사, 깊은 복사 123456789101112131415161718const _ = require('lodash');const o = { x: { y: 1 } };&gt;// 얕은 복사const c1 = { ...o };console.log(o);console.log(c1);console.log(c1 === o);console.log(c1.x === o.x);// 깊은 복사const c2 = _.cloneDeep(o);console.log(o);console.log(c2);console.log(c2 === o);console.log(c2.x === o.x); 실행결과 12345678{ x: { y: 1 } }{ x: { y: 1 } }falsetrue{ x: { y: 1 } }{ x: { y: 1 } }falsefalse 얕은 복사와 깊은 복사로 생성된 객체는 원본과는 다른 객체이다. 하지만 얕은 복사는 객체에 중첩되어있는 객체의 참조값을 복사하고 깊은 복사는 모두 복사하여 새로운 복사본을 만드는 차이점이 있다. 참조에 의한 전달12345var person = { name: 'Lee',};var copy = person; 객체를 가리키는 변수 person을 copy라는 변수에 할당하면 원본의 참조값이 복사되어 전달 된다. 이를 참조에 의한 전달이라고 한다. person과 copy는 다른 메모리 주소를 가지고 있지만 동일한 참조값을 가진다. 이렇게 되면 한 곳에서 프로퍼티의 값을 추가 삭제 변경 할때 다른 곳도 영향을 받게 된다. 123456789101112var person = { name: 'Lee',};var copy = person;console.log(copy); // { name: 'Lee' }copy.name = 'Kim';copy.address = 'seoul';console.log(person); // { name: 'Kim', address: 'seoul' }","link":"/2021/09/28/js/javascript-%EC%9B%90%EC%8B%9C%EA%B0%92%EA%B3%BC-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EB%B9%84%EA%B5%90/"},{"title":"javascript-전역변수의 문제점","text":"전역변수의 문제점변수의 생명주기 변수는 선언에 의해 생성되고 할당을 통해 값을 가진다. 변수는 언젠가 소멸한다. 전역변수의 생명주기는 애플리케이션의 생명주기와 같다. 함수 내에서 생성된 지역변수는 함수 호출시 선언문이 실행되고 함수 종료시 소멸된다. 즉 지역변수의 생명 주기는 함수의 생명 주기와 같다. 전역 변수의 문제점 암묵적 결합전역변수의 의도는 코드 어디서든 참조할 수 있는 변수를 만든다는 의미이다. 이는 모든 코드가 이를 참조하고 값을 변경할 수 있는 암묵적 결합을 의미한다.변수의 유효범위가 클수록 코드의 가독성이 나빠지고 의도치 않은 값 변경이 일어날 수 있다. 긴 생명 주기전역 변수는 생명주기가 길다. 즉 메모리 소비 시간이 길다.var 키워드로 생성된 변수는 중복을 혀용하므로 전역변수는 변수 이름이 중복될 가능성이 크다. 의도치 않게 변수가 중복되면 값이 변경된다. 스코프 체인 상에서 종점에 존재전역 변수는 스코프 상에서 종점에 존재한다. 이는 변수의 검색시 가장 마지막 단계에서 검색이 된다는 것이다. 따라서 검색 속도가 가장 느리다. 네임스페이스 오염파일을 분리해도 하나의 전역 스코프를 공유 한다는 것에서 다른 파일 내에 동일한 변수가 스코프내에 존재할 수 있다는 문제점이 있다. 전역 변수의 사용을 억제하는 방법전역 변수는 꼭 필요한 상황이 아니라면 지역변수를 활용해야 한다. 무조건 적인 지역변수으 사용을 권장하지 않지만 무분별한 전역 변수의 사용은 자제하는 것이 바람직하다. 즉시 실행 함수함수의 정의와 동시에 실행되는 즉시 실행 함수에서 모든 코드를 즉시 실행 함수로 감싸면 모든 변수가 즉시 실행 함수의 지역 변수로만 사용이 가능하다. 이방법은 주로 라이브러리 같은 곳에서 사용하는 모습을 볼 수 있다. 네임스페이스 객체전역에 네임스페이스 역할을 담당할 객체를 생성하고 전역 변수처럼 사용하려하는 변수를 프로퍼티로 추가하는 방법. 1234var MYAPP = {}; // 전역 네임스페이스 객체MYAPP.name = 'Lee';console.log(MYAPP.name); // Lee 이방법은 네임스페이스로 분리하여 식별자의 충돌을 억제하는 장점이 있지만 네임스페이스 객체 자체가 전역 변수에 할당되기 때문에 유용한 방법은 아니다. 모듈 패턴 모듈 패턴이란 클래스를 모방하여 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만드는 방식이다. 모듈 패턴은 전역 변수의 억제, 캡슐화 구현의 특징을 가진다. 1234567891011121314151617var Counter = (function () { var num = 0; // private 변수 return { in() { return ++num; }, out() { return --num; } }}());console.log(Counter.num);console.log(Counter.in());console.log(Counter.out());console.log(Counter.out()); ES6 모둘ES6 모듈을 사용하게 되면 전역변수를 사용할 수 없다. ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공한다. ES6 모듈은 모던 브라우저( 크롬, 엣지16이상 )등에서 사용이 가능하며 IE를 포함한 구형 브라우저에서는 작동하지 않는다.","link":"/2021/10/12/js/javascript-%EC%A0%84%EC%97%AD%EB%B3%80%EC%88%98%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90/"},{"title":"javascript 제어문","text":"제어문제어문은 조건에 따라 코드블록을 실행하거나 반복 실행할 때 사용한다.일반적인 실행 순서는 위에서 아래이며 제어문을 사용하면 순서를 인위적으로 제어 할 수 있다. 블록문블록문이란 0개 이상의 문을 중괄호로 묶은 것으로 코드 블록, 블록 이라고 부른다. 자바스크립트에서는 블록문 하나를 실행단위로 취급한다.블록문은 단독으로 사용이 가능하나 제어문, 함수정의시 사용하는 것이 일반적인 사용방법이다. 123456789{ var foo = 10;}// 제어문var x = 1;if (x &lt; 10) { x++;} 조건문조건문은 조건식의 결과에 따라 코드 블록의 실행을 결정한다. 자바스크립트에서는 if…else문과 switch문 두가지의 조건문을 제공한다. if…else문12345if (조건식) { // 조건식이 참일경우 이 코드블럭이 실행됨} else { // 조건식이 거짓일경우 이 코드블럭이 실행된다.} if…else문은 주어진 조건식의 평과결과를 통해 실행할 코드블럭을 결정한다. 이때 평과 결과는 불리언 타입으로 평가되어야 한다.조건식을 추가하여 실행할 코드블록을 늘리고 싶다면 else if문을 사용한다. 1234567if (조건식1) { // 조건식 1이 참일 경우} else if (조건식2) { //조건식2가 참일 경우} else { // 조건식 1, 조건식2가 모두 거짓일때 실행} 대부분의 if…else문은 삼항 조건 연산자로 바꿔 사용이 가능하다. 123456789101112131415var x = 2;var result;if (x % 2) { result = '홀수';} else { result = '짝수';}console.log(result);// 삼항 조건 연산자로 사용var x = 2;var result = x % 2 ? '홀수' : '짝수';console.log(result); 조건에 따라 값을 결정하여 변수에 할당하는 경우에는 삼항 조건 연산자를 사용하는 편이 가독성이 좋고 조건에 따라 실행해야하는 내용이 많거나 복잡한경우 if…else문을 사용하는 것이 가독성이 좋다. switch문switch문은 주어진 표현식을 평가하여 그 값과 일치하는 표현식을 갖는 case문으로 실행의 흐름을 옮겨 실행된다. 12345678910switch (표현식) { case 표현식1 : switch문의 표현식과 표현식1이 일치시 실행될 문; break; case (표현식2) : switch문의 표현식과 표현식2가 일치시 실행될 문; break; default : switch문의 표현식과 일치하는 표현식이 없을때 실행될 문;} switch문의 표현식은 불리언 값보다는 문자열이나 숫자 값이 경우에 많이 사용한다. switch문을 이용한 윤년계산 예제. 1234567891011121314151617181920// 연도가 4로 나누어 떨어지는 해는 윤년이다.// 4로 나누어 떨어지지만 100으로 나누어 떨어지는 해는 평년이다.// 연도가 400으로 나누어 떨어지는 해는 윤년이다.var year = 2021;var month = 2;var days = 0;switch (month) { case 1: case 3: case 5: case 7: case 8: case 10: case 12: days = 31; break; case 4: case 6: case 9: case 11: days = 30; break; case 2: days = ((year % 4 === 0 &amp;&amp; year % 100 !== 0) || (year % 400 === 0)) ? 29 : 28; break;}console.log(days); // 28 반복문반복문은 조건식의 평과 결과가 참인 경우 코드블럭을 실행한다. 그 후 여전히 조건식이 참인경우 코드블럭을 다시 실행한다. 자바스크립트에서는 베열을 순회할 때 사용하는 forEach메서드 객체의 프로퍼티를 열거할때 사용하는 for…in문 과 같은 반복문을 대체할 수 있는 다양한 기능을 제공한다. for문for문은 조건식이 거짓으로 평가될 때까지 코드블록을 반복 실행한다. 가장 일반적으로 사용되는 for문의 형태는 다음과 같다. 123for (변수 선언문 또는 할당문; 조건식; 증감식;) { 조건식이 참일 경우 반복 실행될 문;} for문의 실행법 123for (var i = 0; i &lt; 2; i++) { console.log(i);} 실행순서 for문을 실행하면 변수 선언문이 실행된다. 변수 선언은 한번만 실행된다. 변수 선언문이후 조건식이 실행된다. 조건문의 평과 결과가 true일때 코드블록이 실행된다. 코드블록의 실행이 종료되면 증감식이 실행된다. 증감식 실행 이후 평과 결과가 true면 코드블럭을 실행 false면 반복문에서 빠져나온다. while문while문은 조건식의 평과 결과가 참이면 코드블럭을 반복하여 실행한다. for문은 반복 횟수가 명확할때 주로 사용하며 while문은 횟수가 불명확 할때 주로 사용한다. 123456var count = 0;while (count &lt; 3) { console.log(count); count++;} 조건식이 참일경우 반복하여 실행이 된다. 조건식의 평과 결과가 항상 true일 경우에 무한루프가 된다. do…while문do…while문은 코드블록을 먼저 실행하고 조건식을 평가한다. 따라서 코드블록이 한번이상 무조건 실행이 된다. 123456var i = 0;do { console.log(i); i++;} while (i &lt; 3); break문break문은 반복문, 레이블문에서의 코드블록을 탈출하는 역할을 한다. 레이블문이란 식별자가 붙은 문을 의미한다. 123456outer : for (var i = 0; i &lt; 3; i++) { for (var j = 0; j &lt; 3; j++) { if (i + j === 3) break outer; console.log(`${i} ${j}`); }} continue문continue문의 반복문은 코드블록의 실행을 현 지점에서 중지하고 반복문의 증감식으로 실행흐름을 이동시킨다. 123456789101112var string = 'heLlo world';var search = 'l';var count = 0;for (var i = 0; i &lt; string.length; i++) { if (string[i] !== search) continue; count++;}console.log(count);const re = new RegExp(search, 'g');console.log(string.match(re).length);","link":"/2021/09/14/js/javascript-%EC%A0%9C%EC%96%B4%EB%AC%B8/"},{"title":"javascript 타입변환과 단축평가","text":"타입 변환과 단축 평가타입 변환이란자바스크립트의 모든 값은 타입이 존재한다. 값의 타입을 개발자가 의도적으로 변환하는 것을 명시적 타입 변환, 타입 캐스팅이라 한다. 12345var x = 10;// 명시적 타입변환 - 숫자를 문자열로 var str = x.toString();console.log(type of str, str); // string, 10 개발자의 의도와 상관없이 표현식을 평가하는 도중 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되는 상황이 생긴다. 이를 암묵적 타입 변환, 타입 강제 변환이라 한다. 123456var x = 10;// 암묵적 타입 변환// 문자열 연결 연산자는 숫자 타입 x를 바탕으로 새로운 문자열을 생성한다.var str = x + '';console.log(type of str, str); // string, 10 명시적 타입 변환, 암묵적 타입 변환은 기존 원시 값을 변경하는 것이 아닌 기존 원시 값을 기준으로 다른 타입의 새로운 값을 생성하는 것이다. 암묵적 타입 변환자바스크립트 엔진이 표현식을 평가시 개발자의 의도와 상관없이 코드의 문맥을 고려하여 암묵적으로 타입을 강제 변환하는 것. 123'10' + 2 // 1025 * '10' // 510 이처럼 표현식을 평가할 때 코드의 문맥에 부합하지 않는 상황이 발생할 수 있다. 이때 에러를 발생시키기도 하지만 자바스크립트가 가급적 암묵적 변환을 통해 표현식을 평가한다. 명시적 타입 변환개발자의 의도에 따라 명시적으로 값의 타입을 변경하는것. 문자열 타입으로 변경시 String 생성자 함수를 이용, Object.prototype.toString 메서드를 이용, 문자열 연결 연산자를 이용하는 방법들이 있다. 숫자 타입으로 변경시 Number 생성자 함수를 이용, parseInt.parseFloat 함수를 사용하는 방법, + 단항 산술 연산자를 사용하는 방법, * 산술 연산자를 이용하는 방법 불리언 타입으로 변경시 Boolean 생성자 함수를 이용하는 방법 ! 부정 논리 연산자를 두번 사용하는 방법이 있다. 단축 평가1'Cat' &amp;&amp; 'Dog' // &quot;Dog&quot; 논리곱 연산자는 두개의 피연산자가 모두 true일때 true를 반환해준다. 평가 순서에 따라 좌항의 값인 Cat은 true로 평가된다. 하지만 두번째 피연산자가 논리곱의 평과 결과를 반환하기 때문에 해당 식은 두번째 피연산자인 Dog를 그대로 반환한다 논리합 연산자또한 논리곱 연산자와 동일하게 작동하지만 하나의 피연산자만 true이면 true를 반환하기때문에 위의 식에서는 Cat이 이미 true로 평과 되었기때문에 두번재 피연산자를 평가하지 않고 그래도 첫 번째 피연산자를 반환할 것이다. 이처럼 논리 연산의 결과를 결정하게되는 피연산자의 타입을 변환하지 않고 그대로 반환하는 것을 단축 평가라고 한다. 단축 평가는 표현식을 평가하는 도중 평가 결과가 확정되었을때 나머지 평과 과정을 생략하는 것을 의미하고 있다. 1234567'cat' || 'dog' // dogfalse || 'dog' // dog'cat' || false // cat'cat' &amp;&amp; 'dog' // dogfalse &amp;&amp; 'dog' // false'cat' &amp;&amp; 'false' // false 이러한 단출평가는 if문을 대체할 수 있다. 어떤 조건이 참으로 평과되는 값 일때 무언가를 해야한다면 논리곱(&amp;&amp;) 연산자로 대체를 할 수 있다. 12345678910var done = true;var message = '';// 주어진 조건이 true라면if (done) message = '완료';// 단축 평가로 대체message = done &amp;&amp; '완료'console.log(message); // &quot;완료&quot; 조건이 false 값일때 무언가를 해야한다면 논리합(||) 연산자로 대체가 가능하다. 12345678var done = false;var message = '';if (!done) message = '미완료';message = done || '미완료';console.log(message); // &quot;미완료&quot; 객체를 가리키기를 기대하는 변수가 null or undefined가 아닌지 확인하고 프로퍼티 참조할때객체는 key와 value로 구성된 프로퍼티의 집합이다. 만약 객체를 가리키기를 기대하는 변수의 값이 객체가 아닌 null 또는 nudefined일 경우 타입 에러가 발생하게 된다. 이때 단축 평가를 사용하게 되면 에러가 발생되지 않게 된다. 123var elem = null;// elem이 null이나 undefined와 같은 falsy 값이면 elem으로 평가되고 truthy값이면 elem.value값으로 평가된다.var value = elem &amp;&amp; elem.value; // null 옵셔널 체이닝 연산자옵셔널 체이닝 연산자란 ?. 좌항의 피연산자가 null 또는 undefined일 경우 undefined를 반환하고 아니라면 우항의 프로퍼티 참조를 이어가는 방식이다. 123var elem = null;var value = elem?.value;console.log(value); // undefined null 병합 연산자null병합 연산자는 좌항의 피연산자가 null, undefined일 경우 우항의 피연산자를 반환하고 그렇지 않을 경우 좌항의 피연산자를 반환한다. 이는 변수의 기본값을 설정할 때 유용하다. 12345var foo = null ?? 'dafault value';console.log(foo); // &quot;defalut value&quot;var foo = 'left value' ?? 'dafault value';console.log(foo); // &quot;left value&quot;","link":"/2021/09/14/js/javascript-%ED%83%80%EC%9E%85%EB%B3%80%ED%99%98%EA%B3%BC-%EB%8B%A8%EC%B6%95%ED%8F%89%EA%B0%80/"},{"title":"javascript 표현식과 문","text":"표현식과 문값값은 식이 평가되어 생성된 결과를 의미한다. 평가란 식을 해석해서 값을 생성하거나 참조하는 것을 의미한다. 110 + 20; 10 + 20 이 평가되어 30이라는 값을 생성한다. 모든 값은 데이터 타입을 가지며 메모리에 2진수로 저장된다. 메모리에 저장된 값은 타입에 따라 다르게 해석 될 수 있다. 0100 0000이란 2진수를 문자열로 해석하면 A 이지만 숫자로 해석하면 65인것 처럼 말이다. 리터럴리터럴이란 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용하여 값을 생성하는 표기법을 의미한다. 리터럴 예시 비고 정수 100 부동소수점 10.5 2진수 0b01000001 ob로 시작 8진수 0o101 ES6에서 도입 16진수 0x41 ES6에서 도입 문자열 ‘Hello’ 불리언 true, false null null undefined undefined 객체 {name: ‘Lee’, address: ‘seoul’}; 배열 [‘lee’, ‘han’]; 함수 function() {} 정규표현식 /[A-Z]+/g 표현식표현식은 값으로 평가될 수 있는 문이다. 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다. 문문 은 프로그램을 구성하는 기본 단위이자 최소 실행 단위이다. 이러한 문은 여러개의 토큰으로 이루어지며 토큰이란 문법적인 의미를 가지며 문법적으로 더이상 나눌 수 없는 코드의 기본 요소를 의미한다. 예를 들면 키워드, 식별자, 연산자, 리터럴, 세미콜론, 마침표 등의 특수기호는 문법적인 의미를 가지며 모두 토큰이다. 문은 선언문, 할당문, 조건문, 반복문 등으로 구분이 가능하다. 1234567891011121314// 선언문var x;// 할당문x = 5;// 함수 선언문function foo () {}// 조건문if ( x &gt; 1) {}// 반복문for (i = 0; i &lt; x; i++) {}","link":"/2021/09/10/js/javascript-%ED%91%9C%ED%98%84%EC%8B%9D%EA%B3%BC-%EB%AC%B8/"},{"title":"javascript 프로그래밍언어란&quot;","text":"프로그래밍이란컴퓨터에게 실행을 요구하는 일종의 커뮤니케이션의 한종류이다. 프로그래밍 언어컴퓨터에게 전달하는 기계어를 사람이 이해할수있는 약속된 구문으로 구성된 프로그래밍 언어를 사용하여 프로그램을 작성하고 기계어로 변환하는 과정을 이용한다. 이때 변환하는 일종의 번역기를 컴파일러 혹은 인터프리터라고 한다. 즉 프로그래밍언어는 컴퓨터와의 일종의 커뮤니케이션으로 프로그래밍 언어는 구문과 의미의 조합으로 표현된다. 이러한 과정을 거치는 프로그래밍이란 결국 요구사항의 집합을 분석하여 적절한 자료구조와 함수의 집합으로 변환한 후 그 흐름을 제어하는 것이다.","link":"/2021/09/10/js/javascript-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%96%B8%EC%96%B4%EB%9E%80/"},{"title":"javascript-함수","text":"함수함수란?함수는 자바스크립트에서 중요한 핵심중 하나이다. 프로그래밍 언어의 함수는 일련의 과정을 문으로 구현하고 코드블록으로 감싸서 하나의 실행 단위로 정의 한것이다.함수는 입력을 받아 출력을 내보낸다. 이때 함수 내부로 입력을 전달받는 변수를 매개변수 입력을 인수 출력을 반환값이라 한다. 또한 함수는 값이고 여러개 존재할 수 있기 때문에 특정 함수를 구별하기 위해 식별자인 함수 이름을 사용할 수 있다. 12345// 함수 정의function 함수이름(매개변수1, 매개변수2) { return 매개변수1 + 매개변수2 // 반환값}함수이름(값1, 값2); // 함수 호출 함수는 함수 정의로 생성하며 다양한 방법으로 정의할 수 있다. 1234// 함수 정의function add (x, y) { return x + y;} 함수를 정의하고 나서 실행을 하기 위해서는 인수를 매개변수를 통해 함수에 전달하며 함수의 실행을 지시해야한다. 이 과정을 함수 호출이라고 한다. 12345// 함수 호출var result = add(2, 5);// 인수를 전달하면 반환값이 반환된다.console.log(result); // 7 함수는 왜 사용할까?함수는 필요할 때마다 호출하여 실행이 가능하다. 실행 시점은 개발자가 결정하기도 하고 재사용이 가능하다. 동일한 작업을 반복적으로 실행해야 한다면 같은 코드를 중복하여 작성하는 것이 아닌 함수를 재사용하는 것이 효율적이다. 함수는 코드의 재사용 측면에서 매우 유용한 기능이다. 함수는 재사용성을 높여주고 유지보수 측면에서 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높이는 효과가 있다. 이러한 함수를 정의할때 함수이름 즉 식별자를 붙일 수 있다. 함수이름은 함수의 역할을 이해하기 쉽게 네이밍해주는 것이 좋다. 함수 리터럴?자바스크립트의 함수는 객체 타입의 값이다. 따라서 함수도 함수 리터럴로 생성할 수 있다. 함수 리터럴은 function키워드, 함수 이름, 매개변수 목록, 함수 몸체로 구성된다. 함수 리터럴의 구성요소 구성요소 설명 함수이름 함수이름은 식별자다. 함수이름은 함수 몸체 내에서만 참조할수 있는 식별자이다. 함수이름은 생략이 가능하다 이를 무명함수라 한다. 매개변수 목록 0개이상의 매개변수를 소괄호 내에 정의한다. 각 매개변수는 함수 호출시 전달한 인자의 순서대로 할당된다. 함수 몸체 함수가 호출되었을 때 일괄적으로 실행될 문들을 하나의 실행단위로 정의한 것이다. 함수 몸체는 함수의 호출로 실행된다. 함수 정의함수 정의란 함수를 호출하기 전에 전달받을 매개변수들 실행할 문들 반환값을 정의하는 것을 말한다. 정의된 함수는 자바스크립트 엔진에 의해 함수 객체가 된다. 함수 정의 방식 정의 방식 예시 함수 선언문 function add(x, y) { return x + y } 함수 표현식 var add = function (x, y) { return x + y } Function 생성자함수 var add = new Function('x', 'y', 'return x + y'); 화살표 함수 var add = (x, y) =&gt; x + y; 함수 선언문12345function add(x, y) { return x + y;}console.log(add(1, 2)); // 3 함수 선언문은 함수 리터럴과 형태가 동일하다. 단 함수 선언문은 함수 이름을 생략할 수 없다. 함수 선언문은 표현식이 아닌 문이다.자바스크립트 엔진은 함수 선언문을 해석하여 함수 객체를 생성한다. 이때 함수이름과 동일한 이름의 식별자를 임의로 생성하고 거기에 함수 객체를 할당한다.즉 함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출하는 것이다. 함수 생성 시점과 호이스팅1234567891011121314151617// 함수 참조console.log(add);console.log(sub);// 함수 호출console.log(add(2, 5));console.log(sub(2, 5));// 함수 선언문function add(x, y) { return x + y;}//함수 표현식var sub = function (x, y) { return x - y;}; 위의 코드처럼 함수 선언문으로 선언한 함수는 함수 선언이전에 호출이 가능하다. 하지만 함수 표현식으로 정의한 함수는 정의 이전에 호출이 불가능하다. 이는 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르기 때문이다. 함수 선언문은 코드가 실행되는 시점인 런타임 이전에 실행이 된다. 따라서 런타임 이전에 함수가 생성이 되는 것이다. 이처럼 함수선언문이 코드의 위로 끌어 올려져 먼저 생성된 이후 실행되는 것처럼 보이는 것을 함수 호이스팅이라고 한다.var 키워드를 사용한 변수는 선언문 이전에 참조시 undefined로 평가되지만 함수는 호이스팅에 의해 호출이 가능한 차이점이 있다. 이에 반해 함수 표현식은 변수에 할당되는 값이 함수 리터럴인 문이다. 변수 선언은 런타임 이전에 undefined로 초기화 되지만 할당문은 값이 할당되는 시점에 평가되므로 런타임에서 함수 객체가 된다. 따라서 함수 표현식은 함수 정의 이전에 참조하게 되면 undefined로 평가되는 것이다. 화살표 함수ES6에서 도입된 화살표 함수는 function 키워드 대신 화살표 =&gt; 를 사용하여 좀더 간략한 방법으로 함수를 정의할 수 있다. 함수 호출매개변수와 인수함수를 실행하기 위해 필요한 값을 함수 외부에서 전달해야 할경우 매개변수를 통해 인자를 전달한다. 이때 인수는 값으로 평가될 수 있는 표현식이여야 한다. 인수는 함수를 호출할때 지정하고 개수와 타입에 제한이 없다. 매개변수는 함수를 정의할때 선언하며 함수 몸체 내부에서 변수와 동일하게 취급된다. 따라서 함수가 호출되면 암묵적으로 매개변수가 생성되고 undefined로 초기화된 이후 인수가 순서대로 할당된다. 함수의 호출시 실행 단계함수정의 -&gt; 호출 (호출시 인수 전달) -&gt; 정의된 함수에서 매개변수 생성 후 인자 할당 -&gt; 정의된 문 실행 후 반환 -&gt; 호출시 지정한 변수에 값 할당 반환문함수는 return 키워드와 함께 표현식으로 이뤄진 반환문을 사용해 실행 결과를 외부로 반환 할 수 있다. 123function add(x, y) { return x + y; // 반환문} 함수 호출은 표현식이다. 따라서 return 키워드가 반환한 평가결과를 값으로 평가한다. 1234function add(x, y) { return x + y; // 반환문 cosole.log('hi'); // 무시됨} return 키워드 이후의 실행문들은 실행되지 않고 무시된다. 참조에 의한 전달과 외부 변경 상태의 변경원시값은 값에 의한 전달 객체는 참조에 의한 전달방식으로 동작한다.매개변수 또한 함수 몸체 내부에서는 변수와 동일하게 취급되므로 값에 의한 전달 참조에 의한 전달 방식을 사용한다. 123456789101112function changeVal (primitive, obj) { primitive += 100; obj.name = 'Kim';}var num = 100;var person = { name: 'Lee' };changeVal(num , person);console.log(num); // 100 원시값은 원본이 바뀌지 않는다.console.log(person); // { name: 'Kim' } 객체는 원본이 훼손된다. 위 경우 함수는 원시타입 인수와 객체 타입 인수를 전달받아 값을 변경하는데 원시값은 값의 변경이 불가능 하므로 원시값을 재할당해 새로운 값으로 변경하고 객체타입은 변경이 가능하므로 재할당없이 직접 값을 변경해준다. 이처럼 함수가 외부상태의 어떤 값을 변경하게 되면 상태변화를 추적하기 어려움이 있다. 이러한 문제점을 해결하기 위한 방법 중 한가지는 객체를 불변객체로 만들어 사용하는 것이다.객체를 깊은 복사를 통해 완전히 새로운 객체를 생성하여 재할당을 통해 교체하면 된다. 다양한 함수의 형태즉시 실행 함수함수는 정의와 동시에 실행되는 함수를 의미한다. 이 함수는 한번만 호출되며 다시 실행할 수 없다. 익명 즉시 실행 함수12345(function () { var a = 3; var b = 4; return a * b;}()); 즉시 실행 함수는 일반적으로 함수이름이 없는 익명 함수를 사용하는 것이 일반적이다. 함수이름이 있는 기명 함수도 실행은 가능하지만 그룹연산자 **(…)**로 선언해야하기 때문에 함수 선언문이 아닌 리터럴로 평가되어 다시 호출이 불가능하다. 1234567(function foo () { var a = 3; var b = 4; return a * b;}());foo(); // Error 즉시 실행 함수는 반드시 그룹연산자로 감싸야 한다는 특징을 가지고 있다. 그룹연산자로 함수를 묶는 이유는 함수 리터럴을 평가하여 함수 객체를 생성하기 위해서이다. 이렇게 즉시 실행 함수에 코드를 모아두게 되면 혹시 있을 변수의 충돌이나 함수이름의 충돌을 방지 할 수 있다. 재귀함수함수가 자기 자신을 호출하는것을 재귀함수라 한다. 재귀함수는 반복되는 처리를 위해 사용한다. 반복문을 사용하여 10부터 0까지 출력하는 함수12345function count (a) { for (var i = a; i &gt;= 0; i--) { console.log(i); }} 재귀함수를 사용하여 10부터 0까지 출력하는 방법1234567// 재귀함수function fac (n) { if (n &lt; 0) return; console.log(n); fac(n -1);}fac(10); 동일한 실행결과를 반복문 없이도 구현이 가능하다. 하지만 재귀함수는 반복되는 처리를 무한 반복하기 때문에 탈출조건을 반드시 정의해야하며 무한 반복에 빠질경우 스택 오버플로를 일으킬수 있으므로 주의하여 사용해야한다. 또한 재귀함수는 반복문을 사용하는 것보다 직관적으로 이해하기 편하기 때문에 사용하는 것이므로 한정적으로 사용하는 것이 좋다. 중첩 함수함수 내부에 정의된 함수를 중첩 함수, 내부 함수라고 한다. 중첩 함수를 가지고 있는 함수를 외부 함수라고 부른다. 중첩 함수의 호출은 외부 함수에서만 가능하며 중첩 함수는 자신을 호출하는 외부 함수를 돕는 헬퍼 함수 역할을 하는 특징이 있다. 123456789101112131415// 중첩 함수function outer () { var x = 1; // 중첩 함수 function inner () { var y = 2; // 중첩 함수는 외부 함수의 변수를 참조할 수 있다. console.log(x + y); } inner();}outer(); 콜백 함수123456789101112131415function re (n , f) { for (var i = 0; i &lt; n; i ++) { f(i); }}var logAll = function (i) { console.log(i);}re(5, logAll);var logOdds = function (i) { if(i%2) console.log(i);};re (5, logOdds); re함수의 경우에 따라 바뀌는 실행 결과를 f로 추상화하여 이를 외부에서 전달한다. js의 함수는 일급 객체이므로 함수의 매개변수를 통해 함수가 전달이 된다.re 함수는 실행할 횟수인 인수를 전달받고 실행결과를 출력할 함수로 전달받은 함수를 호출한다. 따라서 위 실행결과는 하나의 함수에서 여러가지의 실행결과를 출력할 수 있다.이러한 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백함수라고 하며 매개변수를 통해 함수의 외부에서 콜백함수를 전달받은 함수를 고차 함수라고 한다. 이전의 중첩 함수가 외부 함수의 헬퍼 함수역할을 하는 것처럼 콜백 함수도 고차 함수의 헬퍼 함수역할을 한다. 고차 함수는 매개변수를 통해 전달받은 콜백함수의 호출 시점을 결정해서 호출한다. 따라서 콜백함수는 고차 함수에 의해 호출되며 고차 함수는 필요에 따라 콜백 함수에 인수를 전달 할 수 있다. 콜백 함수를 사용하는 예제123456789var res = [1, 2, 3].map((item) =&gt; { return item * 2;});console.log(res); // [2, 4, 6]var fil = [1, 2, 3].filter((item) =&gt; { return item % 2;});console.log(fil); // [1, 3] 순수 함수와 비순수 함수함수형 프로그래밍에서 어떠한 외부 상태에도 의존하지 않고 변경하지도 않는 함수를 순수 함수라고 하고 외부 상태에 의존하거나 외부 상태를 변경하는 함수를 비순수 함수라고 한다.순수 함수는 동일한 인수가 전달되면 언제나 동일한 값을 반환하는 함수이다. 즉 순수 함수는 오직 매개변수를 통해 함수 내부에 전달된 인수에게 의존하여 반환값을 만드는 함수이다. 순수 함수1234567891011var count = 0;function increase(n) { return ++n;}// 순수 함수가 반환한 값을 변수에 재할당하여 상태를 변경count = increase(count);console.log(count); // 1 count = increase(count);console.log(count); // 2 순수 함수의 의미와 반대된 개념으로 비순수 함수는 외부 상태에 의존하는 함수이다. 비순수 함수12345678910var count = 0;function increase() { return ++count; // 외부 상태에 의존하여 외부 상태를 변경한다.}increse();console.log(count); // 1increse();console.log(count); // 2 함수형 프로그래밍은 순수 함수와 보조 함수의 적절한 조합으로 외부 상태를 변경하는 부수효과를 최소화하여 불변성을 지향하는 프로그래밍이다.","link":"/2021/10/11/js/javascript-%ED%95%A8%EC%88%98/"},{"title":"자바스크립트의 동적 타이핑","text":"동적타이핑C나 자바 같은 정적타입 언어는 변수를 생성할 때 변수에 할당할 수 있는 값의 종류 즉 데이터 타입을 사전에 선언해야 한다. 이를 명시적 타입 선언 이라고 한다. 정적 타입 언어에서는 변수의 타입을 변경 할 수 없으머 변수에 선언한 타입에 맞는 값만 할당이 가능하다. 컴파일 시점에서 타입 체크를 수행한다. 이때 통과를 하지 못하면 에러가 발생하고 프로그램이 실행 되지 않는다. 이를 통해 타입의 일관성을 강제함으로써 안정적인 코드의 구현으로 실행시 일어나는 에러를 줄일 수 있다. 하지만 자바스크립트는 변수를 선언할때 타입을 명시하지 않는다. 이로 인해 어떠한 값도 변수에 할당이 가능하다. 이러한 특징으로 인해 정적 타입 언어에서의 데이터 타입과 개념이 조금 다르다.자바스크립트는 값을 할당하는 시점에 변수의 데이터 타입을 동적으로 결정한다. 또한 이 값을 언제든 변경이 가능하다. 즉 자바스크립트에서 변수는 선언이 아닌 할당에 의해 타입이 결정되고 재할당에 의해 변수의 타입은 변경이 언제든지 가능하다고 볼 수 있다. 이러한 특징을 통적 타이핑이라 한다. 동적 타입 언어와 변수동적 타입 언어에서는 변수에 어떤 데이터 값도 자유롭게 할당이 가능하다. 이는 너무나도 편하고 좋은 기능이다. 하지만 떄로는 위험도 있는 것이 동적 타이핑의 단점이다.모든 소프트웨어 아키텍쳐에는 트레이드오프가 존재한다. 이러한 문제를 해결할 명확한 해결책은 없듯이 동적 타입 언어 구조 또한 구조적인 단점이 존재한다. 트레이드 오프 두개의 정책이나 목표 중 하나를 달성하려할 때 다른 목표의 달성이 늦어지거나 손실이 생기는 모순적인 상황을 의미한다. 동적 타이핑의 구조적 단점으로는 변수값이 언제든지 변경될 수 있기 때문에 복잡한 프로그램에서 변하는 값을 추적하기 어렵다는 단점 그리고 변수의 타입이 고정되어 있지 않고동적으로 변하는 언어의 변수는 값의 변경만으로 타입이 변할 수 있다는 단점이 있다. 즉 동적 타입 언어의 변수는 값을 확인하기 전까지 값의 타입을 확신 할 수 없다.또한 자바스크립트는 개발자의 의도와 상관없이 타입이 엔진에 의해 변하는 상황이 생기기도 한다. 이러한 문제들로 인해 동적 타이핑은 유연성이 높다는 장점을 가지고 신뢰성이 떨어진다는 단점이 존재한다. 이때문에 자바스크립트에서 변수를 사용할 때는 다음과 같은 주의 사항이 필요하다. 변수는 꼭 필요한 경우에 한해 제한적으로 사용한다. 값은 언제든지 변경이 가능하므로 오류의 발생 가능성이 존재하며 변수의 개수가 많을수록 오류가 발생하게될 확률이 높아진다. 따라서 무분별한 변수의 사용은 자제하며 필요한 경우에 한해 제한적으로 사용한다. 변수의 유효범위를 최대한 좁게 만들어 부작용을 억제한다. 전역변수는 최대한 사용하지 않는다. 어디서든 참조가 가능한 변수는 언제든지 의도하지 않은 대로 값이 변경될 가능성이 크고 다른 코드의 영향을 줄 가능성이 있다. 변수보다는 상수를 사용하여 값을 억제한다. 변수 이름은 변수의 목적이나 의미를 파악하도록 네이밍을 한다.","link":"/2021/09/12/js/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-%EB%8F%99%EC%A0%81-%ED%83%80%EC%9D%B4%ED%95%91/"},{"title":"javascript-let, const, 블록레벨 스코프","text":"let, const 키워드와 블록레벨 스코프ES5 까지 변수의 선언을 유일하게 할 수 있던 방법인 var키워드는 여러가지의 문제점들이 있다. 변수의 중복선언var 키워드로 선언한 변수는 중복 선언이 가능하다. 함수레벨 스코프var키워드로 선언한 변수는 오직 함수의 코드블록만이 지역 스코프로 인정된다. 따라서 외부 함수에서 var키워드로 선언한 전역 변수는 코드블록 내에서 선언해도 전역변수가 된다. 변수 호이스팅var 키워드로 선언한 변수는 호이스팅에 의해 가장 위로 끌어 올려지고 할당이전에도 참조가 가능하다. 123456789101112// 변수 호이스팅에 의해 이미 foo라는 변수는 선언이 되었다.// 아직 변수에 값이 할당된 상태가 아니기 때문에 undefined가 반환된다.console.log(foo); // undefined// 변수 호이스팅에 의해 foo변수가 선언되었고 값을 선언하면 foo의 값은 123이 된다.foo = 123;// 값이 할당된 변수이기 때문에 변수의 값이 반환된다.console.log(foo); // 123// 런타임 이전에 foo 라는 변수가 선언이되고 undefined로 초기화 된다.var foo; 선언문 이전에 참조하는 것이 변수 호이스팅에 의해 에러가 발생하지는 않지만 코드의 가독성을 해치며 오류를 발생시킬 여지가 생긴다. let 키워드let 키워드는 ES6에서 도입된 변수 선언 키워드이다.var키워드와의 차이점은 다음의 특징들이 있다. 변수 중복 선언 금지var키워드로 변수를 선언하면 같은 식별자이름의 변수를 중복 선언해도 에러가 발생하지 않는다. 하지만 let키워드는 같은 이름의 변수를 선언하면 문법 에러가 발생한다. 블록 레벨 스코프var키워드로 선언한 변수는 오직 함수 코드 블록만을 지역 스코프로 인정하는 함수 레벨 스코프 방식이였다. 하지만 let키워드는 모든 코드블록을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다. 동일한 코드로 var키워드와 let키워드의 스코프 레벨 차이를 확인해보자 var 키워드 123456789101112var i = 10;function foo () { var i = 100; for (var i = 0; i &lt; 5; i++) { console.log(i); // 0, 1, 2, 3, 4 } console.log(i); // 5}foo();console.log(i); //10 let 키워드 123456789101112let i = 10; // 젼역 변수function foo () { let i = 100; // 함수 레벨 스코프의 지역 변수 for (let i = 0; i &lt; 5; i++) { // 블록 레벨 스코프의 지역변수 console.log(i); // 0, 1, 2, 3, 4 } console.log(i); // 5 }foo();console.log(i); // 10 변수 호이스팅let 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는 것처럼 동작한다. 12console.log(foo); // 참조에러let foo; let 키워드로 선언한 변수는 선언문 이전에 참조하면 참조에러가 발생한다. var 키워드는 런타임 이전 자바스크립트 엔진에 의해 변수가 선언되고 초기화 단게가 진행된다. 이때 undefined로 초기화가 되기 때문에 선언문 이전에도 참조가 가능하지만let 키워드로 선언한 변수는 선언단계와 초기화 단계가 분리되어 실행된다. var 키워드의 변수와 마찬가지로 런타임 이전에 변수가 선언은 되지만 초기화 단계는 선언문에 도달 했을때 진행 되므로 선언 이전에 변수를 참조하면 참조 에러가 발생하는 것이다. 이러한 변수의 선언단계인 스코프 시작 단계와 초기화 단계 사이에서 변수를 참조 할 수 없는 것을 일시적 사각지대라고 부른다. 그렇다면 let 키워드로 선언한 변수는 호이스팅이 발생하지 않을까? 결론은 아니다. 123456let a = 1; // 전역변수if (true) { console.log(a); // 참조 에러 let a = 1243; // 지역 변수} 변수 호이스팅이 일어나지 않는다면 if문 내에서 참조하는 a변수는 상위 스코프의 a라는 변수를 참조해야 한다.하지만 참조에러가 난다는 것은 지역 스코프내에 a라는 변수가 호이스팅에 의해 상위로 끌어 올려졌다는 것을 의미한다. ES6에서 도입된 let const를 포함 모든 선언은 호이스팅이 일어난다. 다만 let, const, class를 사용한 선언문은 호이스팅이 일어나지 않는 것 처럼 동작하게 되어있다. const 키워드const 키워드는 상수를 선언하기 위해 사용하는 키워드이다. const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화가 진행되어야 한다. 123const a = 1; // 👍const b; // 👎 const 키워드로 선언한 변수는 let 키워드와 마찬가지로 블록 레벨 스코프를 가진다. 재할당이 금지된다.const 키워드로 선언한 변수는 재할당이 금지된다. 상수?상수란 재할당이 금지된 변수를 의미한다.변수는 값의 재할당과 변경이 자유로운 반면 상수는 재할당이 불가능한 변수이다. 상수는 상태 유지와 가독성 측면, 유지보수를 위해 적극적인 사용이 좋다. const 키워드와 객체const 키워드로 선언한 변수에 객체를 할당시 객체의 프로퍼티 값은 변경이 가능하다. 이는 const 키워드가 재할당을 금지하는 것뿐 값의 불변성을 의미하지는 않는다는 것이다. var vs let, const?변수 선언에는 기본적으로 const 키워드를 사용하고 재할당이 필요한 값에 let키워드를 사용한다. 일단 변수를 선언하고 값이 변경되어야 한다면 let 키워드로 바꿔도 무방하다. 일단 const 키워드를 사용해 변수를 선언하자.","link":"/2021/10/12/js/let-const-%EB%B8%94%EB%A1%9D%EB%A0%88%EB%B2%A8-%EC%8A%A4%EC%BD%94%ED%94%84/"},{"title":"Postgresql ROW _NUMBER 함수","text":"Postgresql DB row_number() 함수 row_number 함수는 조회하는 데이터의 특정 집합내에서 select 결과의 건수의 변화없이 데이터를 조회하는 함수이다. 데이터베이스에서 상품 테이블과 이미지 테이블을 조인한 데이터를 가져오려고 하는 과정에서 문제가 한가지 발행하였다. 현재 개발중인 API서버에서 상품의 데이터들을 조회하여 15개씩 limit옵션을 사용하여 가져오려고 한다.데이터베이스에 대한 심도있는 학습을 하지 않았던 탓일까 왜 당연히 15개의 상품이 모두 조회된다는 생각을 했던것일까… 기존 쿼리 및 결과 정말 쉽게 생각해서 간단하게 left join만 해주면 되는 문제다라는 생각으로 데이터베이스에 조회를 했다. 내가 작성한 쿼리는 다음과 같다. sql 123456 select p.product_no, p.product_title, i.image_no, i.image_srcfrom product pleft join image i on p.product_no = i.image_product_noorder by product_no desclimit 15; 결과 15개의 데이터를 가져오기는 했다… 하지만 이것은 내가 가져오고자 한 데이터의 모든 정보를 가져와 주지않았다. 이렇게 쿼리를 작성해보니 당연한 결과였는데 어떻게 그렇게 단순하게 생각을 한건지 나에게 부끄러움을 느꼈다… 그래서 데이터베이스를 잘아는 분과 구글의 힘을 빌려 원하는 데이터를 가져올 수 있는 방법을 찾던중 postgresql이 orcle의 ROWNUM함수와 같은 기능의 함수를 제공한다는 정보를 통해 쿼리문을 수정하였다. 수정된 sql 123456789 select p.product_no, p.product_title, i.image_srcfrom(select row_number() over(order by a.product_no desc) as rn, a.product_no, a.product_title, a.product_user_nofrom product a) as pleft join image i on i.image_product_no = p.product_no and i.deleted = 'N'where rn &lt;= 15order by p.product_no desc; 결과 row_number 함수는 가져올 데이터의 갯수를 정하고 해당 값이 변동되지 않고서 정해진 데이터의 집합내에 모든 데이터를 가져와 주는 기능으로 사용하는 함수인듯 하다. 먼저 from절에서 서브쿼리로 데이터의 집합을 정하고 해당 집합의 데이터를 가져왔다. 이 방식을 사용하니 15개의 상품을 정상적으로 가져올수 있었고 이제 이 쿼리를 TypeOrm으로 가져가서 사용하면 될듯하다.. 데이터베이스도 공부를 놓으면 안된다는걸 느끼는 과정이였다…","link":"/2021/09/09/postgresql/Postgresql-ROW-NUMBER-%ED%95%A8%EC%88%98/"},{"title":"Sequelize Relration","text":"시퀄라이즈 관계 설정하기 시퀄라이즈를 통해 mysql에 생성한 테이블간의 관계를 성립 시키기 위해 관계 설정을 해주어야 한다. 관계 설정에는 어떤 방식이 이용되는지 살펴 보도록 하자. 👉Relretions Sequelize에서 관계를 설정하기 위해 사용하는 옵션은 다음과 같다. 관계 설정 옵션 hasOne, belongsTo 1 대 1 관계 hasMany, belongsTo 1 대 N 관계 belongsToMany N 대 M 관계 3가지 관계에 대한 메서드는 표에 정리된 것과 같다. 👉관계 설정해보기 1 : 1 관계 일대일 관계를 맺는 방법은 참조될 정보를 가진 테이블에 hasOne 메서드를 키를 참조해가는 테이블에 belongsTo 메서드를 사용하면 된다.예를 들어 유저 한명은 하나의 프로필 이미지를 가질 수 있다는 가정을 해보자. 123456789 // 유저 모델static associate(db) { db.User.hasOne(db.Image);}// 프로필이미지 모델static associate(db) { db.Image.belongsTo(db.User, { foreignKey: 'MyId', sourceKey: 'id' });} 이렇게 설정 시 Image테이블에 ‘MyId’라는 외래키 컬럼이 생성된다. 1 : N 관계 일대다 관계를 맺는 방법은 참조될 정보를 가진 테이블에 hasMany 메서드를 키를 참조해가는 테이블에 belongsTo 메서드를 사용한다.예를 들어 유저 한명은 여러개의 게시물을 작성 할 수 있다고 가정을 해보자. 123456789 // 유저 모델static associate(db) { db.User.hasMany(db.Post);}// 게시물 모델static associate(db) { db.Post.belongsTo(db.User, { foreignKey: 'UserId', sourceKey: 'id' });} 이렇게 설정시 Post테이블에 ‘UserId’라는 외래키 컬럼이 생기며 1 대 다 관계가 성립이 된다. N : M 관계 다대다 관계를 맺는 방법은 관계를 맺을 테이블에 belongsToMany 메서드를 사용하고 through 옵션으로 중간 테이블을 생성해주면 된다.예를 들어 게시물에서 해시태그를 사용하며 동일한 해시태그가 여러개의 게시물에 사용 될 수 있다는 가정을 해보자 123456789 // 게시물 모델static associate(db) { db.Post.belongsToMany(db.Hashtag, { through: 'PostHashtag' });}// 해시태그 모델static associate(db) { db.Hashtag.belongsToMany(db.Post, { through: 'PostHashtag' });} 이렇게 설정시 Post 테이블의 정보와 Hashtag 테이블의 정보를 참조하고 있는 중간 테이블이 생성되며 다대다 관계가 성립이 된다.","link":"/2021/09/09/sequelize/Sequelize-Relration/"},{"title":"SQLD 데이터 모델링","text":"데이터 모델링이란? 정보시스템을 구축하기 위한 데이터 관점의 업무 분석 기법 데이터베이스를 구축하기 위한 분석/설계의 과정 모델링 복잡하고 다향한 현상을 표기법에 의해 규칙을 가지고 표기하는 것을 의미한다. 가설적 또는 일정 양식에 맟춘 표현 어떤 것에 대한 에비표현으로 그로부터 최종대상이 구축되도록 하는 계획으로서 기여 하는 것 모델링의 특징모델링은 추상화, 단순화, 명확화 3가지 특징이 있다. 추상화는 현실세계를 일정한 형식에 맟추어 표현을 한다는 의미이다. 단순화는 복잡한 현실세계를 약속된 규약에 의해 제한된 표기법, 언어로 표현하여 쉽게 이해할 수 있도록 하는 개념을 의미한다. 명확화는 누구나 이해하기 쉽게 대상에 대한 애매모호함을 제거하고 정확하게 표기하는 것을 의미한다. 모델링의 세가지 관점 데이터 관점 : 업무가 어떤 데이터와 관련이 있는지 또는 데이터간의 관계는 무엇인지에 대해 모델링 하는 방법 프로세스 관점 : 업무가 실제하고 있는 일은 무엇인지 또는 무엇을 해야 하는지를 모델링 하는 방법 데이터와 프로세스의 상관관점 : 업무가 처리하고 있는 일의 방법에 따라 데이터는 어떻게 영향을 받고 있는지 모델링 하는 방법 데이터 모델이 제공하는 기능 시스템을 현재 또는 원하는 모습으로 가시화하도록 도와준다. 시스템의 구조와 행동을 명세화 할 수 있게 한다. 시슽템을 구축하는 구조화된 틀을 제공한다. 시스템을 구축하는 과정에서 결정한 것을 문서화 한다. 다양한 영역에 집중하기 위해 다른 영역의 세부 사항은 숨기는 다양한 관점을 제공한다. 중요성 및 유의점 파급효과 : 시스템 구축이 완성되어 가는 과정에서 수많은 단위 테스트가 수행되고 이러한 과정이 반복된다. 이러한 테스트 과정에서 데이터 모델이 변경되는 상황은 프로젝트의 규모가 클수록 문제가 일어난다. 이러한 이유로 데이터 설계는 중요하다. 복잡한 정보 요구사항의 간결한 표현 : 데이터 모델은 정보요구사항을 파악하기 위해 유용하다. 데이터 품질 : 데이터로 이용할 수 있는 비즈니스 기회를 얻기 위해 데이터는 필요한 데이터만이 존재 해야 한다. 데이터 모델링의 3단계 진행 데이터 모델링 내용 수준 개념적 데이터 모델링 추상화 수준이 높고 업무 중심적이며 포괄적인 수준의 모델링 추상적 논리적 데이터 모델링 시스템으로 구축하고자 하는 업무에 대하여 key 속성 관계 등을 정확하게 표현 물리적 데이터 모델링 실제로 데이터 베이스에 이식할 수 있도록 설계 구체적","link":"/2021/10/17/sqld/SQLD-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AA%A8%EB%8D%B8%EB%A7%81/"},{"title":"SQLD 속성","text":"속성이란 업무에서 필요로 하고 인스턴스에서 관리하고자 하는 의미상 더이상 분리되지 않는 최소의 데이터 단위이다.속성의 개념은 다음과 같다. 업무에서 필요로 한다. 의미상 더이상 분리 되지 않는다. 엔터티를 설명하고 인스턴스의 구성요소가 된다. 엔터티와 인스턴스, 속성, 속성값의 관계 하나의 엔터티는 두개 이상의 속성을 갖는다. 하나의 엔터티는 두개 이상의 인스턴스의 집합니다. 하나의 속성은 하나의 속성값을 가진다. 속성의 특징 업무에서 필요로 하는 정보이다. 정규화 이론에 의해 정해진 식별자에 함수적 종속성을 가진다. 하나의 속성에는 한개의 값만을 가지게 해야한다. 하나 이상의 값이 필요하다면 별도의 엔터티로 분리를 하는 것이 좋다. 속성의 분류 속성에 따른 분류 기본 속성 : 업무로부터 추출한 모든 속성이 여기에 해당된다. 설게 속성 : 업무상 필요한 속성 이외에 데이터 모델링을 위해 업무의 규칙화를 위해 속성을 새로 만들거나 변형하여 정의하는 속성. 파생 속성 : 다른 속성에 의해 영향을 받아 생성되며 보통 계산된 값으로 쓰이는 경우가 많다. 엔터티 구성 방식엔터티를 구별하기 위해 주 식별자로 사용하는 속성을 PK 속성, 다른 엔터티와 관계를 포함한 속성을 FK 속성 나머지 속성을 일반 속성으로 구별한다. 도메인각 속성이 가질 수 있는 범위를 도메인이라고 하는데 쉽게 이해하기 위해서 속성에 대한 값의 범위, 데이터 타입, 크기, 제약사항을 의미한다. 속성의 명명 엔터티와 마찬가지로 현업에서 사용하는 이름을 사용한다. 약어 사용은 자제한다. 서술식 표현은 자제하며 명사를 사용한다. 유일한 속성 이름을 지정한다. 이는 반 정규화 적용시 안정적 적용이 가능한 장점을 가진다.","link":"/2021/10/16/sqld/SQLD-%EC%86%8D%EC%84%B1/"},{"title":"SQLD 엔터티의 개념","text":"엔터티란? 사람, 장소, 물건, 사건, 개념 등의 명사에 해당 업무상 관리가 필요한 관심사 저장이 되기 위한 어떤 것 즉 엔터티란 업무에 필요하며 유용한 정보를 저장하고 관찰하기 위한 집합으로 지속적인 관심을 가지고 있어야 하는 대상이다. 또한 그 대상간의 동질성을 지닌 인스턴스나 그들이 행하는 행위의 집합이다. 엔터티의 특징 반드시 업무에 필요한 정보여야 한다. 유일한 식별자에 의해 식별이 되어야 한다. 영속성으로 존재하는 인스턴스의 집합이다. 업무 프로세서에 의해 이용되어야 한다. 반드시 속성이 존재해야 한다. 다른 엔터티와 최소 한개 이상의 관계를 가지고 있어야 한다. 엔터티의 분류?엔터티는 자신의 성격, 실체 유형에 따라 구분하거나 업무를 구성하는 모습에 따라 구분이 되고 발생시점에 따라 구분이 가능하다. 유무형에 따른 분류유/무형에 따라 유형, 개념, 사건 엔터티로 구분이 가능하다. 유형 엔터티 : 물리적인 형태가 있고 지속적으로 활용이 가능한 정보 EX) 사원, 물품 개념 엔터티 : 물리적인 형태가 없고 관리해야 할 개념적 정보로 구분이 되는 엔터티 EX) 조직, 보험상품 사건 엔터티 : 업무 수행에 있어 발생되는 엔터티 EX) 주문, 청구, 미납 발생 시점에 따른 분류엔터티의 발생 시점에 따라서 기본/키엔터티, 중심 엔터티, 행위 엔터티로 구분이 된다. 기본 엔터티 : 업무에 원래 존대하는 정보, 다른 엔터티에 의해 생성이 되지 않고 독립적으로 생성이 가능하며 다른 엔터티의 부모 역할 수행이 가능 중심 엔터티 : 기본 엔터티로부터 발생, 업무의 중심적 역할을 수행한다. 행위 엔터티 : 두개 이상의 부모 엔터티로부터 생성 주로 상세 설계 단계에서 도출된다. 엔터티의 네이밍 현업에서 사용하는 이름을 사용한다. 약어 사용은 자제한다. 단수명사를 사용한다. 유일한 이름을 부여한다. 생성 의미에 맞는 이름을 부여한다.","link":"/2021/10/16/sqld/SQLD-%EC%9E%90%EA%B2%A9%EC%A6%9D-%EA%B3%B5%EB%B6%80-1%EC%9D%BC%EC%B0%A8/"},{"title":"SQLD 정규화","text":"정규화정규화의 가장 쉬운 의미는 데이터 베이스 수행에 있어 성능 향상 전략중에 한가지이다. 데이터 중복제거와 분류를 통해서 입력/수정/삭제 성능을 향상시켜준다. 하지만 계속되는 엔터티의 생성으로 조인이 빈번하게 일어나 데이터 조회 성능은 저하 될수도 있다. 가장 이해하기 쉬운 의미.. 1정규화 : 모든 속성은 하나의 값을 가져야 한다.(반복적이고 같은 의미를 담는 형태가 있어서는 안된다.) 2정규화 : 모든 속성은 기본키에 종속 되어야 한다. 3정규화 : 기본키가 아닌 모든 속성간에 서로를 종속 할 수 없다. 예를 들어보자… 주문 테이블 주문번호 (PK) 주문일자 품목코드 품목단가 주문수량 고객번호 고객명 주문이라는 테이블에 주문에 대한 모든 데이터가 들어가있다. 예를 들어 내가 옷 두개를 한번에 주문한다. 그렇다면 데이터는 다음과 같이 저장이 될것이다. 주문번호 주문일자 품목코드 품목단가 주문수량 고객번호 고객명 1 10/17 1 2000 1 1 한주련 1 10/17 2 3000 1 1 한주련 1번이라는 주문번호로 주문한 상품의 수만큼 중복된 컬럼이 존재 하게 될것이다. 이 구조에서는 1정규화가 필요하다. 1번이라는 주문번호가 중복되지 않도록… 주문 주문 번호 (PK) 주문일자 고객번호 고객명 주문품목 주문번호 (FK) 품목코드 품목단가 주문수량 1차 정규화의 결과로 이제 1번이라는 하나의 기본키로 여러개의 상품을 중복없이 식별할 수 있다. 2차 정규화는 주문품목 테이블에서 필요성이 나타난다. 2차 정규화란 복합키로 구성된 (여러개의 PK) 경우 2차 정규화의 대상이 된다 이는 복합키의 일부에만 종속되는 속성이 있을 경우 이 속성을 분리해주는 것이다. 1차 정규화를 마친 주문 품목 테이블에서 품목단가라는 속성은 품목코드라는 키와만 관련이 있고 주문번호와는 관련이 없다 이때 품목단가 속성이 일부 키에만 종속되어 있으므로 해당 속성을 분리해주면 된다. 주문품목 주문번호 (FK) 품목코드 (FK) 주문수량 품목 품목코드 (PK) 품목 단가 2차 정규화를 통해 일부의 종속성을 가진 속성을 분리 해주었다. 마지막 3차 정규화는 일반 속성인 컬럼은 기본키에 의존해야 하는데 일반 속성에 의존하고 있는 속성들을 분리하는 것이다. 주문테이블을 살펴보면 고객명이라는 속성은 기본키인 주문 번호에 종속성을 가지고 있지 않고 고객번호 속성에 종속성을 가지고 있는 상태이다. 따라서 3차 정규화의 대상이 된다. 주문 주문번호 (PK) 주문일자 고객번호 (FK) 화원 회원번호 (PK) 고객명 솔직히 그동안 데이터베이스 설계하면서 정규화에대한 개념을 모르고 한번에 이과정을 수행했는데 그럼 된거 아닌가 싶지만… 시험을 보기위해서 과정을 나열하다보니 내가 해온 과정과 비슷하지만 다른.. 어떤 그런 어려운 느낌…","link":"/2021/10/17/sqld/SQLD-%EC%A0%95%EA%B7%9C%ED%99%94/"},{"title":"TypeOrm Entity","text":"Create TypeOrm Entity엔티티는 데이터베이스 테이블에 매핑되는 클래스 입니다. 새로운 클래스를 정의하고 @Entitiy() 표시로 엔티티를 생성할 수 있습니다. 123456789101112131415161718import {Entity, PrimaryGeneratedColumn, Column} from &quot;typeorm&quot;;@Entity()export class User { @PrimaryGeneratedColumn() id: number; @Column() firstName: string; @Column() lastName: string; @Column() isActive: boolean;} 기본 엔티티는 열과 관계로 구성된다. 각 엔티티는 반드시 주 열을 가져야 하며 각각 연결 옵션에 등록을 해주어야한다. 123456789101112import {createConnection, Connection} from &quot;typeorm&quot;;import {User} from &quot;./entity/User&quot;;const connection: Connection = await createConnection({ type: &quot;mysql&quot;, host: &quot;localhost&quot;, port: 3306, username: &quot;test&quot;, password: &quot;test&quot;, database: &quot;test&quot;, entities: [User]}); enttities 에 엔티티를 모두 넣어주는 방식과 엔티티의 전체 디렉토리 경로를 넣어 줄 수도 있다. 1234567891011import {createConnection, Connection} from &quot;typeorm&quot;;const connection: Connection = await createConnection({ type: &quot;mysql&quot;, host: &quot;localhost&quot;, port: 3306, username: &quot;test&quot;, password: &quot;test&quot;, database: &quot;test&quot;, entities: [&quot;entity/*.js&quot;]}); 열데이터 베이스 테이블은 열로 구성되었기 때문에 엔티티도 동일하게 열로 구성을 해주어야 한다. PrimaryColumn엔티티에는 하나 이상의 기본 열이 있어야 한다. @PrimaryColumn()모든 유형의 값을 취하는 기본 열을 만든다. 열 유형을 지정할 수 있고. 열 유형을 지정하지 않으면 속성 유형에서 유추 된다. 아래 예제는 int저장하기 전에 수동으로 할당 해야 하는 형식으로 id를 생성 한다. 123456789import {Entity, PrimaryColumn} from &quot;typeorm&quot;;@Entity()export class User { @PrimaryColumn() id: number;} @PrimaryGeneratedColumn()값이 자동 증가 값으로 자동 생성되는 기본 열을 만든다. 123456789import {Entity, PrimaryGeneratedColumn} from &quot;typeorm&quot;;@Entity()export class User { // auto @PrimaryGeneratedColumn() id: number;} @PrimaryGeneratedColumn(“uuid”)를 사용하여 값이 자동으로 생성되는 기본 열을 만든다. 이는 고유한 문자열이다. 123456789import {Entity, PrimaryGeneratedColumn} from &quot;typeorm&quot;;@Entity()export class User { @PrimaryGeneratedColumn(&quot;uuid&quot;) id: string;} 특정 조건 컬럼 @CreateDateColumn엔티티의 삽입 날짜로 자동 설정되는 특수 열 @UpdateDateColumnsave엔티티 관리자 또는 저장소 를 호출 할 때마다 엔티티의 업데이트 시간으로 자동 설정되는 특수 열 @DeleteDateColumn엔티티 관리자 또는 저장소의 일시 삭제를 호출 할 때마다 엔티티 삭제 시간에 자동으로 설정되는 특수 열 @VersionColumn엔티티 관리자 또는 저장소를 호출 할 때마다 엔티티의 버전으로 자동 설정되는 특수 열 컬럼 유형첫 번째 매개 변수로 @Column 또는의 열 옵션에서 열 유형을 지정할 수 있다. 12@Column(&quot;int&quot;) or 1@Column({ type: &quot;int&quot; }) enum 유형typescript 열거 형 사용 1234567891011121314151617181920export enum UserRole { ADMIN = &quot;admin&quot;, EDITOR = &quot;editor&quot;, GHOST = &quot;ghost&quot;}@Entity()export class User { @PrimaryGeneratedColumn() id: number; @Column({ type: &quot;enum&quot;, enum: UserRole, default: UserRole.GHOST }) role: UserRole} 열거 형 값과 함께 배열 사용 123456789101112131415export type UserRoleType = &quot;admin&quot; | &quot;editor&quot; | &quot;ghost&quot;,@Entity()export class User { @PrimaryGeneratedColumn() id: number; @Column({ type: &quot;enum&quot;, enum: [&quot;admin&quot;, &quot;editor&quot;, &quot;ghost&quot;], default: &quot;ghost&quot; }) role: UserRoleType} 열 옵션 type: ColumnType컬럼 유형. 위에 나열된 유형 중 하나입니다 . name: string데이터베이스 테이블의 열 이름. 기본적으로 열 이름은 속성 이름에서 생성됩니다. 자신의 이름을 지정하여 변경할 수 있습니다. length: number컬럼 유형의 길이. 예를 들어 varchar(150)유형 을 작성 하려면 열 유형 및 길이 옵션을 지정하십시오. width: number열 유형의 표시 너비. MySQL 정수 유형 에만 사용 onUpdate: string``ON UPDATE방아쇠. MySQL 에서만 사용됩니다 . nullable: boolean컬럼 NULL또는 NOT NULL데이터베이스를 만듭니다 . 기본적으로 열은 nullable: false입니다. update: boolean“save”조작으로 컬럼 값이 갱신되는지 여부를 나타냅니다. false 인 경우 개체를 처음 삽입 할 때만이 값을 쓸 수 있습니다. 기본값은 true입니다. insert: boolean개체를 처음 삽입 할 때 열 값이 설정되었는지 여부를 나타냅니다. 기본값은 true입니다. select: boolean질의를 할 때 기본적으로이 열을 숨길 지 여부를 정의합니다. 로 설정 false하면 열 데이터가 표준 쿼리와 함께 표시되지 않습니다. 기본적으로 열은select: true default: string데이터베이스 레벨 컬럼의 DEFAULT값을 추가합니다 . primary: boolean열을 기본으로 표시합니다. 당신이 사용하는 경우 동일합니다 @PrimaryColumn. unique: boolean -열을 고유 한 열로 표시 (고유 제약 조건 생성). comment: string데이터베이스의 열 주석. 모든 데이터베이스 유형에서 지원되지는 않습니다. precision: number10 진수 (정확한 숫자) 열의 정밀도 (10 진수 열에 만 적용됨)는 값에 대해 저장되는 최대 자릿수입니다. 일부 열 유형에서 사용됩니다. scale: number소수점 오른쪽의 자릿수를 나타내며 정밀도보다 클 수없는 소수점 (정확한 숫자) 열 (10 진수 열에 만 적용됨)의 스케일입니다. 일부 열 유형에서 사용됩니다. zerofill: boolean``ZEROFILL숫자 열에 속성을 넣습니다 . MySQL에서만 사용됩니다. 인 경우 trueMySQL UNSIGNED은이 열에 속성을 자동으로 추가합니다 . unsigned: boolean``UNSIGNED숫자 열에 속성을 넣습니다 . MySQL에서만 사용됩니다. charset: string열 문자 집합을 정의합니다. 모든 데이터베이스 유형에서 지원되지는 않습니다. collation: string -열 데이터 정렬을 정의합니다. enum: string[]|AnyEnum``enum허용되는 열거 형 값 목록을 지정하기 위해 열 유형에 사용됩니다. 값 배열을 지정하거나 열거 형 클래스를 지정할 수 있습니다. enumName: string -사용 된 열거 형의 이름을 정의합니다. asExpression: string생성 된 컬럼 표현식. MySQL 에서만 사용됩니다 . generatedType: “VIRTUAL”|”STORED”생성 된 컬럼 유형. MySQL 에서만 사용됩니다 . hstoreType: “object”|”string”``HSTORE열의 유형을 반환합니다 . 값을 문자열 또는 객체로 반환합니다. Postgres 에서만 사용됩니다 . array: boolean -배열이 될 수있는 postgres 및 cockroachdb 열 유형에 사용됩니다 (예 : int []).","link":"/2021/09/09/typeorm/TypeOrm-Entity/"},{"title":"TypeOrm Relation","text":"TypeOrm RelationTypeOrm 엔티티 파일을 만들어보고 관계를 설정 해보려 한다.먼저 공식문서를 통해 관계 설정 방식에 대해 참고 하여 작성하였다.. Relations 1 : 1 = @OneToOne 1 : N = @OneToMany N : 1 = @ManyToOne N : N = @ManyToMany OneToOne서로 1 대 1로 관계를 맺는 모델에 사용한다. 관계를 설정 할 모델의 타겟을 지정하여 연결이 가능하다. 단방향 / 양방향 모두 가능하다. OneToMany &amp; ManyToOne1 대 다, 다 대 1 관계를 맺는 모델에 사용한다. OneToMany와 ManyToOne 은 반드시 함께 설정해야 한다. @JoinColumn 옵션 생략이 가능하다. 이렇게 되면 ManyToOne 쪽에 foriegn Key가 생성된다. ManyToMany서로 다 대 다로 관계를 맺는 모델에 사용한다. @JoinTable 옵션 사용이 필수적이다. Relation Options Cascade : 설정 시 두 테이블간의 영속성이 설정됨 JoinColumn : 참조 키 컬럼을 지정하여 생성 할 수 있다. JoinTable : 다대다 관계의 중간 테이블을 생성한다. 참고문서공식문서.","link":"/2021/09/09/typeorm/TypeOrm-Relation/"},{"title":"TypeOrm 시작하기.","text":"TypeOrm 이란TypeORM은 자바스크립트와 함께 사용이 가능하며 Node JS, 브라우저 등을 지원하고 소규모 애플리케이션 부터 대규모 애플리케이션 까지데이터 베이스를 사용하는 모든 종류의 애플리케이션을 개발하는 데 도움이 되는 추가 기능을 제공하는 것이다.TypeORM은 다른 모든 javascript ORM과 달리 Active Record 및 Data Mapper 패턴을 모두 지원한다 즉, 가장 생산적인 방식으로 고품질의 느슨하게 결합 된 확장 가능하고 유지 관리 가능한 애플리케이션을 작성할 수 있다. TypeOrm의 특징 DataMapperActiveRecord 및 모두 지원 (선택 사항) 엔티티 및 열 데이터베이스 특정 열 유형 엔티티 관리자 리포지토리 및 사용자 지정 리포지토리 깨끗한 객체 관계형 모델 연관 (관계) 열망하고 게으른 관계 단방향, 양방향 및 자체 참조 관계 다중 상속 패턴 지원 캐스케이드 지수 업무 마이그레이션 및 자동 마이그레이션 생성 연결 풀링 복제 여러 데이터베이스 연결 사용 여러 데이터베이스 유형 작업 데이터베이스 간 및 스키마 간 쿼리 우아한 구문, 유연하고 강력한 QueryBuilder 왼쪽 및 내부 결합 조인을 사용하는 쿼리에 대한 적절한 페이지 매김 쿼리 캐싱 원시 결과 스트리밍 벌채 반출 리스너 및 구독자 (후크) 마감 테이블 패턴 지원 모델 또는 개별 구성 파일의 스키마 선언 json / xml / yml / env 형식의 연결 구성 MySQL / MariaDB / Postgres / CockroachDB / SQLite / Microsoft SQL Server / Oracle / SAP Hana / sql.js 지원 MongoDB NoSQL 데이터베이스 지원 NodeJS / Browser / Ionic / Cordova / React Native / NativeScript / Expo / Electron 플랫폼에서 작동 TypeScript 및 JavaScript 지원 생성 된 코드는 성능이 뛰어나고 유연하며 깨끗하고 유지 관리가 가능합니다. 가능한 모든 모범 사례를 따릅니다. CLITypeOrm은 위와 같은 특징을 가지고 있다. TypeOrm Setting npm 패키지를 설치합니다.1npm install typeorm --save reflect-metadatashim 을 설치해야합니다 .1npm install reflect-metadata --save 앱의 전역 위치 (예 :)에서 가져옵니다 app.ts.1import &quot;reflect-metadata&quot;; 노드 유형을 설치해야 할 수도 있습니다.1npm install @types/node --save-dev 데이터베이스 드라이버를 설치합니다. MySQL의 또는 MariaDB1npm install mysql --save( mysql2도 동일) 대한 PostgreSQL을 또는 CockroachDB1npm install pg --save SQLite1npm install sqlite3 --save 마이크로 소프트 SQL 서버1npm install mssql --save sql.js1npm install sql.js --save 오라클1npm install oracledb --save SAP12npm i @sap/hana-clientnpm i hdb-pool MongoDB1npm install mongodb --save","link":"/2021/09/09/typeorm/TypeOrm-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"title":"TypeOrm Test","text":"TypeOrm을 사용하여 엔티티를 생성하고 관계를 설정해보는 것 까지 이번 포스팅에서 진행 해보도록 합니다.🤐 먼저 typeorm을 사용하기위해 서버를 구동해야 하는데… 간단하게 하려 했지만 기존에 하던 곳에서 하는게 가장 편하다고.. 저는 Nest서버에서 실행 하기로 했습니다..도저히 다른곳에서 시작하기가… NestJs 와 TypeOrm 연동 포스팅은 나중에 진행 하기로 하고 지금은 엔티티생성 관계 설정까지만!!! 먼저 User 엔티티를 만들어보도록 합니다. 최대한 간단하게 ㅎ 12345678910111213141516171819202122232425262728293031323334import { Column, Entity, PrimaryGeneratedColumn } from &quot;typeorm&quot;;export enum UserRole { ADMIN = &quot;admin&quot;, EDITOR = &quot;editor&quot;, GHOST = &quot;ghost&quot;}@Entity()export class Users { @PrimaryGeneratedColumn() id: number; @Column('varchar', { name: 'email', unique: true, length: 30 }) email: string; @Column('varchar', { name: 'name', length: 20, unique: true }) name: string; @Column('int', { name: 'age' }) age: number; @Column('varchar', { name: 'job', length: 10, nullable: true }) job: string; @Column({ name: 'role', type: 'enum', enum: UserRole, default: UserRole.ADMIN }) role: UserRole;} 그리고 관계를 맺기위한 Post 엔티티를 생성합니다. 1234567891011121314import { Column, Entity, PrimaryGeneratedColumn } from &quot;typeorm&quot;;@Entity()export class Posts { @PrimaryGeneratedColumn() id: number; @Column('varchar', { name: 'title', length: 150 }) title: string; @Column('text', { name: 'content' }) content: string;} 엔티티를 생성하고 잠시 데이터베이스에 테이블이 잘 생성 됬는지 확인을 먼저 해봐야죠? 두개의 테이블이 모두 생성 되었습니다. 이제 두 테이블간의 관계를 설정해 주도록 하겠습니다. 지금까지의 데이터베이스 테이블 관계 설정을 할 때 사실 제일 많이 사용되는게 1 대 다 관계였는데 1대1 관계는 그다지 설정할 일이 별로 없었고시퀄라이즈에을 사용하였을때만 다대다를 설정해 보았기 때문에 이번 테스트는 1 대 다 관계를 통해 테스트를 진행 할 예정 입니다. 먼저 User 엔티티에 @OneToMany 데코레이터를 통해 설정을 해줍니다. 123456789101112131415161718192021222324252627282930313233343536373839import { Column, Entity, OneToMany, PrimaryGeneratedColumn } from &quot;typeorm&quot;;import { Posts } from &quot;./posts.entity&quot;;export enum UserRole { ADMIN = &quot;admin&quot;, EDITOR = &quot;editor&quot;, GHOST = &quot;ghost&quot;}@Entity()export class Users { @PrimaryGeneratedColumn() id: number; @Column('varchar', { name: 'email', unique: true, length: 30 }) email: string; @Column('varchar', { name: 'name', length: 20, unique: true }) name: string; @Column('int', { name: 'age' }) age: number; @Column('varchar', { name: 'job', length: 10, nullable: true }) job: string; @Column({ name: 'role', type: 'enum', enum: UserRole, default: UserRole.ADMIN }) role: UserRole;// 관계 설정 @OneToMany(() =&gt; Posts, (posts) =&gt; posts.users) posts: Posts[];} 그리고 다음 Post 엔티티에는 OneToMany의 반대 ManyToMany를 설정한다. 12345678910111213141516171819202122import { Column, Entity, JoinColumn, ManyToOne, PrimaryGeneratedColumn } from &quot;typeorm&quot;;import { Users } from &quot;./user.entity&quot;;@Entity()export class Posts { @PrimaryGeneratedColumn() id: number; @Column('varchar', { name: 'title', length: 150 }) title: string; @Column('text', { name: 'content' }) content: string; @ManyToOne(() =&gt; Users, (user) =&gt; user.posts, { nullable: false, onDelete: 'CASCADE', }) @JoinColumn([{ name: 'Userid', referencedColumnName: 'id' }]) users: Users;} ManyToOne에서는 JoinColumn 을 생략이 가능하지만 기본적으로 생성해주는 이름이 마음에 안들거나 데이터 베이스 설계시 특정 컬럼을 참조하기로 했다면 설정하면 좋을 것 같다고 생각한다. 이렇게 관계를 설정해주고 다시 데이터베이를 확인해본다. 확인 결과 다음과 같이 Post테이블에서는 User테이블의 Pk를 참조 하는 관계가 설정이 된 것을 확인 할 수 있다.","link":"/2021/09/09/typeorm/TypeOrm-Test/"},{"title":"Nodejs express로 에어비앤비 클론코딩 해보기 1.","text":"에어비앤비 클론코딩 해보기 1. Nodejs를 학습하고 학습한 내용을 바탕으로 무언가를 만들어봐야 겠다는 마음 하나로 무턱대고 혼자 진행했던 프로젝트입니다.실제 서비스까지의 구현을 목표로 하지 않고 node.js와 express를 이용한 앱을 만들어보고자 진행했던 프로젝트라 많이 힘들었고 좋은 결과물이 나오지는 못했지만 처음으로 스스로 처음부터 만들어본 것 이기 때문에 이후 다른 어떤 프로젝트에서도 기본적인 개념을 알고 진행하는데 있어 충분한 학습 효과가 있었던 프로젝트 입니다. Github : https://github.com/hanjuren/Node 프로젝트의 전체적인 구조 Nodejs기반 express앱 mysql 데이터 베이스 사용 및 sequelize 사용 view를 위해 nunjucks 템플릿 엔진 사용 passport를 통한 사용자 인증 기능 구현 완성 결과 사용한 패키지 express express-session express-mysql-session passport passport-local passport-kakao passport-naver passport-facebook bcrypt cookie-parser dotenv morgan multer nunjucks mysql2 sequelize sequelize-cli nodemon 프로젝트를 진행하며 느낀점node.js의 기본적인 학습만 진행하고 바로 작업을 진행하며 하나씩 붙여나가는 과정이 스스로 무언가를 만들어낸다는 것에 의미가 큰 과정이였습니다.비록 작업을 계속 해나가며 프로젝트의 과정이 설계를 하지 않고 혼자 추가해보고 싶은 기능을 구현하다보니 두서 없는 과정으로 진행되었지만 기능 하나하나 스스로 만들며막히는 부분을 해결해 나가는 과정이 의미있었습니다.하지만 이 과정을 겪고서 작고 사소한 프로젝트라도 시작 전 설계의 중요성과 구조를 잡고 시작해야하는 중요성을 크게 느끼게 되었고 무턱대고 작업을 한다고 해서 그저 돌아가기만 하는 기능을 만드는 것이무의미 하다는 것도 느끼게된 프로젝트 였습니다.아쉬웠던 점은 클론코딩을 하다보니 스스로 생각해내는 기능은 적고 클론코딩의 대상이 된 웹의 기능을 어떤식으로 구현해볼지에 대해 고민을 하던 시간이 대부분이였던 것에 아쉬움을 느꼈습니다.스스로 만들어나가는 과정은 뿌듯했지만 새로운 것을 만들어 낸다는 느낌보다는 기능을 가능한 수준에서 모방하기만 한다는 느낌이 컷던 만큼 이후 프로젝트에서는 하나의 기능을 만들더라도많은 고민과 보다 좋은 기능을 만들 수 있는 측면까지 고민하며 작업해야겠다라고 생각하게 되었습니다. 또한 이 프로젝트의 결과물에 대해 다시 한번 글을 작성하며 이런 부분은 지금보니 이렇게 개선하면 되겠다는 부분을 생각을 많이 하게되었던 프로젝트 입니다.이 프로젝트에서 했던 내용을 기록하며 다시 공부한다는 마음으로 진행 부분을 기록하려 합니다.","link":"/2021/09/09/project/airbnb/Nodejs-express%EB%A1%9C-%EC%97%90%EC%96%B4%EB%B9%84%EC%95%A4%EB%B9%84-%ED%81%B4%EB%A1%A0%EC%BD%94%EB%94%A9-%ED%95%B4%EB%B3%B4%EA%B8%B0-1/"},{"title":"Nodejs express로 에어비앤비 클론코딩 해보기 3.","text":"숙소 업로드 구현 숙소 업로드 라우터 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 try { fs.readdirSync('uploads');} catch (error) { console.error('uploads 폴더가 없어 uploads 폴더를 생성 합니다.'); fs.mkdirSync('uploads');}const upload = multer({ storage: multer.diskStorage({ destination(req, file, cb) { cb(null, 'uploads/'); }, filename(req, file, cb) { const ext = path.extname(file.originalname); cb(null, path.basename(file.originalname, ext) + Date.now() + ext); }, }),});// 게시글 업로드router.post('/host', isLoggedIn, upload.array('img'), async (req, res, next) =&gt; { const hostaddress = req.body.firstCity.concat(&quot; &quot;, req.body.middleCity,&quot; &quot;, req.body.hostaddress); try{ const newHost = await Host.create({ title: req.body.title, hostaddress, city: req.body.firstCity, person: req.body.person, roominfo_room: req.body.room, roominfo_bed: req.body.bed, roominfo_cook: req.body.cook, roominfo_bathroom: req.body.bathroom, hostinfo: req.body.hostinfo, hosttype: req.body.hosttype, UserId: req.user.id, }); for(i=0; i&lt;req.files.length; i++){ let newImage = await Image.create({ src: &quot;img/&quot; + req.files[i].filename, HostId: newHost.id, }); } console.log(&quot;success&quot;); res.redirect('/'); } catch (error) { console.log(error); next(error); }}); 숙소 업로드 라우터는 숙소 정보를 담는 Host모델과 숙소의 사진을 담는 Image모델을 사용하여 업로드를 진행한다. 사진 파일들은 multer 모델을 사용하여 업로드했고 이미지의 파일 이름을 Image모델에 담아 주었다. 이미지 업로드는 이미지의 갯수 만큼 생성하도록 반복문을 사용하여 진행했는데 더 좋은 방법이 있을 수 도 있지만 간단하게 구현 했다. 결과 숙소 정보를 입력해주고 데이터를 서버로 보낸다. 입력한 데이터가 hosts 테이블에 잘 저장 되었다. 이제 입력한 데이터들을 화면에 뿌려 주면 된다. 보완점 업로드 라우터에서 업로드를 실행 하기 전에 로그인 여부를 확인하는 미들웨어를 사용했는데 이 미들웨어는 로그인 여부만 확인 해줄 뿐 사용자가 호스트 권한이 있는지 여부는 확인 해 주지 않는다. 호스트를 확인 할 수 있는 미들웨러를 따로 만들면 라우터 코드가 줄고 간결할 것 같다. Nodejs express로 에어비앤비 클론코딩 해보기 3. https://hanjuren.github.io/2021/08/31/project/airbnb/Nodejs-express로-에어비앤비-클론코딩-해보기-3/","link":"/2021/09/09/project/airbnb/Nodejs-express%EB%A1%9C-%EC%97%90%EC%96%B4%EB%B9%84%EC%95%A4%EB%B9%84-%ED%81%B4%EB%A1%A0%EC%BD%94%EB%94%A9-%ED%95%B4%EB%B3%B4%EA%B8%B0-3/"},{"title":"Nodejs express로 에어비앤비 클론코딩 해보기 2.","text":"Sequelize Model 구축 Mysql 데이터베이스를 사용하며 Sequelize를 통해 데이터 관리를 했다. 시쿼라이즈를 통한 데이터베이스 사용을 위해 모델을 구축하는 과정을 기록합니다. DB 관계 User 1 : N HostUser 1 : N ReviewUser 1 : N ReservationUser 1 : N Favorite Host 1 : N ImageHost 1 : N FavoriteHost 1 : N ReservationHost 1 : N Review 많은 모델을 설계하지는 않았지만 각각 필요한 모델이라고 생각하는 모델을 구축했다.기본적으로 유저와 게시글을 기준하여 예약 기능에 필요한 모델 찜 모델, 리뷰 모델 정도로 구성했다. 자세한 코드는 깃헙에 올렸으니 기본적인 관계 설정과 모델 구조는 깃에서 확인하면 될 것 같다. Model file : github","link":"/2021/09/09/project/airbnb/Nodejs-express%EB%A1%9C-%EC%97%90%EC%96%B4%EB%B9%84%EC%95%A4%EB%B9%84-%ED%81%B4%EB%A1%A0%EC%BD%94%EB%94%A9-%ED%95%B4%EB%B3%B4%EA%B8%B0-2/"},{"title":"Nodejs express로 에어비앤비 클론코딩 해보기 4.","text":"local 계정 회원가입 구현 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374 // 프론트 코드document.getElementById('join__form').addEventListener('submit', (e) =&gt; { e.preventDefault(); const joinData = { email: e.target.email.value, password: e.target.password.value, name: e.target.name.value, nickname: e.target.nickname.value, phone: e.target.firstNum.value + e.target.middleNum.value + e.target.lastNum.value, } console.log(joinData); if(joinData.email === &quot;&quot; ) { return alert('이메일을 입력해주세요.'); } if(joinData.password &lt; 4) { return alert('비밀번호는 4글자 이상입니다.'); } if(joinData.name === &quot;&quot; || joinData.nickname === &quot;&quot; || joinData.phone === &quot;&quot; || joinData.phone.length &gt; 11) { return alert('잘못된 정보입니다.'); } axios.post('/auth/join', joinData) .then((response) =&gt; { if(response.data.joinsuccess){ alert(response.data.message); return window.location = &quot;/login&quot;; } alert(response.data.message); return location.reload(); }) .catch((error) =&gt; { console.log(error); }); e.target.email.value = ''; e.target.password.value = ''; e.target.name.value = ''; e.target.nickname.value = ''; e.target.firstNum.value = ''; e.target.middleNum.value = ''; e.target.lastNum.value = ''; });// 서버 코드router.post('/join', isNotLoggedIn, async (req, res, next) =&gt; { try { const { email, password, name, nickname, phone, } = req.body; console.log(req.body); //const phone = firstNum + middleNum + lastNum; const user = await User.findOne({ where: {email} }); if(user) { return res.json({ joinsuccess: false, message: &quot;입력하신 이메일로 가입한 계정이 존재합니다...&quot; }); } const hash = await bcrypt.hash(password, 12); const newUser = await User.create({ email, password: hash, name, nickname, phone, }); return res.json({ joinsuccess: true, message: &quot;회원가입 성공입니다.&quot;}); } catch (error) { console.error(error); return res.json({ joinsuccess: false, message: &quot;데이터 베이스 오류 입니다 관리자에게 문의 하세요...&quot;}); }}); 회원 가입 페이지에서 가입 정보를 받아온 후 User모델에 새로운 데이터를 생성하여 회원을 생성한다. 가입 전 회원을 구분할 수 있는 이메일로 기존의 데이터와 일치한 정보가 있는지 확인을 하고 없을 때 생성하는 방식으로 진행했다… 결과 회원 가입을 할 정보를 입력한다. 서버에서 처리 후 json형식으로 보낸 데이터에 따라 성공 실패 여부를 확인 한다. 입력한 데이터가 없는 회원이기 때문에 성공이라는 메시지를 띄웠고 성공했다는 것을 알수있다..✌✌ users 테이블을 확인하면 아까 입력한 데이터가 성공적으로 생성 된 것을 확인 할 수 있다. 👍 문제점 로컬 계정 회원 가입 처리 코드 작성은 간단하게 구현해서 어렵게 느껴지지는 않았지만… 페이지에서 데이터를 보낼 때 검사하는 방법이 너무 많고 어려운게 많아서 간단하게 검사 후 서버로 데이터를 보내는 방식으로 진행했다… 자바 스크립트를 이용해서 데이터를 검사해서 보내야 하는 방법에 치여서 조금 어려움을 느꼈다 자바스크립트의 공부가 필요하다는 것을 느끼는 과정 이였다. 보완점 혼자 하는 프로젝트라서 많은 것을 축소해서 진행 하려 하다 보니 회원 가입 과정이 너무 단순하다는 생각이 들었다. 많은 사이트들을 참고해서 비슷한 과정으로 만들고 싶었지만 본인 인증 부분을 제외 시킨 것이 조금 아쉽다. 본인 인증 구현도 공부해서 사용해봐야겠다. Nodejs express로 에어비앤비 클론코딩 해보기 4. https://hanjuren.github.io/2021/08/31/project/airbnb/Nodejs-express로-에어비앤비-클론코딩-해보기-4/","link":"/2021/09/09/project/airbnb/Nodejs-express%EB%A1%9C-%EC%97%90%EC%96%B4%EB%B9%84%EC%95%A4%EB%B9%84-%ED%81%B4%EB%A1%A0%EC%BD%94%EB%94%A9-%ED%95%B4%EB%B3%B4%EA%B8%B0-4/"},{"title":"아파트 온도, 습도, 전력 실시간 데이터 관리 프로젝트 Part 1.","text":"아파트 실시간 데이터 관리 프로젝트아파트 실시간 데이터를 전송받아 저장하고 사용자에게 데이터를 제공하는 서비스를 만들어보았다.Node.js, express를 기반으로 하여 서버를 구성하고 사용자가 데이터를 볼 수 있는 View는 기본적인 html로 구성하여 백엔드 구축을 중점으로 한 프로젝트이다. 실시간 데이터를 전송받기 위해 선택한 통신방법은 MQTT통신을 사용하였다.소켓 통신을 통해 실시간 데이터 처리를 하려했던 과정에서 MQTt통신으로 방법을 변경하게 된 이유는 다음과 같은 이유였다. Socket 과 Mqtt 통신 모두 실시간으로 데이터를 전송 할 수 있지만 Socket은 데이터의 전송을 하고 응답을 기다리고 있다. 하지만 우리의 프로젝트는 실시간 데이터를 전송만 받을 뿐 다시 응답을 돌려 주지 않기 때문에 필요없는 자원이 소모된다. 그러나 Mqtt통신은 데이터의 전송을 하지만 응답을 대기하지 않는다. 실시간 통신을 위한 서버와의 연결이 비정상적으로 해제 되었을 때 Socket은 재 연결 까지 전송 받아야 하는 데이터가 유실된다. 반면 Mqtt통신은 연결이 해제 되어도 데이터를 연결이 될 때까지 보관 후 연결시 순차적으로 전송해주기 때문에 유실 가능성이 적다. 프로젝트에서 가공하는 데이터가 온도, 습도, 전력 과 같은 데이터이기 때문에 아두이노 같은 IOT기기에 적합한 통신 방법을 사용해 보기 위해서 그렇다면 WebSocket과 Mqtt는 무엇이 다른가??? WebSocket이란 TCP기반 소켓 통신을 대체할 목적에서 등장한 양방향 통신기법이다. Mqtt란 저전력, 신뢰할 수 없는 네트워크 등의 상황에서 사용하는 메시징 프로토콜이다. 두가지 모두 실시간 통신이 가능하지만 두 방식을 직접 적으로 비교할 수는 없다고 한다. 이유를 알아보니 통신 레벨의 차이와 mqtt는 통신 프로토콜에 의존하지 않으며 패킷 구조로 데이터를 전송하는 차이점이 있다. 간단하게 두가지의 차이점을 알아보고 우리는 왜 Mqtt를 선택하여 실시간 온도 등의 데이터를 전송받기로 했는가에 대한 이유를 알아보자. Why Mqtt? 데이터의 유실을 최소화 할 수 있다.프로젝트에서 데이터를 3초에 한번씩 전송을 받는다는 가정으로 진행을 했다. 3초에 한번 모든 데이터가 서버로 들어오는 와중 서버와 소켓연결이 끊기고 1분뒤에 재연결이 되었다. 우리는 20번의 데이터를 찾을 수 없다. 물론 소켓연결 해제시 재연결과 유실되는 데이터를 중계하여 관리 한다면 유실 가능성이 적어 지지만 단적인 예로 중간에 비어버린 데이터를 찾을 수 없다.하지만 Mqtt는 데이터를 전송 후 데이터의 전송 여부 패킷을 추적이 가능하며 비어있는 중간의 데이터를 받을 수 있다는 차이점이 있다. 데이터 크기가 적다.Mqtt데이터는 패킷 구조로 이루어져 있고 크기가 비교적 다른 통신에 비해 작다는 장점이 있다. Mqtt통신이 저전력 환경에서 통신을 하는 환경에 사용하기 때문에 비교적 데이터의 패킷 크기가 작다. 사물인터넷에서는 주로 Mqtt를 이용한다.Mqtt는 주로 사물인터넷 환경에서 사용하게 된다. mqtt는 저전력 환경에서 통신을 성공시키기 위해 구조가 잘 되어있다. 상시 전력이 들어오지 않을 수 있는 환경에서 사요하기 때문에 이러한 부분에서 발달이 되어있다. Mqtt Setting실제 아두이노와 같은 기기를 활용하여 데이터를 받을 수 없기 때문에 테스트 코드를 사요하여 가상의 데이터를 생성하고 mqtt를 통해 데이터를 계속해서 전송해준다. 123456789101112131415161718192021222324252627282930const mqtt = require('mqtt');describe(&quot;Mqtt Test&quot;, () =&gt; { before(&quot;connection&quot;, () =&gt; { console.log(&quot;connection Success&quot;); }); it(&quot;public topic&quot;, () =&gt; { try { const mqttClient = mqtt.connect(/* url */ ); setInterval(() =&gt; { const data = { aptComplex: &quot;1단지&quot;, // 아파트 단지 aptDong: &quot;101동&quot;, // 아파트 동 number: &quot;101호&quot;, // 아파트 호수 temperature: rand(18, 38), humidity: rand(30, 50), watt: rand(1, 2)/10, } // console.log(`send data = ${JSON.stringify(data)}`) mqttClient.publish(/*토픽 이름*/, JSON.stringify(data)); }, 2000) } catch (e) { console.log(e) } })}); publish로 전송하고자 하는 토픽을 통해 데이터를 전송하게 된다. 이 데이터를 서버에서 받기 위해서는 같은 이름의 토픽을 구독하면 데이터가 들어온다. 123... this.mqttClient.subscribe(this.topic);... subscribe(구독)을 통해 토픽이름으로 들어오는 데이터를 전송 받을 수 있다. Mqtt를 경험하며.Mqtt통신에 대해 IOT분야에서 현업 활동중이신 팀원분의 의견으로 또다른 통신 방식에 대해 학습하고 습득할 수 있는 좋은 경험이 되었다. 기본적인 세팅이후 프로젝트 구조에 맞게 수정해가며mqtt 모듈의 메서드 하나하나 어떤 이벤트가 발생하고 동작하는지 알아보는 시간을 가지며 좋은 경험을 했다. 버퍼 형태로 오는 데이터를 다시 문자로 바꾸고 어디서 부터 버퍼형태로 넘어왔는지 왜 버퍼형태였는지 삽질을 해가며 뜯던 시간 모두 영양가 있는 시간이였다.","link":"/2021/11/02/project/apt/%EC%95%84%ED%8C%8C%ED%8A%B8-%EC%98%A8%EB%8F%84-%EC%8A%B5%EB%8F%84-%EC%A0%84%EB%A0%A5-%EC%8B%A4%EC%8B%9C%EA%B0%84-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B4%80%EB%A6%AC-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-Part-1/"},{"title":"Nodejs express로 에어비앤비 클론코딩 해보기 5.","text":"도시별 숙소 보여주기 도시별 숙소 라우터 12345678910111213141516171819202122232425262728293031323334353637383940414243 router.get('/city', async (req, res, next) =&gt; { try { let hosts; let count; let city; let category... hosts = await Host.findAll({ where: { hostaddress: { [Op.like]: &quot;%&quot; + req.query.city + &quot;%&quot; }, }, include: { model: Image, attributes: ['src'], }, order: [['id', 'DESC']], offset: offset, limit: 12, }); count = await Host.count({ where: { city: { [Op.like]: &quot;%&quot; + req.query.city + &quot;%&quot; }, }, }); if(req.query.city) { city = req.query.city; } else { city = &quot;전체&quot; } res.render('hosts', {hosts, count, city}); } } catch (error) { console.error(error); next(error); }}); 숙소의 주소 중 도시 컬럼의 값을 비교하여 해당 도시의 숙소를 가져오는 방식이다. 각 정보를 담는 변수는 다른 조건의 검색 기능에도 사용할 예정이라 미리 만들어서 각각 값을 넣어주는 방식으로 진행했다. 카운트를 해주는 이유는 보내주는 숙소들의 합계를 구해 넘겨서 페이징 처리를 하기 위함이다. 결과 데이터 확인 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 [ Host { dataValues: { id: 1, title: '테스트용 1번 숙소입니다', hostaddress: '서울특별시 강남구 포일세거리로 23 101 - 705', city: '서울특별시', person: '최대 3명', roominfo_room: '2개', roominfo_bed: '싱글 침대 2개', roominfo_cook: '취사 가능', roominfo_bathroom: '1개', hostinfo: '테스트용 숙소 1번입니다\\r\\n\\r\\n숙소 업로드가 잘 진행되는지 확인합니다.', hosttype: '펜션', createdAt: 2021-04-01T19:25:20.000Z, updatedAt: 2021-04-01T19:25:20.000Z, deletedAt: null, UserId: 1, Images: [Array] }, _previousDataValues: { id: 1, title: '테스트용 1번 숙소입니다', hostaddress: '서울특별시 강남구 포일세거리로 23 101 - 705', city: '서울특별시', person: '최대 3명', roominfo_room: '2개', roominfo_bed: '싱글 침대 2개', roominfo_cook: '취사 가능', roominfo_bathroom: '1개', hostinfo: '테스트용 숙소 1번입니다\\r\\n\\r\\n숙소 업로드가 잘 진행되는지 확인합니다.', hosttype: '펜션', createdAt: 2021-04-01T19:25:20.000Z, updatedAt: 2021-04-01T19:25:20.000Z, deletedAt: null, UserId: 1, Images: [Array] }, _changed: Set(0) {}, _options: { isNewRecord: false, _schema: null, _schemaDelimiter: '', include: [Array], includeNames: [Array], includeMap: [Object], includeValidated: true, attributes: [Array], raw: true }, isNewRecord: false, Images: [ [Image], [Image], [Image], [Image] ] }]1 서울시 숙소를 가져오도록 하였고 현재 숙소는 1개이다. 숙소에 대한 데이터와 숙소들의 총 합계도 잘 구해진 것을 확인 할 수 있다. 화면 서울시의 숙소에 대한 데이터를 가져왔고 가져온 모든 데이터를 사용한 것은 아니지만 데이터 확인을 위해 진행한 것이고 올바르게 잘 가져와 졌다. 👍 보완점 sequelize의 비교 연산자를 처음 써보면서 조금 헷갈리는 부분이 많았다. 공식 문서가 너무 불친절 하지만 잘 참고하여 원하는 결과를 얻을 수 있게 공부가 더 필요하다. 지금은 한 개의 데이터만 가져오지만 위에서 진행한 것처럼 필요하지 않은 데이터까지 넘겨 주는 건 올바르지 않다. 필요한 데이터만 보낼 수 있도록 코드를 조금 수정해야 할 필요가 있다.","link":"/2021/09/09/project/airbnb/Nodejs-express%EB%A1%9C-%EC%97%90%EC%96%B4%EB%B9%84%EC%95%A4%EB%B9%84-%ED%81%B4%EB%A1%A0%EC%BD%94%EB%94%A9-%ED%95%B4%EB%B3%B4%EA%B8%B0-5/"},{"title":"아파트 온도, 습도, 전력 실시간 데이터 관리 프로젝트 마무리하며.","text":"아파트 실시간 데이터 관리 프로젝트를 마무리하며 느꼈던점Node.js를 기반으로한 협업을 통해? 사실 현업에 계신 분 2명과 취준생 2명이 모인 스터디라 현업 개발자 분들 께서 많은 정보와 팁을 알려주신 재능기부 현장느낌이였다. 하지마 어디서도 들을 수 없는… 그런 정보들을 얻는 기회였다고 생각한다. 물론 프로젝트를 그분들께 의존하지는 않았다. 기본적인 세팅과 아이디어를 제공해주시고 거의 2명이 만든 그런 느낌이였다. Mqtt라는 통신기법에 대해 처음 알게되었고 어떤 기능을 위해 여러가지 고려하여 다양한 선택을 하는 생각의 폭을 넓힐 수 있는 좋은 경험으로 생각된다. 무턱대고 기능을 위해 내가 아는 것만 활용하여 물론 아는것이 많지도 않다. 하지만 틀에 갖혀서 개발하는 것보다 기능을 위해 많은 것을 생각하고 고려하면 또다른 방향으로도 더 좋은 결과를 낳을 수 있다는 것을 느끼는 프로젝트 였다. 또한 과연 내가 백엔드 개발자를 꿈꾸지만 그에 맞는 준비를 하고 있었는가 그냥 무턱대고 코드만 치며 내것이 되었다라고 생각하던 것은 아니였을까 라는 의문을 나에게 던지는 값진 시간이 되었다. 좋은 결과물을 위해서는 많은 공부와 시간을 투자할 준비가 되어있어야 한다. 새로운 것에 대한 도전 그리고 알아가기 위해 노력하는 자세 또 그것을 내 것으로 만들 준비 이러한 덕목이 앞으로 개발자가 되기 위해 내가 준비하는 과정에서 가장 중요하지 않을까 라는 생각이 들었던 프로젝트였다. 지난 프로젝트들을 정리하며 그때 내가 생각했던것을 정리하고 다시 생각을 해보며 그때 생각한 것을 나는 지키고 있는가. 모든 다짐을 지키지는 못했지만 이때 다짐했던 하나의 결과를 위해 고민을 수없이 하고 의문을 가지고 기능 구현에 안주하지 않는 자세를 지금까지 갖고 있었구나 라는 생각을 하게 된다. 어쩌면 프로젝트를 진행하는 과정에서 사용하는 기술, 언어, 모듈에 대한 이해도 모두 중요하지만 이러한 과정에서 나를 발전시킨 것이 아니였을까. 또 아직 더 발전해야 하는 나의 모습을 더욱 앞으로 나아가게 하는 과정이라고 생각된다.","link":"/2021/11/02/project/apt/%EC%95%84%ED%8C%8C%ED%8A%B8-%EC%98%A8%EB%8F%84-%EC%8A%B5%EB%8F%84-%EC%A0%84%EB%A0%A5-%EC%8B%A4%EC%8B%9C%EA%B0%84-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B4%80%EB%A6%AC-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EB%A7%88%EB%AC%B4%EB%A6%AC%ED%95%98%EB%A9%B0/"},{"title":"아파트 온도, 습도, 전력 실시간 데이터 관리 프로젝트 Part 2.","text":"스케줄러를 통한 이메일 보내기 기능 구현사용자의 실시간 데이터를 서버로 전송받고 데이터베이스에 저장하여 쌓인 데이터를 연산하여 사용자에게 특정한 일자에 보내도록 하는 기능을 제공하기로 했다. 가장 먼저 생각한 방식이자 이상적인 방법이였던 카카오톡으로 전송하기는 토이 프로젝트이기에 사업자 번호 등 카카오에서 요구하는 조건에 부딧혀 포기하고 구글 이메일 보내기로 방향을 틀게 되었다. 구상하는 방식은 이렇다. 매월 1일 자정에 모든 동 호수의 데이터를 그래프로 그린다. 각 호수별 사용자이자 입주민이라는 가정하에 그래프 이미지를 이메일로 매월 1일 00시 15분에 발송한다. 스케줄러 활용우리는 node-schedule모듈을 활용하여 스케줄러를 작성하여 메일을 발송하기로 했다. 그래프 이미지 그리기 모든 집의 데이터를 각각 그래프로 그려 이미지로 파일로 저장 그래프 그리기 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768const get_month = () =&gt; { const today = new Date(); return today.getMonth() + 1;}// 아파트 단지, 동, 호 일별 데이터 가져오기const sensorData = async (Complex, Dong, Ho) =&gt; { let exData = await apt_Info.sensorFind(Complex, Dong, Ho); return exData;};// 아파트의 모든 단지 동 호 정보 가져오기const basename = async () =&gt; { const aptInfo = await apt_Info.aptFind(); for(let i=0; i &lt; aptInfo.length; i++) { // 파일 이름 지정 =&gt; ex) 단지 동 호.png let fileName = `${aptInfo[i].AptDong.apt_complex}${aptInfo[i].AptDong.apt_dong}${aptInfo[i].apt_ho}`; // 단지, 동, 호의 센서 데이터 받아오기. let data = await sensorData(aptInfo[i].AptDong.apt_complex, aptInfo[i].AptDong.apt_dong, aptInfo[i].apt_ho); // 차트를 그리기위한 날짜, 데이터 별 배열 분리 let dateArray = []; let humiArray = []; let tempArray = []; let wattArray = []; data.map((sensor) =&gt; { let newDate = new Date(sensor.dataValues.date); dateArray.push(dateAndTime.format(newDate, 'MM-DD')); tempArray.push(sensor.dataValues.humidityAVG); humiArray.push(sensor.dataValues.temperatureAVG); wattArray.push(sensor.dataValues.electricitySUM); }); // 차트 그리기 함수로 파일 이름과 데이터 배열 전달 humiChart(fileName, humiArray, dateArray); tempChart(fileName, tempArray, dateArray); wattChart(fileName, wattArray, dateArray); }; console.log(&quot;차트 그리기 시작&quot;); logger.info('create chart');};// 아파트 모든 세대의 전력 차트 그리기const wattChart = (fileName, data, date) =&gt; { const filewatt = fileName + &quot;watt.png&quot;; saveChart(filewatt, &quot;Watt&quot;, data, date);};// 아파트 모든 세대 온도 차트 그리기const tempChart = (fileName, data, date) =&gt; { const filetemp = fileName + &quot;temp.png&quot;; saveChart(filetemp, &quot;Temp&quot;, data, date);};// 아파트 모든 세대 습도 차트 그리기const humiChart = (fileName, data, date) =&gt; { const filehumi = fileName + &quot;humi.png&quot;; saveChart(filehumi, &quot;Humi&quot;, data, date);};//차트그리기 스케줄러const drawChart = () =&gt; { // 매달 자정에 파일 생성 const jobs = schedule.scheduleJob('0 0 01 * *', function() { basename(); });}; 이미지 그리기 코드 1234567891011121314151617181920212223242526272829303132333435363738394041424344const ChartJsImage = require('chartjs-to-image');const fs = require('fs');const chart = new ChartJsImage();const days = function(month,year) { return new Date(year, month, 0).getDate();};const get_Month = () =&gt; { const today = new Date(); return today.getMonth() + 1;}const makeFolder = (dir) =&gt; { try { if (!fs.existsSync(dir)) { fs.mkdirSync(dir) } } catch (err) { console.error(err) }}const saveChart = async (filename, type, data, date) =&gt; { // 차트 label 지정 const labels = date; // 차트 그리기 chart.setConfig({ type: 'line', data: { labels: labels, datasets: [{ label: type, data }] }, }); // 월별 / 데이터별 파일 구분하기 const folderName = './data/' + (get_Month() - 1); const monthPath = folderName + '/' + type; // Write file to disk makeFolder(folderName); makeFolder(monthPath); await chart.toFile(monthPath + &quot;/&quot; + filename);}module.exports = saveChart; 각각의 파일은 월별 / 데이터 종류로 구분되어 저장되고 저장된 이미지를 사용자에게 전송한다. 이메일 보내기 이메일 보내기 1234567891011121314151617181920212223242526272829303132333435// 이메일 보내기 스케줄러 시간 지정 const mailResult = async () =&gt; { const userinfo = await User.findAll({ attributes: ['uemail', 'apt_ho'], include: { model: AptHo, include: { model: AptDong, } }, }); userinfo.map((user) =&gt; { let emailParam = { toEmail: `${user.uemail}`, subject: `${get_month() -1}월 사용량입니다.`, text: `${get_month() - 1}월 사용량입니다.`, // ex)1단지101동101호 name: `${user.AptHo.AptDong.apt_complex}${user.AptHo.AptDong.apt_dong}${user.AptHo.apt_ho}`, month: get_month() - 1, }; // const rule = new schedule.RecurrenceRule(); // const m = 50; // rule.minute = m; // 매달 1일 0시 15분 이메일 보내기 실행 const j = schedule.scheduleJob('13 13 02 * *', function() { // const j = schedule.scheduleJob(rule, async function() { console.log(&quot;send mail&quot;); // await basename(); logger.info('send mail'); mailSender.sendGmail(emailParam); }); });}; 테스트를 위해 시간을 조정하여 진행하였고 스케줄러 시간 부분만 원하는 시간으로 조정하면 정상적으로 전송이 된다. 결과","link":"/2021/11/02/project/apt/%EC%95%84%ED%8C%8C%ED%8A%B8-%EC%98%A8%EB%8F%84-%EC%8A%B5%EB%8F%84-%EC%A0%84%EB%A0%A5-%EC%8B%A4%EC%8B%9C%EA%B0%84-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B4%80%EB%A6%AC-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-Part-2/"},{"title":"git action AWS Ec2 배포하기 3","text":"Git Action Ec2 Codedeploy 자동배포 하기 3. AWS의 설정을 모두 마치고 git에서 git action을 통해 자동배포를 진행해보도록 한다.자동 배포를 진행하기위해 진행해야 하는 과정은 다음과 같다. git action workflow 작성 appspec.yml 작성 .sh 스크립트 작성 3가지의 과정을 하나씩 진행해보자. git action workflow 작성하기 git action이란? github의 저장소를 기반으로 하여 작성한 스크립트를 이용하여 작업을 진행해주는 서비스이다.git workflow는 저장소에서 일어나는 특성 이벤트시 구동될 스크립트를 작성해주고 git이 이벤트를 감지하여 테스트, 배포 등의 작업을 진행한다.작업의 환경은 window, mac, linux 환경에서 구동 할 수 있으며 다양한 스크립트의 샘플이 존재하고 있다. git action workflow작성하기 먼저 작업을 진행하던 레파지토리로 들어간다. 이후 상단의 action 탭을 클릭하면 다음과 같은 화면이 보여진다. 이후 node.js 워크플로우를 클릭하여 샘플 스크립트를 받는다. 샘플 스크립트의 형태는 다음과 같다. 해당 스크립트를 이용하여 작업을 진행하기 위해 우측 상단의 커밋실행을 누르고 로컬 작업 환경으로 레파지토리를 pull로 업데이트를 해준다. 그러면 우리의 로컬 작업 폴더에 다음과 같은 폴더와 파일이 추가된다. 폴더구조는 다음과 같다. node.js.yml파일을 수정하여 자동배포를 위한 과정을 작성해주면 된다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 # node.js.ymlname: Build &amp; Deployenv: PROJECT_NAME: Nestjs-appon: push: branches: - mainjobs: build: runs-on: ubuntu-18.04 steps: - name: Configure AWS credentials uses: aws-actions/configure-aws-credentials@v1 with: aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }} aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }} aws-region: ap-northeast-2 - uses: actions/checkout@v2 - name: Use Node.js uses: actions/setup-node@v1 with: node-version: '14.x' - name: delete package-lock.json run: rm package-lock.json - name: Install Dependencies run: npm install - name: Build run: npm run build - name: Create env file run: | mkdir secret cd secret touch .env.development cat &lt;&lt; EOF &gt;&gt; .env.development ${{ secrets.ENV }} EOF cd ../ - name: Make tar file run: tar -cpvzf ./$GITHUB_SHA.tgz * shell: bash - name: Upload to S3 run: | aws s3 cp \\ --region ap-northeast-2 \\ ./$GITHUB_SHA.tgz s3://nestjs-s3-test/$PROJECT_NAME/$GITHUB_SHA.tgz - name: Code Deploy run: aws deploy create-deployment --application-name Nesjs-App --file-exists-behavior OVERWRITE --deployment-config-name CodeDeployDefault.OneAtATime --deployment-group-name Nestjs-group --s3-location bucket=nestjs-s3-test,bundleType=tgz,key=$PROJECT_NAME/$GITHUB_SHA.tgz 전체적인 내용은 이렇게 생겼다. 부분적으로 이해를 해보자면 1234 on: push: branches: - main on 태그는 어떤 이벤트가 일어날때 밑에 작성한 스크립트를 실행할지 정하는 것이다. 여기서는 main브랜치에 push가 될때 작업을 실행하기로 지정해두었다. 123 jobs: build: runs-on: ubuntu-18.04 git action 작업을 우분투 환경에서 실행한다는 의미이며 윈도우나 맥 또다른 리눅스 OS를 사용하여 작업해도 된다. 하지만 Ec2인스턴스에 배포할 예정이기 때문에 리눅스 환경에서 작업하는 것을 추천한다. 1234567 steps: - name: Configure AWS credentials uses: aws-actions/configure-aws-credentials@v1 with: aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }} aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }} aws-region: ap-northeast-2 steps는 밑으로 나열된 작업들을 순차적으로 실행한다는 의미이다. 먼저 aws에 사용자 인증을 위해 인증 절차를 진행해준다. secrets. 으로 작성된 부분은 git 레파지토리 세팅 탭에서 작성할수 있으며 비밀키 갑을 불러와 과정을 진행한다. 자세한 내용은 생략하도록 한다. 123456789101112131415161718192021222324 - uses: actions/checkout@v2 - name: Use Node.js uses: actions/setup-node@v1 with: node-version: '14.x' - name: delete package-lock.json run: rm package-lock.json - name: Install Dependencies run: npm install - name: Build run: npm run build - name: Create env file run: | mkdir secret cd secret touch .env.development cat &lt;&lt; EOF &gt;&gt; .env.development ${{ secrets.ENV }} EOF cd ../ nodejs기반 프로젝트를 빌드하기위해 nodejs 환경에서 다음의 작업을 진행한다라고 명시해준 후 pakage-lock.json파일을 지워준다. 이유는 애초에 깃에 올리지 않아도 되지만 올려진 상태에서 리눅스에서 npm install을 할 경우 윈도우 작업 환경과 충돌하는 패키지가 있을 수 있기 때문에 지우고 다시 npm install을 통해 생성해준다.이후 빌드 과정을 거친 후 env파일을 생성해준다.폴더를 만들고 진행하는 이유는 gitignore에 걸려서 s3에 같이 업로드가 안되길래 새로운 폴더를 통해 작성하고 ec2환경에서 다시 복사해오는 방식을 선택했다… 더 좋은 방법이 있겠지만 해당 방법을 택했다… 12345678910111213 - name: Make tar file run: tar -cpvzf ./$GITHUB_SHA.tgz * shell: bash - name: Upload to S3 run: | aws s3 cp \\ --region ap-northeast-2 \\ ./$GITHUB_SHA.tgz s3://nestjs-s3-test/$PROJECT_NAME/$GITHUB_SHA.tgz - name: Code Deploy run: aws deploy create-deployment --application-name Nesjs-App --file-exists-behavior OVERWRITE --deployment-config-name CodeDeployDefault.OneAtATime --deployment-group-name Nestjs-group --s3-location bucket=nestjs-s3-test,bundleType=tgz,key=$PROJECT_NAME/$GITHUB_SHA.tgz 프로젝트 폴더내용을 압축하여 S3버킷에 업로드하는 과정 이후 codedeploy가 해당 파일을 읽고 실행할 수 있도록해주는 내용이다. 조금 디테일하게 보자면 ‘./$GITHUB_SHA.tgz s3://버킷이름/$PROJECT_NAME/$GITHUB_SHA.tgz’ ‘–application-name 애플리케이션 이름’ ‘–deployment-group-name 배포그룹이름’ ‘–s3-location bucket=버킷이름,bundleType=tgz,key=$PROJECT_NAME/$GITHUB_SHA.tgz’ &lt;- 압축한 파일 이름과 경로 appspec.yml 작성 해당 파일은 Codedeploy배포시 ec2인스턴스 내에서 실행 하게 될 스크립트를 정의하는 파일이다. 12345678910111213141516171819 # appspec.ymlversion: 0.0os: linuxfiles: - source: / destination: /home/ec2-user/nest-apppermissions: - object: /home/ec2-user pattern: '**' owner: root group: roothooks: BeforeInstall: - location: scripts/before_deploy.sh runas: root AfterInstall: - location: scripts/after_deploy.sh runas: root 내용의 구성은 스크립트가 실행될 디렉토리를 적고 해당 위치에서 실행될 스크립트 파일의 이름을 지정한다.BeforeInstall은 프로젝트가 실행되기 이전의 작업을 지정해놓은 파일이고 AfterInstall은 프로젝트 앱을 실행할 스크립트의 파일이다. 123456789 # scripts/before_deploy.sh#!/bin/bashREPOSITORY=/home/ec2-usercd $REPOSITORYpm2 killsudo rm -rf nest-app 많은 내용을 포함하여 작성해도 되지만 여기서는 간단하게 작업을 진행했다. pm2로 실행되고 있는 프로세스를 모두 종료한다. 하나의 인스턴스에 여러개의 노드를 사용하는 프로세스가 있다면 한번에 종료시키는 명령어는 문제가 될 수 있기때문에 주의가 필요하다. 기존의 프로젝트 폴더를 삭제해준다. 12345678910111213141516 # scripts/after_deploy.sh#!/bin/bashREPOSITORY=/home/ec2-user/nest-appcd $REPOSITORY# nvm 환경변수 등록export NVM_DIR=&quot;/home/ec2-user/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot;[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/bash_completion&quot;cd secretsudo mv .env.development ../cd ../rm -rf secretnpm start workflow에서 생성한 env파일을 프로젝트의 루트 디렉토리로 옮겨 와주는 작업을 한다. 이후 start 스크립트를 실행하여 프로젝트를 구동 시킨다. nvm 환경변수 등록은 npm 명령어가 인스턴스에 직접 접속했을때는 실행되는데 배포과정에서는 실행되지 않는 문제가 있어서 환경변수를 등록하고 사용하는 과정이다. 모든 스크립트 파일을 작성했으니 다음과정에서 배포가 되는지 테스트를 진행해보도록 한다.","link":"/2021/09/09/aws/git-action-AWS-Ec2-%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B0-3/"},{"title":"Sequelize 시작하기","text":"시퀄라이즈 시작하기프로젝트 생성하기시퀄라이즈란 ORM(Object-relational Mapping)의 한 종류로 분류되며 자바스크립트 객체와 데이터베이스의 릴레이션을 매핑하는 도구이다. 시퀄라이즈에서 사용 할 수 있는 데이터베이스는 이번에 사용 할 Mysql외에도 Postgresql, MariaDB, SqliteDB 등이 있다. 이러한 시퀄라이즈를 사용하는 이유는 SQL을 알지 못하더라도 자바스크립트 문법만으로 SQL이 가능하다는 장점이 있다. 하지만 기본적인 SQL을 모르고 사용하는 것을 권장하지는 않는다. 기본적인 문법은 알아야 시퀄라이즈 사용에 큰어려움이 없다. 시퀄라이즈 시작하기프로젝트 생성하기 1npm init 프로젝트를 생성한 후 시퀄라이즈 사용에 필요한 패키지들을 install 해준다.npm i mysql2 sequelize sequelize-cli3가지 모듈과 뷰 화면에 필요한 템플릿 엔진 및 각 환경에 맞게 사용해주면 된다. 시퀄라이즈 생성터미널에 npx sequelize init을 입력한다.이 후 폴더 구조를 살펴보면 config, models, migrations, seeders 폴더가 프로젝트 폴더에 추가 된 것을 확인 할 수 있다. 기본적인 설정은 여기까지다. express 시퀄라이즈 연결 1234567891011121314151617181920 const express = require('express'); const path = require('path'); const morgan = require('morgan'); const nunjucks = require('nunjucks'); const { sequelize } = require('./models'); const app = express(); app.set('port', process.env.PORT || 3001); ... sequelize.sync({ force: false }) // force: false 실행시마다 테이블을 새로 재생성할건가에 대한 옵션 true or false .then(() =&gt; { console.log('데이터베이스 연결 성공!'); }) .catch((err) =&gt; { console.log(err); }); ... sync 메서드를 사용하여 express서버와 시퀄라이즈를 연결해주면 된다. force옵션은 boolean타입으로 적어주면 되는데 true설정시 기존의 데이터베이스의 모든 데이터와 테이블을 삭제 후 다시 생성하는 옵션이므로상황에 맞게 잘 선택해서 사용해야한다. 👈 잘못하면 데이터가 다 날아가 버리는 그런 일이 일어날 수 있다... config.json 수정 1234567891011121314151617181920212223 { &quot;development&quot;: { &quot;username&quot;: &quot;유저이름&quot;, &quot;password&quot;: &quot;비밀번호&quot;, &quot;database&quot;: &quot;데이터베이스&quot;, &quot;host&quot;: &quot;127.0.0.1&quot;, &quot;dialect&quot;: &quot;사용할 데이터베이스 여기서는 mysql&quot; }, &quot;test&quot;: { &quot;username&quot;: &quot;root&quot;, &quot;password&quot;: null, &quot;database&quot;: &quot;database_test&quot;, &quot;host&quot;: &quot;127.0.0.1&quot;, &quot;dialect&quot;: &quot;mysql&quot; }, &quot;production&quot;: { &quot;username&quot;: &quot;root&quot;, &quot;password&quot;: null, &quot;database&quot;: &quot;database_production&quot;, &quot;host&quot;: &quot;127.0.0.1&quot;, &quot;dialect&quot;: &quot;mysql&quot; }} config파일을 수정하여 데이터베이스 정보와 유저 정보를 입력하고 서버를 실행한다. 123 [nodemon] starting `node app.js`3001 번 포트에서 대기중데이터베이스 연결 성공! 연결 성공시 설정한 로그가 출력되면 연결이 성공 한 것이다. 연결이 실패하면 error로그를 출력된다. 모델 정의하기시퀄라이즈는 데이터베이스의 테이블과 대응되는 관계이며 모델과 테이블을 연결해주는 역할을 하는 기능을 가지고 있다. 따라서 데이터베이스에서 사용할 테이블을 시퀄라이즈에서 정의 해주어야 한다.또한 시퀄라이즈에서는 모델 이름은 단수형 테이블 이름은 복수형으로 네이밍을 하는 암묵적인 규칙이 있다고 한다.. User 모델정의 12345678910111213141516171819202122232425262728293031323334353637383940 const Sequelize = require('sequelize'); module.exports = class User extends Sequelize.Model { static init(sequelize) { return super.init({ name: { type: Sequelize.STRING(20), allowNull: false, unique: true, }, age: { type: Sequelize.INTEGER.UNSIGNED, allowNull: false, }, married: { type: Sequelize.BOOLEAN, allowNull: false, }, comment: { type: Sequelize.TEXT, allowNull: true, }, created_at: { type: Sequelize.DATE, allowNull: false, defaultValue: Sequelize.NOW, }, }, { sequelize, timestamps: false, underscored: false, modelName: 'User', tableName: 'users', paranoid: false, charset: 'utf8', coolate: 'utf8_general_ci', }); } static associate(db) {} }; 모델은 확장 클래스로 정의를 한다. 모델정의는 static init과 associate 두가지로 구분되며 위의 코드를 보면 init 메서드에서는 테이블에대한 설정을 하고 associate 메서드는 비워진 것을 확인 할 수 있다.associate 메서드는 테이블간의 관계를 맺을 때 사용하는 메서드로 사용한다.init 메서드 첫 번째 인수첫 번재 인수로 전달하는 값은 컬럼을 설정하는 값들이다. 이곳에 컬럼명과 자료형을 입력하면 되는데 STRING와 같이 mysql이나 데이터베이스에서 사용하는 자료형과는 조금 다른 형식으로 입력을 하는 것을 볼 수 있다. 이는 시퀄라이즈와 데이터베이스 자료형의 비교를 해보며 작성하면 된다.init 메서드 두 번째 인수두 번째 인수로 전달하는 값은 테이블의 옵션을 설정하는 값들을 작성한다. 테이블의 옵션들을 살펴보면 다음과 같다. sequelize: static init의 매개변수와 연결되는 옵션이다. timestamps: 값이 true면 시퀄라이즈는 createdAt과 updatedAt 컬럼을 추가해준다, 각각의 로우가 생성될 때와 수정될 때의 시간이 자동으로 입력된다. underscored: 시퀄라이즈는 테이블명과 컬럼명을 기본적으로 생성 할 때 camel case로 만든다. 이를 snake case로 바꾸는 옵션이다. modelName: 모델 이름을 설정할 수 있다. tableName: 실제 데이터베이스의 테이블 이름이다. paranoid: true로 설정하면 deletedAt이라는 컬럼을 생성해준다. 이렇게 하면 로우를 삭제할 때 완전히 지우지 않고, deletedAt에 지운 시각이 기록된다. charset, collate: 각각 utf8 과 utf8_general_ci 로 설정해야 한글이 입력된다. 이모티콘까지 입력할 수 있게 하고 싶다면 utf8mb4 와 utf8mb4_general_ci 를 입력해주면 된다. 이렇게 생성한 모델은 서버 구동 시 데이터 베이스에 새로운 테이블을 생성한다. 다음 포스팅에서는 시퀄라이즈의 관계설정에 대해 정리하는 글을 남기도록 해야겠다.","link":"/2021/09/09/sequelize/Sequelize-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"title":"Docker Node.js nodemon","text":"도커를 활용하여 Express를 구동하기 위해 이전 포스팅을 통해 기본적인 앱을 띄워 보았다. 도커를 통해 express를 실행하였지만 코드의 수정이 있을 때 마다 빌드를 다시 해주어야 하는 문제점이 있었다.node.js에서는 nodemon이라는 모듈을 사용하여 개발환경에서 코드의 변경사항이 감지되었을때 자동으로 코드의 반영사항을 포함하기 위해 서버를 재시동 해주며 개발을 진행한다. 도커를 통해 띄운 express를 로컬에서 작업 후 변경사항을 반영해주기 위해서는 도커의 작업 디렉토리와 로컬 작업 디렉토리를 볼륨 연결 설정을 통해 연결해주고 nodemon으로 express를 구동해주면 된다. docker-compose.yml123456789101112131415161718192021222324252627282930313233version: &quot;3.8&quot;services: mysql: image: mysql:5.7 command: --default-authentication-plugin=mysql_native_password --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci restart: always environment: MYSQL_DATABASE: test MYSQL_USER: test MYSQL_PASSWORD: 1210ss MYSQL_ROOT_PASSWORD: 1210ss ports: - &quot;3306:3306&quot; volumes: - ./data:/var/lib/mysql - ./mysql.conf:/etc/mysql/conf.d docker-test: build: context: . args: PORT: &quot;4000&quot; image: docker-node-app container_name: docker-node-app volumes: - .:/usr/src/app - /usr/src/app/node_modules ports: - &quot;1210:4000&quot; docker-compose.yml 파일을 통해 여러 컨테이너를 한번에 관리해주는 방식으로 하나의 서비스를 위해 실행하거나 존재해야하는 이미지들을 한 파일을 통해 정의하는 방식이다. mysql은 이 후 사용할 예정이므로 넘어가도록 하고 volumes옵션이 중요한 부분이다. volumes은 다음과 같이 작성해 주면된다. &lt;로컬 작업 디렉토리&gt;:&lt;도커 컨테이너 디렉토리&gt; 이것은 로컬 디렉토리와 도커의 디렉토리를 연결하겠다는 의미로 코드의 변경이나 생성 삭제와 같은 작업의 결과를 공유해준다. 이 후 nodemon을 통해 express 를 실행하고 로컬에서 작업 후 변경사항이 생기게 되면 도커에서 실행중인 express가 재시동 되며 수정 사항을 반영하게 된다. 1234567891011121314151617FROM node:12ARG PORTRUN mkdir -p /usr/src/appWORKDIR /usr/src/app# . 은 현재 디렉토리의 모든것을 /usr/src/app으로 복사한다는 의미다.COPY . /usr/src/appRUN npm installRUN npm install -g nodemon# Bundle app sourceEXPOSE $PORT# 도커에서 nodemon을 실행하기 위해 필요한 옵션CMD [&quot;nodemon&quot;, &quot;-L&quot;, &quot;app.js&quot;] 컨테이너를 다시 빌드 후 접속하고 코드를 수정하면 변경사항이 자동으로 반영되는 모습을 확인 할 수 있다.","link":"/2021/12/19/docker/Docker-Node-js-nodemon/"},{"title":"Docker 개발환경 세팅하기","text":"Docker 개발 환경 구축회사에서 처음 클론 받은 레포지토리의 개발 환경 구축을 위해 도커환경을 구축하며 사용하던 명령어들과 도커를 이용하여 프로젝트 환경을 세팅하는 기본적인 것들에 대해서 기록하고자 글을 남깁니다. 도커란..도커는 컨테이너 기반으로 작동하는 오픈소스 가상화 플랫폼이다. 도커에서 말하는 컨테이너란 다향한 프로그램과 실행환경을 컨테이너 단위로 추상화하여 동일한 인터페이스를 제공하고 프로그램의 배포 및 관리를 단순하게 작업할 수 있도록 도와준다.백엔드 서버 프로그램이나 데이터 조회를 위한 데이터베이스 서버 등 서비스 운영에 필요한 모든 것을 컨테이너로 추상화하여 사용이 가능하다. 도커를 운용하며 가장 중요한것 중 하나인 컨테이너는 독자적으로 격리된 공간에서 프로세스가 동작하는 방식으로 작동한다. 기존 가상화 서비스는 주로 OS를 가상화하여 사용했는데흔히 VMware, VitrualBox같은 가상머신을 활용하여 사용자 OS위에 새로운 OS를 씌워 사용하는 방식인데 이는 매우 무거울 뿐만아니라 느리다는 단점이 존재한다.도커는 이러한 단점에서 자유로우며 편리함을 제공한다. 이미지컨테이너 실행에 필요한 설정값 등을 포함하고 있는 것이며 도커에서 제공하며 본인이 원하는 버전의 서비스 이미지를 사용한다면 상태값이 변하는 일이 없다. 사용법.기본적인 이론시간은 거두절미하고 (사실 이론은 알면 좋지만? 몰라도 된다고 생각함.. 어치피 쓰다보면 아니까?) 그냥 바로 하나 만들어보자. 계획은 이렇다 Node.js기반으로 그냥 비어있는 express앱에서 간단한 crud가 가능한 정도의 express앱을 만들자. 회사에서 만들어져있는 도커 파일을 보면서처음보고 이게 뭔가… 싶었지만 조금 노가다하고 하나하나 공부하는 맛이 있었다. 서비스를 위한 프로젝트는 아니니 간단하게 사용해보려 한다. Dockerfile 생성.먼저 간단하게 도커파일을 생성 후 express앱을 띄워보는 테스트를 진행하자. 데이터베이스 연결은 나중에 작업하는걸로 하고 진행해보도록 하자. 12345678910111213# 어떤 환경에서 실행 할지 명시한다. 수많은 버전이 있다.FROM node:12WORKDIR /usr/app/src# . 은 현재 디렉토리의 모든것을 /usr/src/app으로 복사한다는 의미다.COPY . /usr/app/srcRUN npm installEXPOSE 3000CMD npm start app.js1234567891011const express = require('express');const app = express();const port = 3000;app.get('/', function (req, res) { res.send('Hello World');});app.listen(port, () =&gt; { console.log(`http://localhost:${port} ::: express app start`);}); 1234567891011121314151617{ &quot;name&quot;: &quot;docker-node-app-test&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;app.js&quot;, &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;start&quot;: &quot;node app.js&quot; }, &quot;author&quot;: &quot;hanjuren&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;dependencies&quot;: { &quot;axios&quot;: &quot;^0.24.0&quot;, &quot;express&quot;: &quot;^4.17.1&quot;, &quot;xlsx&quot;: &quot;^0.17.4&quot; }} 이런식으로 파일을 간단하게 생성해준 후 먼저 도커 이미지를 만들어준다. docker build –tag=docker-node-app-test build명령어를 통해 이미지를 생성해주고 이미지가 생성되었는지 확인해본다. docker images 해당 명령어는 도커로 사용중인 이미지 목록들을 보여주며 tag에 적었던 이름으로 이미지가 생성되면 정상적으로 생성이 된것이다. 이미지 생성이 완료되었고 해당 이미지를 실행하면 express가 실행되며 접속이 가능하다. 실행하기 위한 명령어는 다음과 같다. docker run –name=test -p 4444:3000 docker-node-app-test name옵션에 실행할 컨테이너의 이름을 지정해주고 -p옵션은 로컬 PC에서 4444 포트로 접속시 도커에서 실행중인 3333포트로 매핑하겠다는 옵션이다. 그리고 싷행하고자 하는 이미지 이름을 나열하여 명령어를 입력하면 실행이 된다. 정상적으로 3000포트에서 실행중인 express에 접근하여 작동하는 것이 확인되었다. 다음은 데이터베이스 이미지와 함께 실행하며 express에서 mysql을 같이 사용하며 CRUD작업을 진행해보자.","link":"/2021/12/05/docker/Docker-%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD-%EC%84%B8%ED%8C%85%ED%95%98%EA%B8%B0/"},{"title":"Doker Mysql(sequelize)","text":"Docker MySQL Express 연결하기이전 도커로 express앱을 띄운 후 연결 확인 후 데이터 베이스를 도커로 실행 한 후 express와 연결하는 테스트를 진행해보도록 하자. 먼저 docker-compose.yml에 mysql이미지를 추가해준다. 1234567891011121314151617mysql: image: mysql:5.7 command: --default-authentication-plugin=mysql_native_password --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci restart: always environment: MYSQL_DATABASE: # Database Name MYSQL_USER: # User name MYSQL_PASSWORD: # Password MYSQL_ROOT_PASSWORD: # Root Password ports: - &quot;3306:3306&quot; volumes: - ./data:/var/lib/mysql - ./mysql.conf:/etc/mysql/conf.d docker-compose up 명령 실행 후 mysql이 실행중인 것을 확인하고 docker exec -it #{name} bash 를 통해 mysql로 접근이 가능하다. express sequelize 세팅 npm install sequelize mysql2 sequelize-cli npx sequelize-cli init &lt;- 시퀄라이즈 초기 설정 config 수정1234567891011121314151617181920212223{ &quot;development&quot;: { &quot;username&quot;: &quot;test&quot;, &quot;password&quot;: &quot;1210ss&quot;, &quot;database&quot;: &quot;test&quot;, &quot;host&quot;: &quot;mysql&quot;, &quot;dialect&quot;: &quot;mysql&quot; }, &quot;test&quot;: { &quot;username&quot;: &quot;root&quot;, &quot;password&quot;: null, &quot;database&quot;: &quot;database_test&quot;, &quot;host&quot;: &quot;127.0.0.1&quot;, &quot;dialect&quot;: &quot;mysql&quot; }, &quot;production&quot;: { &quot;username&quot;: &quot;root&quot;, &quot;password&quot;: null, &quot;database&quot;: &quot;database_production&quot;, &quot;host&quot;: &quot;127.0.0.1&quot;, &quot;dialect&quot;: &quot;mysql&quot; }} 데이터 베이스를 환경에 맞게 연결할 수 있는 옵션이 있다. 간단하게 dev 환경 세팅만 진행 후 연결을 해보도록 한다. 123456789101112// app.js// ...sequelize.sync({ force: false }) // force: false 실행시마다 테이블을 새로 재생성할건가에 대한 옵션 true or false .then(() =&gt; { console.log('데이터베이스 연결 성공!'); }) .catch((err) =&gt; { console.log(err); });// ... 다시 docker의 express를 실행해주면 데이터 베이스 연결이 완료된다. 1234567891011 ✘ hanjuryeon  ~/docker-test   main ±  docker-compose up docker-testStarting docker-node-app ... doneAttaching to docker-node-appdocker-node-app | [nodemon] 2.0.15docker-node-app | [nodemon] to restart at any time, enter `rs`docker-node-app | [nodemon] watching path(s): *.*docker-node-app | [nodemon] watching extensions: js,mjs,jsondocker-node-app | [nodemon] starting `node app.js`docker-node-app | express app startdocker-node-app | Executing (default): SELECT 1+1 AS resultdocker-node-app | 데이터베이스 연결 성공!","link":"/2021/12/30/docker/Doker-Mysql-sequelize/"},{"title":"Sequelize Migration","text":"도커를 통해 데이터베이스를 띄우고 express를 실행시켜 연결을 해보았다. MySQL과 연결하여 데이터베이스를 사용하기 위해서 Sequelize를 사용하여 연결까지 성공적으로 연결을 진행하였다. 기존에 시퀄라이즈를 사용할때는 모델을 모두 정의한 후 데이터베이스를 생성하고 모델의 수정사항이 있을때마다 **Sync({ force: false || true })**옵션을 통해 데이터베이스를 수정하며 진행했다. 물론 혼자 사용하는 데이터베이스고 서비스를 하지 않는 디비여서 이런방식으로 사용해도 무방하지만 실무에서 사용하는 데이터베이스는 많은 데이터가 있고 구조의 변경이 일어날때 마다 데이터를 백업한다던지 새로 덤프 한다는 것은 현실적으로 어려움이 있다. 이러한 문제점을 보완하기 위해 ORM에서는 마이그레이션 기능을 지원한다. 마이그레이션이란 어떤 운영환경에서 다른 환경으로 환경의 변화를 위해 옮겨지는 작업을 의미한다. 데이터베이스 마이그레이션이란. 데이터베이스 마이그레이션이란 하나의 데이터베이스를 다른 종류의 데이터베이스로 데이터를 옮기는 경우 혹은 두개의 데이터베이스를 하나의 시스템으로 합치거나 분할 혹은 데이터베이스 모델의 구조적 변경을 진행 하는 모든 과정을 의미한다.데이터 베이스 마이그레이션이란? 그렇다면 시퀄라이즈에서 제공하는 Migration 기능에는 어떤 기능이 있을까? 시퀄라이즈에서는 몇가지 명령어를 통해 마이그레이션 기능을 사용할 수 있다고 한다. Sequelize Migration시퀄라이즈 마이그레이션 기능을 사용하기 위해서는 먼저 sequelize-cli 패키지를 설치해야한다. 1npm install -g sequelize-cli 기존에 시퀄라이즈를 연결했으므로 초기 세팅 과정은 넘어가도록 하고 초기 세팅 과정은 공식문서를 통해 확인이 가능하다. Create Model마이그레이션을 통해 모델을 생성하는 과정이다. **명령어는 sequelize-cli model:generate –name ${modelName} –attributes ${columnName:type}**을 통해 생성이 가능하다. 1sequelize-cli model:generate --name User --attributes nick_name:string 명령어를 실행하면 models 디렉토리에 user.js migrations 디렉토리에 시간-create-user.js 형식의 파일이 생성이 된다. 1234567891011121314151617181920212223242526// models/user.jsconst { Model } = require('sequelize');module.exports = (sequelize, DataTypes) =&gt; { class User extends Model { static associate(models) { User.hasMany(models.Post, { as: 'posts', foreignkey: 'user_id', }); } }; User.init({ nick_name: { type: DataTypes.STRING, allowNull: false, } }, { sequelize, modelName: 'User', tableName: 'users', underscored: true, charset: 'utf8', coolate: 'utf8_general_ci', }); return User;}; User.init 내부에는 명령어 실행 시 –attributes에 지정했던 컬럼과 타입이 지정되며 추가적으로 컬럼을 생성하려면 파일 내부에서 직접 컬럼을 추가해주면 된다. 동일한 방식으로 유저 모델과 게시글 모델 마이그레이션 파일을 생성해주면 된다. 123456789101112131415161718192021222324252627282930313233// models/post.jsconst { Model } = require('sequelize');module.exports = (sequelize, DataTypes) =&gt; { class Post extends Model { static associate(models) { Post.belongsTo(models.User, { as: 'user', foreignkey: 'user_id', }); } }; Post.init({ title: { type: DataTypes.STRING, allowNull: false, }, content: { type: DataTypes.STRING, allowNull: false, }, user_id: { type: DataTypes.INTEGER, } }, { sequelize, modelName: 'Post', tableName: 'posts', underscored: true, charset: 'utf8', coolate: 'utf8_general_ci', }); return Post;}; 두개의 모델 파일이 생성되고 내부에 추가할 컬럼을 입력하며 테이블 생성시 설정할 옵션들을 지정해주면 옵션에 맞게 테이블이 생성이 된다. 또한 유저와 게시글의 1:N 관계를 지정하기 위해 hasMany, belongsTo 옵션을 통해 관계를 지정해주었다. 모델 파일이 성공적으로 생성이 되었으니 마이그레이션 스크립트를 확인해보자. 1234567891011121314151617181920212223242526272829// migrations/20211231045301-create-user.js'use strict';module.exports = { up: async (queryInterface, Sequelize) =&gt; { await queryInterface.createTable('users', { id: { allowNull: false, autoIncrement: true, primaryKey: true, type: Sequelize.INTEGER }, nick_name: { type: Sequelize.STRING, allowNull: false, }, created_at: { allowNull: false, type: Sequelize.DATE }, updated_at: { allowNull: false, type: Sequelize.DATE } }); }, down: async (queryInterface, Sequelize) =&gt; { await queryInterface.dropTable('users'); }}; 1234567891011121314151617181920212223242526272829303132333435363738394041// migrations/20211231045301-create-post.js'use strict';module.exports = { up: async (queryInterface, Sequelize) =&gt; { await queryInterface.createTable('posts', { id: { allowNull: false, autoIncrement: true, primaryKey: true, type: Sequelize.INTEGER }, title: { type: Sequelize.STRING, allowNull: false, }, content: { type: Sequelize.STRING, allowNull: false, }, created_at: { allowNull: false, type: Sequelize.DATE, }, updated_at: { allowNull: false, type: Sequelize.DATE, }, user_id: { type: Sequelize.INTEGER, allowNull: false, references: { model: 'users', key: 'id', }, }, }); }, down: async (queryInterface, Sequelize) =&gt; { await queryInterface.dropTable('posts'); }}; 마이그레이션 파일은 up down 메서드로 구성되며 up은 마이그레이션 실행시 동작하고 down은 실패시 동작할 명령이다. 다양한 옵션과 명령들은 문서를 통해 확인이 가능하다.sequelize migrations docs 모델을 생성하기 위해 up 내부에 createTable 메서드를 사용하고 내부에는 모델 파일과 동일하게 컬럼을 입력해야하며 create_at, updated_at 컬럼은 자동으로 생성되는 컬럼이므로 모델 파일에 정의해줄 필요는 없다. 모델 파일과 마이그레이션 파일을 생성했다면 이제 마이그레이션을 실행해주면 된다. 실행하기 위한 명령어는 sequelizee-cli db:migrate 이며 기본적으로는 env=development 으로 마이그레이션이 실행되니 production환경이나 test환경이라면 env 옵션값을 입력해주면 된다. 1234567891011root@0e9dcef32c40:/usr/src/app# sequelize-cli db:migrate Sequelize CLI [Node: 12.22.8, CLI: 6.3.0, ORM: 6.12.0]Loaded configuration file &quot;config/config.json&quot;.Using environment &quot;development&quot;.== 20211231045323-create-user: migrating ========= 20211231045323-create-user: migrated (0.024s)== 20211231045909-create-post: migrating ========= 20211231045909-create-post: migrated (0.008s) 두개의 마이그레이션 파일이 실행되었고 데이터베이스를 확인해보면 users. posts 테이블이 생성된 것을 확인하면 된다. 도커로 실행중인 mysql을 bash로 접속하여 확인해보자 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# mysql docker connectiondocker exec -it docker-test_mysql_1 bash# mysql connectionroot@4921e7558de3:/# mysql -U test -pEnter password: Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -AWelcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 2Server version: 5.7.36 MySQL Community Server (GPL)Copyright (c) 2000, 2021, Oracle and/or its affiliates.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql&gt; use testDatabase changedmysql&gt; show tables;+----------------+| Tables_in_test |+----------------+| SequelizeMeta || posts || users |+----------------+3 rows in set (0.01 sec)mysql&gt; desc users;+------------+--------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+------------+--------------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || nick_name | varchar(255) | NO | | NULL | || created_at | datetime | NO | | NULL | || updated_at | datetime | NO | | NULL | |+------------+--------------+------+-----+---------+----------------+4 rows in set (0.00 sec)mysql&gt; desc posts;+------------+--------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+------------+--------------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || title | varchar(255) | NO | | NULL | || content | varchar(255) | NO | | NULL | || user_id | int(11) | YES | MUL | NULL | || created_at | datetime | NO | | NULL | || updated_at | datetime | NO | | NULL | |+------------+--------------+------+-----+---------+----------------+6 rows in set (0.00 sec) 테이블 두개가 생성되었고 모델 파일과 마이그레이션에 정의한 컬럼이 모두 생성되고 외래키 지정까지 정상적으로 등록이 되었다. 이렇게 마이그레이션 실행에 대한 정보는 테이블 목록에서 보이는 SequelizeMeta 테이블에 저장되고 관리된다. 123456789# SequelizeMeta table infomysql&gt; select * from SequelizeMeta;+-------------------------------+| name |+-------------------------------+| 20211231045323-create-user.js || 20211231045909-create-post.js |+-------------------------------+2 rows in set (0.00 sec) 실행했던 두개의 마이그레이션 정보가 입력이 되어있으며 실행한 스크립트의 이름을 알 수 있다. 이렇게 마이그레이션을 실행했다면 되돌리기 위한 명령어로는 db:migrate:undo, db:migrate:undo:all이 있고 특정버전 파일을 입력하면 해당 위치까지 롤백이 가능하다. seed migration테이블을 생성했다면 가상의 데이터도 마이그레이션을 통해 삽입이 가능하다. 마이그레이션 파일을 생성하기 위해서 seed:migerate –name #{name} 명령어를 사용하면 된다. 유저 테이블과 게시글 테이블에 하나씩 데이터를 저장해보자. 1sequelize-cli seed:migarate --name insert-data 명령어를 실행하면 seeders 폴더에 seed파일이 생성된다. 1234567891011121314151617181920212223242526272829303132333435// seeders/202112311653-insert-data.jsmodule.exports = { up: async (queryInterface, Sequelize) =&gt; { await queryInterface.bulkInsert('users', [{ nick_name: '한주련', created_at: new Date(), updated_at: new Date(), }], {}); await queryInterface.bulkInsert('posts', [ { title: 'sample title1', content: 'sample content1', user_id: 1, created_at: new Date(), updated_at: new Date(), }, { title: 'sample title2', content: 'sample content2', user_id: 1, created_at: new Date(), updated_at: new Date(), } ]) }, down: async (queryInterface, Sequelize) =&gt; { /** * Add commands to revert seed here. * * Example: * await queryInterface.bulkDelete('People', null, {}); */ }}; 테이블 생성 마이그레이션 파일과 동일한 구조로 생성이 되며 간단하게 유저테이블에 데이터를 넣고 게시글 테이블에도 글 하나를 입력하였다. 해당 마이그레이션을 실행하기 위한 과정은 다음과 같다. 12345678root@0e9dcef32c40:/usr/src/app# sequelize-cli db:seed:all Sequelize CLI [Node: 12.22.8, CLI: 6.3.0, ORM: 6.12.0]Loaded configuration file &quot;config/config.json&quot;.Using environment &quot;development&quot;.== 20211231051943-insert_user_sample: migrating ========= 20211231051943-insert_user_sample: migrated (0.019s) sequelize-cli db:seed:all 명령어를 통해서 데이터를 저장하면 데이터베이스에는 새로운 데이터가 저장 된다. 12345678910111213141516mysql&gt; select * from users;+----+-----------+---------------------+---------------------+| id | nick_name | created_at | updated_at |+----+-----------+---------------------+---------------------+| 1 | 한주련 | 2021-12-31 08:13:09 | 2021-12-31 08:13:09 |+----+-----------+---------------------+---------------------+1 row in set (0.00 sec)mysql&gt; select * from posts;+----+---------------+-----------------+---------+---------------------+---------------------+| id | title | content | user_id | created_at | updated_at |+----+---------------+-----------------+---------+---------------------+---------------------+| 1 | sample title1 | sample content1 | 1 | 2021-12-31 08:13:09 | 2021-12-31 08:13:09 || 2 | sample title2 | sample content2 | 1 | 2021-12-31 08:13:09 | 2021-12-31 08:13:09 |+----+---------------+-----------------+---------+---------------------+---------------------+2 rows in set (0.00 sec) 각각의 데이터가 잘 저장되었다. seed 스크립트는 마이그레이션 파일처럼 따로 기록되고 관리되지 않으므로 여러번 실행하면 실행 횟수 만큼 데이터가 저장되니 유의해야 한다. 마이그레이션을 통한 모델 수정마이그레이션을 통해 테이블을 생성하고 데이터도 넣었으니 모델을 수정하는 방법을 알아보자. 모델 수정 마이그레이션 파일 생성 명령어는 다음과 같다. sequelzie-cli migration:generate –name ${fileName} 명령어를 실행하면 migrations 폴더에 파일이 생성되고 구조는 기존과 동일하게 up down 메서드로 구성되어있다. users 테이블에 email 컬럼을 추가해보자. 123456root@0e9dcef32c40:/usr/src/app# sequelize-cli migration:generate --name add_column_email_to_users Sequelize CLI [Node: 12.22.8, CLI: 6.3.0, ORM: 6.12.0]migrations folder at &quot;/usr/src/app/migrations&quot; already exists.New migration was created at /usr/src/app/migrations/20220101083719-add_column_email_to_users.js . 12345678910111213// migrations/20220101174356-add_column_email_to_users.jsmodule.exports = { up: async (queryInterface, Sequelize) =&gt; { await queryInterface.addColumn('users', 'email', { type: Sequelize.STRING(50), unique: true, }, {}); }, down: async (queryInterface, Sequelize) =&gt; { await queryInterface.removeColumn('users', 'email'); }}; 실행시 일어날 동작과 실패시 일어날 동작으로 구성하여 작성해주었다. 123456789101112131415161718192021222324252627282930# express containerroot@0e9dcef32c40:/usr/src/app# sequelize-cli db:migrateSequelize CLI [Node: 12.22.8, CLI: 6.3.0, ORM: 6.12.0]Loaded configuration file &quot;config/config.json&quot;.Using environment &quot;development&quot;.== 20220101083719-add_column_email_to_users: migrating ========= 20220101083719-add_column_email_to_users: migrated (0.114s)# mysql containermysql&gt; desc users;+------------+--------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+------------+--------------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || nick_name | varchar(255) | NO | | NULL | || created_at | datetime | NO | | NULL | || updated_at | datetime | NO | | NULL | || email | varchar(50) | YES | UNI | NULL | |+------------+--------------+------+-----+---------+----------------+5 rows in set (0.00 sec)mysql&gt; select * from users;+----+-----------+---------------------+---------------------+-------+| id | nick_name | created_at | updated_at | email |+----+-----------+---------------------+---------------------+-------+| 1 | 한주련 | 2021-12-31 08:13:09 | 2021-12-31 08:13:09 | NULL |+----+-----------+---------------------+---------------------+-------+1 row in set (0.00 sec) email 컬럼이 추가되었다. 이런 방식으로 컬럼의 추가 삭제 옵션 변경 등 다양한 작업을 할 수 있다. 시퀄라이즈에서 지원하는 마이그레이션 기능을 사용하여 데이터 베이스를 관리하니 기존 모델의 수정사항이 생길 때마다 데이터베이스를 갈아 엎어버렸던 과정이 상당히 비효율 적이였다고 생각이 되었다. 테이블 날리고 다시 생성하고… 또 데이터 넣어주고.. 이러한 과정을 마이그레이션을 통하면 원할하게 이루어진다는 것을 알게 되었고 마이그레이션 기능을 통해 데이터베이스를 관리하면 안전하고 데이터를 보존할 수 있다는 것을 확실하게 알게되었으며 어떤 과정을 ORM에서 마이그레이션을 지원하는지 학습하게 되어 좋았다. 그리고 대부분의 ORM들이 지원하는 마이그레이션의 기능이 비슷하다는 것을 알게된 시간이기도 했다. 회사에서 루비 온 레일스의 액티브레코드를 사용하며 마이그레이션 기능을 처음 사용해보았고.. 보다 효과적으로 사용하기 위해 공부해야 겠다는 생각이였는데 도커를 공부하면서 하다니.. 겸사겸사 좋은 시간이였다.","link":"/2022/01/01/sequelize/Sequelize-Migration/"},{"title":"웹스톰, 루비마인 단축키 정리(기록중)","text":"웹스톰 루비마인 단축키 정리 (기록)도구창 열기 :⌘0~9 가장자주 쓰게 되는 번호는 프로젝트 폴더 창으로 넘어가는 1번 그리고 커밋 탭인 0번 정도였다. 터미널 열기 : ⎇ F12설정 탭 열기 : ⌘ ,프로젝트 관련 모든 검색 : ⇧⇧파일 내용 검색 : ⌘ ⇧ F최근 파일 조회 : ⌘ E라인 번호로 이동 : ⌘ L열려있는 탭 이동 : ⌘ ⇧ [ , ]커밋 창 열기 : ⌘ K코드 줄 변경 : 이동할 코드 줄에 커서를 두고 ⎇ ⇧ ↑↓라인 전체 복사 : ⌘ D라인 전체 삭제 : ⌘ ⌫단어별 선택 : ⎇ ←→단어별 이동 : ⎇ ⇧ ←→오류 발생 영역으로 이동 : F2오류 해결 방법 제안 : ⎇ ↩︎라인 합치기 : ⌘ ⇧ J현재 파일에서 찾기 : ⌘ F현재 파일에서 변경하기 : ⌘ R코드 라인 정렬 : ⌘ ⎇ L","link":"/2022/01/08/%EC%9D%B8%ED%85%94%EB%A6%AC%EC%A0%9C%EC%9D%B4-%EB%8B%A8%EC%B6%95%ED%82%A4-%EC%A0%95%EB%A6%AC-%EA%B8%B0%EB%A1%9D%EC%A4%91/"},{"title":"Ruby 파일 읽기,쓰기","text":"루비에서 파일 읽기, 쓰기루비에서는 파일 및 디텍토리 입출력을 위하여 File, Dir클래스를 제공하고 있다. ###FileFile 클래스는 다양한 메서드를 통해 파일을 읽고 쓰고 할 수 있으며 다양한 방식으로 활용이 가능하다.회사 프로젝트에서 File 클래스를 주로 사용하게 되었던 부분은 이미지 파일을 읽고 AWS S3에 업로드 할 때 혹은 어드민에서 엑셀 데이터를 활용, 생성하기 위해 주로 사용하였다. File 클래스에 대한 다양한 기능은 문서를 통해 학습하고 필요한 기능을 사용하면 되겠다. File Class Docshttps://ruby-doc.org/core-2.5.0/File.html 포스트에서는 사용했던 메서드와 간단한 사용방법에 대해 기록하고자 한다. 파일 읽기.가장 중요한 읽기이다. 파일을 읽기 위해서는 File.open, File.new 이라는 메서드를 사용한다. 사용방법은 간단하며 다음과 같이 실행한다. 12File.open(filename, option)File.new(filename, option) new 메서드와 open 메서드의 동작 결과는 동일하게 흘러간다. 하지만 open 메서드를 사용하면 코드 블록을 통한 작업이 가능해진다. option 값으로 설정할 수 있는 값은 다음과 같다. 옵션 설명 r 읽기 전용 모드로 파일을 연다. r+ 읽기,쓰기 모드로 파일을 연다. w 쓰기 전용 모드로 파일을 연다. 단 파일이 존재한다면 덮어쓴다. 그리고 파일이 없다면 새로 생성한다. w+ 읽기, 쓰기 모드로 파일을 연다. 단 파일이 존재한다면 덮어쓴다. 그리고 파일이 없다면 새로 생성한다. a 쓰기 전용으로 연다. 파일이 존재한다면 파일의 끝을 가르키며 없으면 생성한다. a+ 읽기 쓰기 모드로 연다. 파일이 존재한다면 끝을 가르키고 없다면 생성한다. 폴더 읽기폴더를 읽기 위해서는 Dir class를 활용한다. 1Dir.new(path) 방식은 파일 클래스와 동일하다. 주로 디렉토리를 읽고 파일을 생성하거나 내부의 파일들을 활용하기 위해 사용되는 것 같다. 디렉토리 내부의 특정 파일을 열기위해 사용하게 되었는데 만약 어떤 경로의 내부에 있는 파일 모두 혹은 특정 파일들만 찾기 위해서는 다음과 같이 사용한다. 12345# 이미지 파일만 가져오도록 한다. 확장자는 png파일만Dir.glob(&quot;./tmp/hexo_blog/*.png&quot;) do |path| File.open(path) ...end cdn 링크를 통한 이미지 파일을 실행하기 위해서 두가지 클래스들을 활용하며 느낀점은 파일 읽고 쓰기 간단하다고 생각했지만 막상 자주 사용하지 않다보니 다소 어려움이 있었다. 가장 어려웠던 cdn 링크 이미지 파일 열기… 고민하고 구글링을 통해 찾아낸 방법…이다. 12345678image_path = &quot;https://ifh.cc/g/jmG8MF.jpg&quot;filename = image_path.split(/[\\/]/)[-1].split('?')[0] # 파일 이름만 잘라낸다. stream = URI.open(image_path) # URI 클래스를 통해 url을 열어준다. 결과값은 strem형식으로 출력이 된다. File.open(&quot;./tmp/#{filename}&quot;, 'w+b') do |file| # 해당 경로에 파일이 당연히 없으니 w+ 옵션으로 생성하게 될것이다. stream.respond_to?(:read) ? IO.copy_stream(stream, file) : file.write(stream) # 스트림형식의 파일을 읽던지 생성하게 끔 하여 파일을 실행한다. img = URI.open(file) ...end 이런 방식으로 이미지를 실행하고 생성하며 업로드 등의 작업을 수행할 수 있다. 연휴 전 마지막 평일이라 그런가… 정리 퀄리티가 평소에도 막장이였는데.. 오늘은 더 심한것 같다.. 그래도 이번주 야근하면서 얻어낸? 결과 중 한가지를 기록하고자 마음먹고 기록을 하게 되었다는 것에 의미를 부여하자…다음 포스트는 루비에서 엑셀 쓰기,읽기 관련하여 기록 예약… 요거 참 골때리고 간단하지만 복잡미묘한 그런 작업…","link":"/2022/01/28/ruby/Ruby-%ED%8C%8C%EC%9D%BC-%EC%9D%BD%EA%B8%B0-%EC%93%B0%EA%B8%B0/"},{"title":"루비 시작하기","text":"자바스크립트 공부를 하며 Node.js 백엔드 개발을 경험해오며 개발자로 성장하기 위해 달려왔다. 면접을 보며 입사하기로 하게 된 기업에서 자바스크립트 스택을 보고 지원했는데 루비 온 레일스를 사용하는 기업이였고 그에 따라 새로운 언어를 배워야 하는 상황이다. 학교에서 자바를 잠깐 배운것 외에는 자바스크립트 외의 언어를 경험해보지 못했는데 새로운 언어와 프레임워크를 경험하게 되어 좋은 경험이 될것 같다는 생각이 든다.😂 📩 Ruby Git Repo 루비는 어떤 언어인가?루비를 공부 해봐야겠다고 생각한 후 루비는 어떤 언어인가를 가장 먼저 알아 보게 되었다. 루비 홈페이지를 찾아보니 루비에 대해 다음과 같이 설명해 주고 있었다. 루비는 순수 객체 지향 언어이다. 루비의 모든 것은 객체로 분류된다. 루비는 유연한 언어이다. 다른 객체 지향 언어와 달리 의도적인 단일 상속만을 제공한다. 대신 모듈 기능을 이용하여 필요한 메서드를 사용할 수 있다. 루비는 모든 것을 객체로 분류한다는 특징이 가장 생소하지만 흥미롭게 다가왔다. 자바스크립트 처럼 원시타입과 참조타입을 분류하지 않고 모든것을 객체로 분류한다는 것이 새로운 언어를 배우기 시작하는 단계에서 흥미를 불러와 주었다. 그렇다면 왜 루비인가왜 루비를 사용하는지 궁금했다. 웹개발이라 하면 자바스크립트, 파이썬, 자바 3가지를 생각하고 루비라는 언어를 들어만 봤지 실질적으로 접하는 기회가 없었기 때문이다.루비를 사용하여 웹 개발을 진행 할 때 루비 온 레일스라는 프레임워크를 사용한다고 한다.루비를 사용하는 가장 보편적인 이유는 쉽고 개발 생산성이 빠르다. 라고 많이 얘기를 하는 것 같다. 아직 루비 기본 문법을 보며 따라하는 단계에서는 느끼지 못했지만Express를 사용하여 개발을 할때의 장점과 비슷한 느낌이지 않을까 넘겨짚어 생각하게 된다. 왜 루비를 사용하는지 회사에 물어보면 그럴듯한 답변이 올지 궁금한데 사실 못 물어 보겠다…. 루비, 루비 온 레일스를 사용하면 다음과 같은 장점이 있다고 한다. 배우기 쉽다 순수 객체 지향언어로 객체에 대한 이해를 한다면 코드가 사람의 언어와 가깝게 설계되어 간단하여 배우기 쉽다는 장점이 있다. MVC 모델이 거의 대부분 구성되어있다. 레일스는 추가적인 작업 없이도 대부분의 MVC모델 구현이 되어있어 편리하다. 확장성, 이식성이 높다. 시스템의 용량을 변경하거나 여러 OS에서 사용하게 되어도 추가 작업없이 사용이 가능하며(물론 Ruby를 지원하는 OS..) 다른언어로 개발된 라이브러리를 루비 위에서 쉽게 구현할 수 있다는 장점이 있다. 그럼 어떤 단점이 있나가장 많이 보이는 단점은 실행속도가 느리다는 것이였다. 따라서 대규모 협업 프로젝트에서는 사용하기 어려운 점이 있다고 한다. 결론?빠른 생산성으로 개발이 가능하지만 대규모 프로젝트에서는 사용하기 어려운 부분이 있다는 것이 전체적인 의견인 것 같다. 정확한 이유는 직접 개발하다보면 느낄 수 있지 않을까 생각중이다. 루비를 설치하고 실행해보자.루비 설치는 루비 홈페이지에서 현재 사용중인 OS에 맞게 설치하면 된다.이후 터미널을 실행하고 루비가 설치 되었는지 간단한 명령어를 실행해서 테스트해보자. Ruby 설치 후 버전 확인 =&gt; ruby -v 언어 공부 할때 가장 먼저 해야하는 “Hello World”출력해보기👀 irb 명령어를 실행해서 루비 환경 실행 후 문자열을 반환해주는 puts 명령어를 실행해서 “Hello World”를 출력하면 된다.실행해보면 nil이 나오는데 nil은 puts에서 항상 반환하는 값이라고 한다. 또한 nil은 null을 의미한다. 이런 사소한 차이가 참 헷갈린다.. 계속해서 루비에대해 학습하며 기본을 익혀보자.. 물론 나는 자바스크립트 공부도 더 해야하는데 왠지 새로운게 끌리는 것 같기도 하고 자바스크립트가 그립기도하고..","link":"/2021/11/23/ruby/%EB%A3%A8%EB%B9%84-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"title":"Ruby 정규표현식","text":"정규표현식그동안 공부를 하면서 서버에서 정규 표현식을 사용하는 일이 얼마나 있을까? 라는 의문과 필요하면 그때그때 찾아보면서 해도 상관없겠다 라는 마음으로 미루고 미룬 것 중 하나가 정규표현식이였다.간단한 코딩 테스트 문제에서도 등장했던 정규표현식인데 항상 마주하면 생각만큼 쉽지 않고 복잡한 정규표현식…왜 정규표현식이 서버 코드에서 사용하는 일이 많지 않을 것이라고 생각했는지 의문이 들 정도로 회사 프로젝트에서 정규표현식의 필요성이 느껴졌다. 가장 많이 사용하는 곳은 Rspec을 활용한 테스트 케이스 코드 그리고 파일을 읽고 쓰는 과정에서 항상 등장하는 정규표현식.. 그래서 기본적인 정규표현식의 형태에 대해 알아보고자 정규표현식을 학습해보고자 한다. 모든 언어에서 정규표현식을 지원하지만 주로 사용하는 언어가 루비와 자바스크립트인 만큼 그리고 회사 백엔드 코드는 루비로 이루어져있기 때문에? 루비 기준으로 루비에서는 어떤 방식으로 정규표현식이 이루어 지는지 알아보았다. 정규표현식이란?정규표현식이란 특정한 규칙을 가진 문자열의 집합을 표현하는 데 사용하는 형식 언어이다. 정규 표현식을 사용해야 하는 이유는 여러가지가 있겠지만 직접 직면한 문제에서 느낀점은 수많은 데이터 혹은 문자들에서 원하는 패턴의 문자열을 매칭하고 치환하는 작업을 할때 정규표현식을 모른다면?일일히 원하는 결과를 위한 메서드를 만들어야 할 것이다. 하지만 정규표현식을 통한 연산을 통해 원하는 값을 얻고 변환하며 결과를 가지고 조건문에서 사용이 가능해진다면하나하나 메서드를 만들 필요도 없고 생산성이 좋아진다. 물론 이런 작업을 위해 그래도 난 메서드를 만들어 보겠다는 사람이 굳이 존재할까 싶지만 정규표현식을 활용하여 많은 작업과 처리가 이루어 질 수 있기 때문에 기본적인 정규표현식에대해 학습해보고자 한다. 루비 정규 표현식패턴으로 문자열 매치하기루비에서는 =~ 기호를 사용하여 지정한 패턴이 문자열에 매칭 되는지 판별한다. 문자열이 패턴에 매치한다면 =~ 연산자는 매치된 위치를 숫자로 리턴한다. 1234567re_1 = /cat/ =~ 'dog and cat're_2 = /cat/ =~ 'catch're_3 = /cat/ =~ 'Cat'pp re_1 # =&gt; 8pp re_2 # =&gt; 0pp re_3 # =&gt; nil 매치 결과가 true일 경우 매치되는 첫번째 인덱스 값을 리턴하며 결과가 false 라면 nil을 반환한다. 결과 반환값이 true || false 이기 때문에 해당 연산을 조건문에서도 사용이 가능하다. 123456789str = 'dog and cat'if /cat/ =~ str pp 'true'else pp 'false'end# =&gt; &quot;true&quot; 일치여부를 확인하는 =~ 연산자의 반대 의미인 !~ 연산자도 존재한다. 반대의 의미를 가지며 일치하지 않는 결과의 값을 반환하게 된다. 12pp /cat/ !~ 'dog and cat' # =&gt; 'false'pp /cat/ !~ 'Cat' # =&gt; 'true' 패턴으로 문자열 치환하기sub메서드는 문자열에서 패턴과 일치하는 문자열을 치환 문자열로 치환해주는 메서드이다. 123str = 'Dog and Cat'new_str = str.sub(/Cat/, 'Rabbit')pp new_str # =&gt; &quot;Dog and Rabbit&quot; sub 메서드는 일치하는 패턴의 첫번째 부분만 치환해주는 메서드로 전역적으로 문자열을 치환하기 위해서는 gsub메서드를 활용하면 된다. 123str_2 = &quot;ababab&quot;new_str_2 = str_2.gsub(/a/, '*')pp new_str_2 # =&gt; &quot;*b*b*b&quot; sub, gsub메서드를 사용할 때 알아두면 좋은 점은 해당 메서드를 사용하여 반환되는 결과값은 기존 문자열 값에 영향을 주지 않고 새로운 문자열을 반환한다는 점이다.기존 문자열을 변환하고 싶다면 메서드 뒤에 !를 사용하여 문자열 값을 직접 바꾸도록 해주면 된다. 또한 !를 사용하여 문자열을 변경하고자 할때는 패턴이 매치 될경우에만 문자열을 치환하며 패턴과 일치 하지 않다면nil을 반환한다. 따라서 !를 사용하여 문자열을 치환하는 것은 조건문에서도 활용이 가능하다는 의미이다. 정규 표현식에 대해 더 알아보기루비란 무엇인가에서 루비의 모든 것은 객체로 활용된다고 했다. 따라서 정규표현식도 루비에서는 객체로 평가가 된다. 정확히는 Regexp의 인스턴스이다. 그러므로 정규표현식을 변수에 대입하거나 메서드 인자로 넘겨줄 수 있다. 1234str = 'Dog and Cat'# 변수에 대입하기pattern = /Cat/pp pattern =~ str # =&gt; 8 정규표현식 생성은 지금까지 생성했던 방식처럼 리터럴을 이용한 생성도 가능하지만 Regexp 클래스의 .new 메서드 또는 %r{…} 문법을 사용하여 생성이 가능하다. %r{…}문법은 “/“를 포함한 정규표현식 생성에 유용하다. 123str = &quot;Dog and Cat&quot;pp Regexp.new(&quot;Dog&quot;) =~ str # =&gt; 0pp %r{Dog} =~ str # =&gt; 0 정규표현식 옵션 옵션 설명 i 대소문자 구분 옵션(대소문자 구별을 하지 않는다.) o 정규표현식내 치환을 위한 평가를 한번만 진행 m 멀티라인 모드 x 확장모드 가독성을 위해 적절한 공백과 주석 활용이 가능하다. 패턴매치정규표현식 객체를 생성하고 나면 **match, =~ !~**등의 연산자를 활용하여 문자열을 평가, 치환, 탐색 할 수 있다. 이때 연산을 위한 피연산자 중 하나는 정규표현식 객체여야 한다. 루비에서 문자열이 표현식에 의해 매치가 되고 나면 특수 변수에 값이 저장되는데 대부분의 루비 프로그래밍에서는 MatchData를 사용하여 값을 활용한다. 12345678910def regexp_test(str, pattern) match = pattern.match(str) if match pp &quot;#{match.pre_match} =&gt; #{match[0]} =&gt; #{match.post_match}&quot; else pp &quot;No match&quot; endendregexp_test('hello my name is han juryeon', /is/) # =&gt; &quot;hello my name =&gt; is =&gt; han juryeon&quot; 복잡한 패턴. | () [] {} + \\ ^ $ * ? 를 제외한 문자들은 자기 자신을 나타내는 문자열에 매치된다. 특수 문자들을 매치하기 위해서는 앞에 역슬래쉬를 넣어주면 된다. 12345require '../Regexp/regexp_4'regexp_test('yes | no', /\\|/) # =&gt; &quot;yes =&gt; | =&gt; no&quot;regexp_test('yes (no)', /\\(no\\)/) # =&gt; &quot;yes =&gt; (no) =&gt; &quot;regexp_test('are you sure?', /e\\?/) # =&gt; &quot;are you sur =&gt; e? =&gt; &quot; 앵커정규표현식은 기본적으로 문자열에서 처음 찾는 부분에 매치가 된다. 만약 문자열의 맨앞과 맨뒤에만 매치가 되도록 하고 싶다면 ^, $ 기호를 사용하면 된다. 1234567891011121314str = &quot;this is\\nthe time&quot;regexp_test(str, /^the/)regexp_test(str, /^this/)regexp_test(str, /$is/)regexp_test(str, /\\Athe/)regexp_test(str, /\\Athis/)=begin&quot;this is\\n&quot; + &quot; =&gt; the =&gt; time&quot;&quot; =&gt; this =&gt; is\\n&quot; + &quot;the time&quot;&quot;No match&quot;&quot;No match&quot;&quot; =&gt; this =&gt; is\\n&quot; + &quot;the time&quot;=end 문자 클래스문자 클래스란 대괄호 안에 있는 문자들의 집합을 의미한다. [aeiou]는 모음의 집합이고 [,:;!?]은 구두점에 매치된다. 이러한 방식을 활용한 정규표현식 표현도 가능해진다. 12345678910str_2 = &quot;Price $12.&quot;regexp_test(str_2, /[aeiou]/)regexp_test(str_2, /[\\s]/)regexp_test(str_2, /[.]/)=begin&quot;Pr =&gt; i =&gt; ce $12.&quot;&quot;Price =&gt; =&gt; $12.&quot;&quot;Price $12 =&gt; . =&gt; &quot;=end 시퀀스 의미 \\d 십진수 \\D 십진수를 제외한 모든 문자열 \\h 십육진수 문자 \\H 십육진수 문자를 제외한 모든 문자 \\R 일반적인 줄바꿈 문자 \\s 공백 \\S 공백을 제회한 문자 \\w 단어 문자 \\W 단어 문자를 제회한 모든 문자 \\X 확장 유니코드 문자소 대괄호 내에서 c1-c2시퀀스를 사용시 두개의 시퀀스를 포함한 사이의 모든 문자와 매치가 된다. 12345678910a = 'see [The PickAxe-page 123]'regexp_test(a, /[A-F]/)regexp_test(a, /[A-Fa-f]/)regexp_test(a, /[0-9]/)=begin&quot;see [The Pick =&gt; A =&gt; xe-page 123]&quot;&quot;s =&gt; e =&gt; e [The PickAxe-page 123]&quot;&quot;see [The PickAxe-page =&gt; 1 =&gt; 23]&quot;=end 선택| 기호는 역슬래쉬와 함께 사용해야 문자로 취급이 된다. 역슬래쉬로 사용하지 않는다면 표현식의 일부로 취급이 된다. 123b = 'red ball blue sky'regexp_test(b, /d|e/) # =&gt; &quot;r =&gt; e =&gt; d ball blue sky&quot;regexp_test(b, /al|lu/) # =&gt; &quot;red b =&gt; al =&gt; l blue sky&quot; 그룹괄호를 사용하여 정규 표현식 내부에서 일부를 그룹으로 묶어줄 수 있다. 1234# 아래의 표현식은 하나의 a 와 하나 혹은 다수의 n에 매치된다.regexp_test('banana', /an+/) # =&gt; &quot;b =&gt; an =&gt; ana&quot;# 아래의 표현식은 하나 혹은 여러개의 an에 매치된다.regexp_test('banana', /(an)+/) # =&gt; &quot;b =&gt; anan =&gt; a&quot; 그룹화 하여 매치된 결과는 다양한 방식으로 활용이 가능하다. 괄호는 매치된 결과를 모아주고 이러한 결과를 다른 정규표현식에서 사용하거나 루비 프로그램 내부에서 사용이 가능하다. 1234567891011121314/(\\d\\d):(\\d\\d)(..)/ =~ &quot;12:50am&quot;pp &quot;Hour is #{$1} Minute is #{$2}&quot;/((\\d\\d):(\\d\\d))(..)/ =~ &quot;12:50am&quot;pp &quot;Time is #{$1}&quot;pp &quot;Hour is #{$2} Minute is #{$3}&quot;pp &quot;AM/PM is #{$4}&quot;=begin&quot;Hour is 12 Minute is 50&quot;&quot;Time is 12:50&quot;&quot;Hour is 12 Minute is 50&quot;&quot;AM/PM is am&quot;=end 동일한 형식으로 match메서드를 활용한다면 매치되는 인덱스값을 이용하면 된다. 또한 매치된 내용을 번호가 아닌 이름으로 참조 할 수 있으며 그룹을 시작하는 괄호에서 ?&lt;..&gt;형식을 사용하면 된다. 12345678910/(?&lt;hour&gt;\\d\\d):(?&lt;minute&gt;\\d\\d)(?&lt;am_or_pm&gt;..)/ =~ &quot;12:50am&quot;pp &quot;Hour is #{hour}&quot;pp &quot;Minute is #{minute}&quot;pp &quot;AM/PM is #{am_or_pm}&quot;=begin&quot;Hour is 12&quot;&quot;Minute is 50&quot;&quot;AM/PM is am&quot;=end","link":"/2022/01/30/ruby/Ruby-%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D/"},{"title":"Ruby 메서드","text":"루비 메서드메서드 정의메서드는 def 키워드로 정의하며 이름의 마지막에는 !, ?, = 를 사용할 수 있다. 각각의 키워드는 다음과 같이 사용된다. True, False를 반환하는 메서드의 경우 ?를 사용하기도 한다. 수신자의 값을 바꿔버리는 메서드의 경우 !를 사용한다. 이러한 메서드는 뱅 메서드라고 불린다. 대입문의 좌측에 올 수 있는 메서드이름 마지막에 = 기호를 사용한다. 가변 인자 리스트개수가 정해지지 않은 가변 매개변수를 전달하거나 하나의 매개변수로 여러개의 매개변수를 처리한다면 메서드 인자의 마지막에 가변매개변수 앞에 *기호를 사용하면 된다. 1234567def method_1(arg_1, *rest) &quot;arg_1 = #{arg_1}, rest = #{rest.inspect}&quot;endpp method_1(&quot;one&quot;) # =&gt; &quot;arg_1 = one, rest = []&quot;pp method_1(&quot;one&quot;, &quot;two&quot;) # =&gt; &quot;arg_1 = one, rest = [\\&quot;two\\&quot;]&quot;pp method_1(&quot;one&quot;, &quot;two&quot;, 1) # =&gt; &quot;arg_1 = one, rest = [\\&quot;two\\&quot;, 1]&quot; 첫 번째 매개변수는 일반적인 매개변수로 지정되고 두 번쨰 매개변수에 *기호가 붙어있기 때문에 남은 매개변수 모두를 Array객체에 저장하여 매개변수에 대입한다. 이러한 가변 매개변수는 메서드에서 직접 사용하지는 않지만 상위 클래스에서 같은 이름을 가지고 있는 메서드를 호출하고자 하는 경우에 사용되기도 한다. 1234567891011121314class Parent def do_something(*) pp &quot;parent class&quot; endendclass Child &lt; Parent def do_something(*) super endenda = Child.newa.do_something # =&gt; &quot;parent class&quot; 메서드와 블록메서드를 호출할때 블록을 결합시켜 호출을 할 수 있다. 이러 방식으로 결합된 메서드는 내부에서 yield를 사용하여 호출이 가능하다. 1234def some(arg_1) yield(arg_1 + 1)endsome(1) { |value| pp &quot;value : #{value}&quot; } # =&gt; 2 이러한 방식으로도 사용이 가능하지만 매개변수 앞에 &amp; 기호를 붙여주면 Proc 객체로 변환되어 이 객체를 마지막 매개변수에 대입하여 사용할 수 있다. 1234def proc(arg_1, &amp;proc) proc.call(arg_1)endproc(1) { |v| pp v * 10 } # =&gt; 10 루비 메서드 결과 반환루비 메서드는 일반적으로 결과를 반환한다. 무조건 반환하는 것은 아니다. 하지만 결과를 반환하는 메서드에서 결과값은 일반적으로 마지막으로 실행된 표현식의 결과값이다.대부분 return 문을 작성하지 않아도 되지만 메서드 실행 중간 빠져나가야 한다면 return 문을 사용하는 경우도 있다. 12345678def re 100.times do |i| value = i * i return i, value if value &gt; 1000 endendv = repp v # =&gt; [32, 1024] 루비에서는 두개 이상의 결과를 return 하게 되면 배열 형태로 결과값을 반환하게 된다. 이런식으로 반환된 Array 값은 병렬 대입문으로 값을 이용 할 수 있다. 123456789def re 100.times do |i| value = i * i return i, value if value &gt; 1000 endendindex, value = repp index # =&gt; 32pp value # =&gt; 1024","link":"/2022/01/30/ruby/Ruby-%EB%A9%94%EC%84%9C%EB%93%9C/"},{"title":"Ruby on Rails Docker Setting (레일스 도커 개발환경 세팅하기)","text":"Ruby on Rails Docker Setting레일스 개발 환경을 도커로 세팅해보자 크게 복잡하고 거창한 환경 세팅은 아니지만 처음 세팅이 항상 골칫거리이다.. 개발 환경ruby-on-rails -v 7.0^ruby -v 2.7.1RubyMineDockerdocker-composepostgres -v 14.2-alpine 1. 기본 세팅을 위한 파일 생성 및 작성123456mkdir backendcd backendtouch Dockerfiletouch docker-compose.ymltouch docker-compoes.env Dockerfile 작성 123456789101112131415161718# syntax=docker/dockerfile:1FROM ruby:2.7.1RUN apt-get update -qq &amp;&amp; apt-get install -y nodejs postgresql-clientWORKDIR /usr/src/appCOPY Gemfile ./COPY Gemfile.lock ./RUN bundle install# Add a script to be executed every time the container starts.COPY entrypoint.sh /usr/bin/RUN chmod +x /usr/bin/entrypoint.shENTRYPOINT [&quot;entrypoint.sh&quot;]EXPOSE 3000# Configure the main process to run when running the imageCMD [&quot;rails&quot;, &quot;server&quot;, &quot;-b&quot;, &quot;0.0.0.0&quot;] docker-compose.yml 작성 12345678910111213141516171819202122232425version: &quot;3&quot;services: ## backend database: image: postgres:14.2-alpine ports: - &quot;5432:5432&quot; env_file: docker-compose.env volumes: - ./psql/data:/var/lib/postgresql/data ## api web: container_name: web build: . command: bash -c &quot;rm -f tmp/pids/server.pid &amp;&amp; bundle exec rails s -p 3000 -b '0.0.0.0'&quot; ports: - &quot;3000:3000&quot; env_file: docker-compose.env volumes: - ./:/usr/src/app depends_on: - &quot;database&quot; environment: - RAILS_ENV=development Gemfile, Gemfile.lock 생성 12touch Gemfiletouch Gemfile.lock 1234# Gemfilesource &quot;https://rubygems.org&quot;ruby &quot;2.7.1&quot; docker-compose.env 12345POSTGRES_USER=userPOSTGRES_PASSWORD=passwordPG_USER=userPG_PASSWORD=password 2. 빌드 시작1docker-compose build 빌드를 시작해도 아직 레일스 세팅이 안되어있다. docker 컨테이너를 이용하여 레일스 설치를 진행한다. 1docker-compose run --no-deps web rails new . --api --force --database=postgresql 실행 시 뭔가 쭉쭉 설치되고 로컬 디렉토리와 컨테이너 볼륨을 지정해줬기 때문에 작업 디렉토리에 레일스 폴더, 파일들이 생성된다. 3. database.yml 작성12345678910111213141516171819# ./config/database.ymldefault: &amp;default adapter: postgresql encoding: utf8 # For details on connection pooling, see Rails configuration guide # https://guides.rubyonrails.org/configuring.html#database-pooling pool: 5 host: database # docker 환경 데이터베이스와 연결을 하기위해서는 컨테이너 이름으로 지정해주어야 한다. username: juren password: jurendevelopment: &lt;&lt;: *default database: juren_developmenttest: &lt;&lt;: *default database: juren_test 4. 데이터베이스 생성하기아직 도커에서 실행중인 postgresql 에는 데이터베이스가 생성되어있지 않다. yml 파일에서 지정한 데이터베이스들을 생성해주기 위해서는 아래 명령어를 실행한다. 12docker-compsoe up # 컨테이너 실행 명령어docker-compose run web rake db:create # rails db 생성 명령어 5. localhost 접속크롬 -&gt; localhost:3000 접속 결과 확인 끝~👍👍은 아니고 이제 시작...","link":"/2022/02/19/ruby/Ruby-on-Rails-Docker-Setting/"},{"title":"Ruby on Rails Grape Gem","text":"루비 온 레일스 Grape Gem 사용하기Grape 젬은 레일스 환경에서 REST 와 유사한 API 프레임워크이다. Grape GitHubGrape Gem GitHub HomePage Install Gem12# Gemfilegem 'grape' Gemfile 에 grape 젬을 추가해준뒤 bundle install 명령어를 실행한다. 설정하기적용하기 위한 프로젝트의 레일스 버전이 7버전으로 grape github README 를 따라 6버전 이상의 세팅 방법을 따라 진행 하였다. path: ./config/initializers/inflections.rb아래의 코드가 이미 작성되어있고 주석처리가 되어있다. 해당부분 주석을 제거하고 작성해주면 된다. 123ActiveSupport::Inflector.inflections(:en) do |inflect| inflect.acronym &quot;DefaultController&quot; # 베이스가 되는 클래스의 이름을 입력하는 부분이다. end 컨트롤러 생성1234cd appmkdir apitouch base_api.rbtouch default_controller.rb path: ./app/api/base_api.rb 12345678class BaseApi &lt; Grape::API # 기타 공용 함수들? helpers do def server_port Rails.env['PORT'] || 3000 end endend path: ./app/api/default_controller.rb 123456789class DefaultController &lt; BaseApi version 'v1', using: :path format :json prefix :api get 'alive' do &quot;rails server run #{server_port} port&quot; endend path: ./config/routes.rb 1234Rails.application.routes.draw do # Define your application routes per the DSL in https://guides.rubyonrails.org/routing.html mount DefaultController =&gt; '/'end curl을 이용하여 요청하기 User Controller 생성하기123# work dir: ./appcd user_controllertouch user_api.rb path: ./app/api/user_controller/user_api.rb 1234567891011121314151617181920212223242526module UserController class UserApi &lt; BaseApi resource 'users' do helpers do def post_params params.as_json(only: %i[email password name nick_name age gender]) end end # GET /api/v1/users/all get 'all' do users = User.all { total: users.count, result: users.map { |r| Entities::UserEntity.represent(r) }, } end # POST /api/v1/users post do user = User.create(post_params) present user, with: Entities::UserEntity end end endend POST /users GET /users/all","link":"/2022/03/06/ruby/Ruby-on-Rails-Grape-Gem/"}],"tags":[{"name":"Ruby","slug":"Ruby","link":"/tags/Ruby/"},{"name":"ec2","slug":"ec2","link":"/tags/ec2/"},{"name":"aws","slug":"aws","link":"/tags/aws/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"CodeDeploy","slug":"CodeDeploy","link":"/tags/CodeDeploy/"},{"name":"Nodejs","slug":"Nodejs","link":"/tags/Nodejs/"},{"name":"Passport","slug":"Passport","link":"/tags/Passport/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"PostgreSQL","slug":"PostgreSQL","link":"/tags/PostgreSQL/"},{"name":"sequelize","slug":"sequelize","link":"/tags/sequelize/"},{"name":"SQLD","slug":"SQLD","link":"/tags/SQLD/"},{"name":"TypeORM","slug":"TypeORM","link":"/tags/TypeORM/"},{"name":"express","slug":"express","link":"/tags/express/"},{"name":"Projects","slug":"Projects","link":"/tags/Projects/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"webstorm","slug":"webstorm","link":"/tags/webstorm/"},{"name":"rubymine","slug":"rubymine","link":"/tags/rubymine/"},{"name":"Regexp","slug":"Regexp","link":"/tags/Regexp/"},{"name":"Ruby on Rails","slug":"Ruby-on-Rails","link":"/tags/Ruby-on-Rails/"}],"categories":[{"name":"Ruby","slug":"Ruby","link":"/categories/Ruby/"},{"name":"aws","slug":"aws","link":"/categories/aws/"},{"name":"ec2","slug":"ec2","link":"/categories/ec2/"},{"name":"Nodejs","slug":"Nodejs","link":"/categories/Nodejs/"},{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"github","slug":"github","link":"/categories/github/"},{"name":"PostgreSQL","slug":"PostgreSQL","link":"/categories/PostgreSQL/"},{"name":"sequelize","slug":"sequelize","link":"/categories/sequelize/"},{"name":"SQLD","slug":"SQLD","link":"/categories/SQLD/"},{"name":"Passport","slug":"Passport","link":"/categories/Passport/"},{"name":"Typeorm","slug":"Typeorm","link":"/categories/Typeorm/"},{"name":"Typerom","slug":"Typerom","link":"/categories/Typerom/"},{"name":"express","slug":"express","link":"/categories/express/"},{"name":"Projects","slug":"Projects","link":"/categories/Projects/"},{"name":"CodeDeploy","slug":"CodeDeploy","link":"/categories/CodeDeploy/"},{"name":"CloneCoding","slug":"Projects/CloneCoding","link":"/categories/Projects/CloneCoding/"},{"name":"AptManagement","slug":"Projects/AptManagement","link":"/categories/Projects/AptManagement/"},{"name":"Docker","slug":"Docker","link":"/categories/Docker/"},{"name":"Ruby on Rails","slug":"Ruby-on-Rails","link":"/categories/Ruby-on-Rails/"},{"name":"docker-compose","slug":"docker-compose","link":"/categories/docker-compose/"}]}