<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Juryeon Blog</title>
    <link>http://hanjuren.github.io/</link>
    
    <atom:link href="http://hanjuren.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Sat, 01 Jan 2022 08:51:42 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Sequelize Migration</title>
      <link>http://hanjuren.github.io/2022/01/01/sequelize/Sequelize-Migration/</link>
      <guid>http://hanjuren.github.io/2022/01/01/sequelize/Sequelize-Migration/</guid>
      <pubDate>Sat, 01 Jan 2022 06:38:15 GMT</pubDate>
      
      <description>&lt;p&gt;도커를 통해 데이터베이스를 띄우고 express를 실행시켜 연결을 해보았다. MySQL과 연결하여 데이터베이스를 사용하기 위해서 Sequelize를 사용하여 연결까지 성공적으로 연결을 진행하였다.&lt;/p&gt;
&lt;p&gt;기존에 시퀄라이즈를 사용할때는 모델을 모두 정의한 후 데이터베이스를 생성하고 모델의 수정사항이 있을때마다 **Sync({ force: false || true })**옵션을 통해 데이터베이스를 수정하며 진행했다. 물론 혼자 사용하는 데이터베이스고 서비스를 하지 않는 디비여서 이런방식으로 사용해도 무방하지만 실무에서 사용하는 데이터베이스는 많은 데이터가 있고 구조의 변경이 일어날때 마다 데이터를 백업한다던지 새로 덤프 한다는 것은 현실적으로 어려움이 있다.&lt;/p&gt;
&lt;p&gt;이러한 문제점을 보완하기 위해 ORM에서는 마이그레이션 기능을 지원한다. 마이그레이션이란 어떤 운영환경에서 다른 환경으로 환경의 변화를 위해 옮겨지는 작업을 의미한다.&lt;/p&gt;
&lt;h3 id=&quot;데이터베이스-마이그레이션이란&quot;&gt;&lt;a href=&quot;#데이터베이스-마이그레이션이란&quot; class=&quot;headerlink&quot; title=&quot;데이터베이스 마이그레이션이란.&quot;&gt;&lt;/a&gt;데이터베이스 마이그레이션이란.&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;데이터베이스 마이그레이션이란 하나의 데이터베이스를 다른 종류의 데이터베이스로 데이터를 옮기는 경우 혹은 두개의 데이터베이스를 하나의 시스템으로 합치거나 분할 혹은 데이터베이스 모델의 구조적 변경을 진행 하는 모든 과정을 의미한다.&lt;br&gt;&lt;a href=&quot;http://wiki.hash.kr/index.php/%EB%A7%88%EC%9D%B4%EA%B7%B8%EB%A0%88%EC%9D%B4%EC%85%98&quot;&gt;데이터 베이스 마이그레이션이란?&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;그렇다면 시퀄라이즈에서 제공하는 Migration 기능에는 어떤 기능이 있을까? 시퀄라이즈에서는 몇가지 명령어를 통해 마이그레이션 기능을 사용할 수 있다고 한다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>도커를 통해 데이터베이스를 띄우고 express를 실행시켜 연결을 해보았다. MySQL과 연결하여 데이터베이스를 사용하기 위해서 Sequelize를 사용하여 연결까지 성공적으로 연결을 진행하였다.</p><p>기존에 시퀄라이즈를 사용할때는 모델을 모두 정의한 후 데이터베이스를 생성하고 모델의 수정사항이 있을때마다 **Sync({ force: false || true })**옵션을 통해 데이터베이스를 수정하며 진행했다. 물론 혼자 사용하는 데이터베이스고 서비스를 하지 않는 디비여서 이런방식으로 사용해도 무방하지만 실무에서 사용하는 데이터베이스는 많은 데이터가 있고 구조의 변경이 일어날때 마다 데이터를 백업한다던지 새로 덤프 한다는 것은 현실적으로 어려움이 있다.</p><p>이러한 문제점을 보완하기 위해 ORM에서는 마이그레이션 기능을 지원한다. 마이그레이션이란 어떤 운영환경에서 다른 환경으로 환경의 변화를 위해 옮겨지는 작업을 의미한다.</p><h3 id="데이터베이스-마이그레이션이란"><a href="#데이터베이스-마이그레이션이란" class="headerlink" title="데이터베이스 마이그레이션이란."></a>데이터베이스 마이그레이션이란.</h3><blockquote><p>데이터베이스 마이그레이션이란 하나의 데이터베이스를 다른 종류의 데이터베이스로 데이터를 옮기는 경우 혹은 두개의 데이터베이스를 하나의 시스템으로 합치거나 분할 혹은 데이터베이스 모델의 구조적 변경을 진행 하는 모든 과정을 의미한다.<br><a href="http://wiki.hash.kr/index.php/%EB%A7%88%EC%9D%B4%EA%B7%B8%EB%A0%88%EC%9D%B4%EC%85%98">데이터 베이스 마이그레이션이란?</a></p></blockquote><p>그렇다면 시퀄라이즈에서 제공하는 Migration 기능에는 어떤 기능이 있을까? 시퀄라이즈에서는 몇가지 명령어를 통해 마이그레이션 기능을 사용할 수 있다고 한다.</p><span id="more"></span><h3 id="Sequelize-Migration"><a href="#Sequelize-Migration" class="headerlink" title="Sequelize Migration"></a>Sequelize Migration</h3><p>시퀄라이즈 마이그레이션 기능을 사용하기 위해서는 먼저 <em>sequelize-cli</em> 패키지를 설치해야한다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g sequelize-cli </span><br></pre></td></tr></table></figure><p>기존에 시퀄라이즈를 연결했으므로 초기 세팅 과정은 넘어가도록 하고 초기 세팅 과정은 공식문서를 통해 확인이 가능하다.</p><ol><li>Create Model<br>마이그레이션을 통해 모델을 생성하는 과정이다. **명령어는 sequelize-cli model:generate –name ${modelName} –attributes ${columnName:type}**을 통해 생성이 가능하다.</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sequelize-cli model:generate --name User --attributes nick_name:string</span><br></pre></td></tr></table></figure><p>명령어를 실행하면 models 디렉토리에 user.js migrations 디렉토리에 시간-create-user.js 형식의 파일이 생성이 된다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// models/user.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; Model &#125; = <span class="built_in">require</span>(<span class="string">&#x27;sequelize&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">sequelize, DataTypes</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Model</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">associate</span>(<span class="params">models</span>)</span> &#123;</span><br><span class="line">      User.hasMany(models.Post, &#123;</span><br><span class="line">        <span class="attr">as</span>: <span class="string">&#x27;posts&#x27;</span>,</span><br><span class="line">        <span class="attr">foreignkey</span>: <span class="string">&#x27;user_id&#x27;</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  User.init(&#123;</span><br><span class="line">    <span class="attr">nick_name</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: DataTypes.STRING,</span><br><span class="line">      <span class="attr">allowNull</span>: <span class="literal">false</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    sequelize,</span><br><span class="line">    <span class="attr">modelName</span>: <span class="string">&#x27;User&#x27;</span>,</span><br><span class="line">    <span class="attr">tableName</span>: <span class="string">&#x27;users&#x27;</span>,</span><br><span class="line">    <span class="attr">underscored</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">charset</span>: <span class="string">&#x27;utf8&#x27;</span>,</span><br><span class="line">    <span class="attr">coolate</span>: <span class="string">&#x27;utf8_general_ci&#x27;</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> User;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>User.init 내부에는 명령어 실행 시 –attributes에 지정했던 컬럼과 타입이 지정되며 추가적으로 컬럼을 생성하려면 파일 내부에서 직접 컬럼을 추가해주면 된다.</p><p>동일한 방식으로 유저 모델과 게시글 모델 마이그레이션 파일을 생성해주면 된다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// models/post.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; Model &#125; = <span class="built_in">require</span>(<span class="string">&#x27;sequelize&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">sequelize, DataTypes</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Post</span> <span class="keyword">extends</span> <span class="title">Model</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">associate</span>(<span class="params">models</span>)</span> &#123;</span><br><span class="line">      Post.belongsTo(models.User, &#123;</span><br><span class="line">        <span class="attr">as</span>: <span class="string">&#x27;user&#x27;</span>,</span><br><span class="line">        <span class="attr">foreignkey</span>: <span class="string">&#x27;user_id&#x27;</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  Post.init(&#123;</span><br><span class="line">    <span class="attr">title</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: DataTypes.STRING,</span><br><span class="line">      <span class="attr">allowNull</span>: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">content</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: DataTypes.STRING,</span><br><span class="line">      <span class="attr">allowNull</span>: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">user_id</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: DataTypes.INTEGER,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    sequelize,</span><br><span class="line">    <span class="attr">modelName</span>: <span class="string">&#x27;Post&#x27;</span>,</span><br><span class="line">    <span class="attr">tableName</span>: <span class="string">&#x27;posts&#x27;</span>,</span><br><span class="line">    <span class="attr">underscored</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">charset</span>: <span class="string">&#x27;utf8&#x27;</span>,</span><br><span class="line">    <span class="attr">coolate</span>: <span class="string">&#x27;utf8_general_ci&#x27;</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> Post;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>두개의 모델 파일이 생성되고 내부에 추가할 컬럼을 입력하며 테이블 생성시 설정할 옵션들을 지정해주면 옵션에 맞게 테이블이 생성이 된다.</p><p>또한 유저와 게시글의 1:N 관계를 지정하기 위해 hasMany, belongsTo 옵션을 통해 관계를 지정해주었다.</p><p>모델 파일이 성공적으로 생성이 되었으니 마이그레이션 스크립트를 확인해보자.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// migrations/20211231045301-create-user.js</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">up</span>: <span class="keyword">async</span> (queryInterface, Sequelize) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> queryInterface.createTable(<span class="string">&#x27;users&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">id</span>: &#123;</span><br><span class="line">        <span class="attr">allowNull</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">autoIncrement</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">primaryKey</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">type</span>: Sequelize.INTEGER</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">nick_name</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: Sequelize.STRING,</span><br><span class="line">        <span class="attr">allowNull</span>: <span class="literal">false</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">created_at</span>: &#123;</span><br><span class="line">        <span class="attr">allowNull</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">type</span>: Sequelize.DATE</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">updated_at</span>: &#123;</span><br><span class="line">        <span class="attr">allowNull</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">type</span>: Sequelize.DATE</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">down</span>: <span class="keyword">async</span> (queryInterface, Sequelize) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> queryInterface.dropTable(<span class="string">&#x27;users&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// migrations/20211231045301-create-post.js</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">up</span>: <span class="keyword">async</span> (queryInterface, Sequelize) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> queryInterface.createTable(<span class="string">&#x27;posts&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">id</span>: &#123;</span><br><span class="line">        <span class="attr">allowNull</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">autoIncrement</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">primaryKey</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">type</span>: Sequelize.INTEGER</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">title</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: Sequelize.STRING,</span><br><span class="line">        <span class="attr">allowNull</span>: <span class="literal">false</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">content</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: Sequelize.STRING,</span><br><span class="line">        <span class="attr">allowNull</span>: <span class="literal">false</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">created_at</span>: &#123;</span><br><span class="line">        <span class="attr">allowNull</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">type</span>: Sequelize.DATE,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">updated_at</span>: &#123;</span><br><span class="line">        <span class="attr">allowNull</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">type</span>: Sequelize.DATE,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">user_id</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: Sequelize.INTEGER,</span><br><span class="line">        <span class="attr">allowNull</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">references</span>: &#123;</span><br><span class="line">          <span class="attr">model</span>: <span class="string">&#x27;users&#x27;</span>,</span><br><span class="line">          <span class="attr">key</span>: <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">down</span>: <span class="keyword">async</span> (queryInterface, Sequelize) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> queryInterface.dropTable(<span class="string">&#x27;posts&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>마이그레이션 파일은 up down 메서드로 구성되며 up은 마이그레이션 실행시 동작하고 down은 실패시 동작할 명령이다. 다양한 옵션과 명령들은 문서를 통해 확인이 가능하다.<br><a href="https://sequelize.org/master/manual/migrations.html">sequelize migrations docs</a></p><p>모델을 생성하기 위해 up 내부에 createTable 메서드를 사용하고 내부에는 모델 파일과 동일하게 컬럼을 입력해야하며 create_at, updated_at 컬럼은 자동으로 생성되는 컬럼이므로 모델 파일에 정의해줄 필요는 없다.</p><p>모델 파일과 마이그레이션 파일을 생성했다면 이제 마이그레이션을 실행해주면 된다.</p><p>실행하기 위한 명령어는 <strong>sequelizee-cli db:migrate</strong> 이며 기본적으로는 env=development 으로 마이그레이션이 실행되니 production환경이나 test환경이라면 env 옵션값을 입력해주면 된다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@0e9dcef32c40:/usr/src/app# sequelize-cli db:migrate         </span><br><span class="line"></span><br><span class="line">Sequelize CLI [Node: 12.22.8, CLI: 6.3.0, ORM: 6.12.0]</span><br><span class="line"></span><br><span class="line">Loaded configuration file &quot;config/config.json&quot;.</span><br><span class="line">Using environment &quot;development&quot;.</span><br><span class="line">== 20211231045323-create-user: migrating =======</span><br><span class="line">== 20211231045323-create-user: migrated (0.024s)</span><br><span class="line"></span><br><span class="line">== 20211231045909-create-post: migrating =======</span><br><span class="line">== 20211231045909-create-post: migrated (0.008s)</span><br></pre></td></tr></table></figure><p>두개의 마이그레이션 파일이 실행되었고 데이터베이스를 확인해보면 users. posts 테이블이 생성된 것을 확인하면 된다. 도커로 실행중인 mysql을 bash로 접속하여 확인해보자</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mysql docker connection</span></span><br><span class="line">docker exec -it docker-test_mysql_1 bash</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mysql connection</span></span><br><span class="line">root@4921e7558de3:/# mysql -U test -p</span><br><span class="line">Enter password: </span><br><span class="line">Reading table information for completion of table and column names</span><br><span class="line">You can turn off this feature to get a quicker startup with -A</span><br><span class="line"></span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 2</span><br><span class="line">Server version: 5.7.36 MySQL Community Server (GPL)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2021, Oracle and/or its affiliates.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type &#x27;help;&#x27; or &#x27;\h&#x27; for help. Type &#x27;\c&#x27; to clear the current input statement.</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> use <span class="built_in">test</span></span></span><br><span class="line">Database changed</span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show tables;</span></span><br><span class="line">+----------------+</span><br><span class="line">| Tables_in_test |</span><br><span class="line">+----------------+</span><br><span class="line">| SequelizeMeta  |</span><br><span class="line">| posts          |</span><br><span class="line">| users          |</span><br><span class="line">+----------------+</span><br><span class="line">3 rows in set (0.01 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> desc users;</span></span><br><span class="line">+------------+--------------+------+-----+---------+----------------+</span><br><span class="line">| Field      | Type         | Null | Key | Default | Extra          |</span><br><span class="line">+------------+--------------+------+-----+---------+----------------+</span><br><span class="line">| id         | int(11)      | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| nick_name  | varchar(255) | NO   |     | NULL    |                |</span><br><span class="line">| created_at | datetime     | NO   |     | NULL    |                |</span><br><span class="line">| updated_at | datetime     | NO   |     | NULL    |                |</span><br><span class="line">+------------+--------------+------+-----+---------+----------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> desc posts;</span></span><br><span class="line">+------------+--------------+------+-----+---------+----------------+</span><br><span class="line">| Field      | Type         | Null | Key | Default | Extra          |</span><br><span class="line">+------------+--------------+------+-----+---------+----------------+</span><br><span class="line">| id         | int(11)      | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| title      | varchar(255) | NO   |     | NULL    |                |</span><br><span class="line">| content    | varchar(255) | NO   |     | NULL    |                |</span><br><span class="line">| user_id    | int(11)      | YES  | MUL | NULL    |                |</span><br><span class="line">| created_at | datetime     | NO   |     | NULL    |                |</span><br><span class="line">| updated_at | datetime     | NO   |     | NULL    |                |</span><br><span class="line">+------------+--------------+------+-----+---------+----------------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>테이블 두개가 생성되었고 모델 파일과 마이그레이션에 정의한 컬럼이 모두 생성되고 외래키 지정까지 정상적으로 등록이 되었다. 이렇게 마이그레이션 실행에 대한 정보는 테이블 목록에서 보이는 SequelizeMeta 테이블에 저장되고 관리된다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> SequelizeMeta table info</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select * from SequelizeMeta;</span></span><br><span class="line">+-------------------------------+</span><br><span class="line">| name                          |</span><br><span class="line">+-------------------------------+</span><br><span class="line">| 20211231045323-create-user.js |</span><br><span class="line">| 20211231045909-create-post.js |</span><br><span class="line">+-------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>실행했던 두개의 마이그레이션 정보가 입력이 되어있으며 실행한 스크립트의 이름을 알 수 있다. 이렇게 마이그레이션을 실행했다면 되돌리기 위한 명령어로는 <strong>db:migrate:undo, db:migrate:undo:all</strong>이 있고 특정버전 파일을 입력하면 해당 위치까지 롤백이 가능하다.</p><h3 id="seed-migration"><a href="#seed-migration" class="headerlink" title="seed migration"></a>seed migration</h3><p>테이블을 생성했다면 가상의 데이터도 마이그레이션을 통해 삽입이 가능하다. 마이그레이션 파일을 생성하기 위해서 <strong>seed:migerate –name #{name}</strong> 명령어를 사용하면 된다.</p><p>유저 테이블과 게시글 테이블에 하나씩 데이터를 저장해보자.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sequelize-cli seed:migarate --name insert-data</span><br></pre></td></tr></table></figure><p>명령어를 실행하면 seeders 폴더에 seed파일이 생성된다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// seeders/202112311653-insert-data.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">up</span>: <span class="keyword">async</span> (queryInterface, Sequelize) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> queryInterface.bulkInsert(<span class="string">&#x27;users&#x27;</span>, [&#123;</span><br><span class="line">      <span class="attr">nick_name</span>: <span class="string">&#x27;한주련&#x27;</span>,</span><br><span class="line">      <span class="attr">created_at</span>: <span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">      <span class="attr">updated_at</span>: <span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">    &#125;], &#123;&#125;);</span><br><span class="line">    <span class="keyword">await</span> queryInterface.bulkInsert(<span class="string">&#x27;posts&#x27;</span>, [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;sample title1&#x27;</span>,</span><br><span class="line">        <span class="attr">content</span>: <span class="string">&#x27;sample content1&#x27;</span>,</span><br><span class="line">        <span class="attr">user_id</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">created_at</span>: <span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">        <span class="attr">updated_at</span>: <span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;sample title2&#x27;</span>,</span><br><span class="line">        <span class="attr">content</span>: <span class="string">&#x27;sample content2&#x27;</span>,</span><br><span class="line">        <span class="attr">user_id</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">created_at</span>: <span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">        <span class="attr">updated_at</span>: <span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">      &#125;</span><br><span class="line">    ])</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">down</span>: <span class="keyword">async</span> (queryInterface, Sequelize) =&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Add commands to revert seed here.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Example:</span></span><br><span class="line"><span class="comment">     * await queryInterface.bulkDelete(&#x27;People&#x27;, null, &#123;&#125;);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>테이블 생성 마이그레이션 파일과 동일한 구조로 생성이 되며 간단하게 유저테이블에 데이터를 넣고 게시글 테이블에도 글 하나를 입력하였다. 해당 마이그레이션을 실행하기 위한 과정은 다음과 같다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@0e9dcef32c40:/usr/src/app# sequelize-cli db:seed:all     </span><br><span class="line"></span><br><span class="line">Sequelize CLI [Node: 12.22.8, CLI: 6.3.0, ORM: 6.12.0]</span><br><span class="line"></span><br><span class="line">Loaded configuration file &quot;config/config.json&quot;.</span><br><span class="line">Using environment &quot;development&quot;.</span><br><span class="line">== 20211231051943-insert_user_sample: migrating =======</span><br><span class="line">== 20211231051943-insert_user_sample: migrated (0.019s)</span><br></pre></td></tr></table></figure><p><strong>sequelize-cli db:seed:all</strong> 명령어를 통해서 데이터를 저장하면 데이터베이스에는 새로운 데이터가 저장 된다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select * from users;</span></span><br><span class="line">+----+-----------+---------------------+---------------------+</span><br><span class="line">| id | nick_name | created_at          | updated_at          |</span><br><span class="line">+----+-----------+---------------------+---------------------+</span><br><span class="line">|  1 | 한주련 | 2021-12-31 08:13:09 | 2021-12-31 08:13:09 |</span><br><span class="line">+----+-----------+---------------------+---------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select * from posts;</span></span><br><span class="line">+----+---------------+-----------------+---------+---------------------+---------------------+</span><br><span class="line">| id | title         | content         | user_id | created_at          | updated_at          |</span><br><span class="line">+----+---------------+-----------------+---------+---------------------+---------------------+</span><br><span class="line">|  1 | sample title1 | sample content1 |       1 | 2021-12-31 08:13:09 | 2021-12-31 08:13:09 |</span><br><span class="line">|  2 | sample title2 | sample content2 |       1 | 2021-12-31 08:13:09 | 2021-12-31 08:13:09 |</span><br><span class="line">+----+---------------+-----------------+---------+---------------------+---------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>각각의 데이터가 잘 저장되었다. seed 스크립트는 마이그레이션 파일처럼 따로 기록되고 관리되지 않으므로 여러번 실행하면 실행 횟수 만큼 데이터가 저장되니 유의해야 한다.</p><h3 id="마이그레이션을-통한-모델-수정"><a href="#마이그레이션을-통한-모델-수정" class="headerlink" title="마이그레이션을 통한 모델 수정"></a>마이그레이션을 통한 모델 수정</h3><p>마이그레이션을 통해 테이블을 생성하고 데이터도 넣었으니 모델을 수정하는 방법을 알아보자. 모델 수정 마이그레이션 파일 생성 명령어는 다음과 같다. <strong>sequelzie-cli migration:generate –name ${fileName}</strong></p><p>명령어를 실행하면 migrations 폴더에 파일이 생성되고 구조는 기존과 동일하게 up down 메서드로 구성되어있다.</p><p>users 테이블에 email 컬럼을 추가해보자.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@0e9dcef32c40:/usr/src/app# sequelize-cli migration:generate --name add_column_email_to_users </span><br><span class="line"></span><br><span class="line">Sequelize CLI [Node: 12.22.8, CLI: 6.3.0, ORM: 6.12.0]</span><br><span class="line"></span><br><span class="line">migrations folder at &quot;/usr/src/app/migrations&quot; already exists.</span><br><span class="line">New migration was created at /usr/src/app/migrations/20220101083719-add_column_email_to_users.js .</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// migrations/20220101174356-add_column_email_to_users.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">up</span>: <span class="keyword">async</span> (queryInterface, Sequelize) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> queryInterface.addColumn(<span class="string">&#x27;users&#x27;</span>, <span class="string">&#x27;email&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">type</span>: Sequelize.STRING(<span class="number">50</span>),</span><br><span class="line">      <span class="attr">unique</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;, &#123;&#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">down</span>: <span class="keyword">async</span> (queryInterface, Sequelize) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> queryInterface.removeColumn(<span class="string">&#x27;users&#x27;</span>, <span class="string">&#x27;email&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>실행시 일어날 동작과 실패시 일어날 동작으로 구성하여 작성해주었다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> express container</span></span><br><span class="line">root@0e9dcef32c40:/usr/src/app# sequelize-cli db:migrate</span><br><span class="line"></span><br><span class="line">Sequelize CLI [Node: 12.22.8, CLI: 6.3.0, ORM: 6.12.0]</span><br><span class="line"></span><br><span class="line">Loaded configuration file &quot;config/config.json&quot;.</span><br><span class="line">Using environment &quot;development&quot;.</span><br><span class="line">== 20220101083719-add_column_email_to_users: migrating =======</span><br><span class="line">== 20220101083719-add_column_email_to_users: migrated (0.114s)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mysql container</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> desc users;</span></span><br><span class="line">+------------+--------------+------+-----+---------+----------------+</span><br><span class="line">| Field      | Type         | Null | Key | Default | Extra          |</span><br><span class="line">+------------+--------------+------+-----+---------+----------------+</span><br><span class="line">| id         | int(11)      | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| nick_name  | varchar(255) | NO   |     | NULL    |                |</span><br><span class="line">| created_at | datetime     | NO   |     | NULL    |                |</span><br><span class="line">| updated_at | datetime     | NO   |     | NULL    |                |</span><br><span class="line">| email      | varchar(50)  | YES  | UNI | NULL    |                |</span><br><span class="line">+------------+--------------+------+-----+---------+----------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select * from users;</span></span><br><span class="line">+----+-----------+---------------------+---------------------+-------+</span><br><span class="line">| id | nick_name | created_at          | updated_at          | email |</span><br><span class="line">+----+-----------+---------------------+---------------------+-------+</span><br><span class="line">|  1 | 한주련 | 2021-12-31 08:13:09 | 2021-12-31 08:13:09 | NULL  |</span><br><span class="line">+----+-----------+---------------------+---------------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>email 컬럼이 추가되었다. 이런 방식으로 컬럼의 추가 삭제 옵션 변경 등 다양한 작업을 할 수 있다.</p><hr><p>시퀄라이즈에서 지원하는 마이그레이션 기능을 사용하여 데이터 베이스를 관리하니 기존 모델의 수정사항이 생길 때마다 데이터베이스를 갈아 엎어버렸던 과정이 상당히 비효율 적이였다고 생각이 되었다. 테이블 날리고 다시 생성하고… 또 데이터 넣어주고.. 이러한 과정을 마이그레이션을 통하면 원할하게 이루어진다는 것을 알게 되었고 마이그레이션 기능을 통해 데이터베이스를 관리하면 안전하고 데이터를 보존할 수 있다는 것을 확실하게 알게되었으며 어떤 과정을 ORM에서 마이그레이션을 지원하는지 학습하게 되어 좋았다.</p><p>그리고 대부분의 ORM들이 지원하는 마이그레이션의 기능이 비슷하다는 것을 알게된 시간이기도 했다. 회사에서 루비 온 레일스의 액티브레코드를 사용하며 마이그레이션 기능을 처음 사용해보았고.. 보다 효과적으로 사용하기 위해 공부해야 겠다는 생각이였는데 도커를 공부하면서 하다니.. 겸사겸사 좋은 시간이였다.</p>]]></content:encoded>
      
      
      <category domain="http://hanjuren.github.io/categories/Nodejs/">Nodejs</category>
      
      <category domain="http://hanjuren.github.io/categories/sequelize/">sequelize</category>
      
      <category domain="http://hanjuren.github.io/categories/Docker/">Docker</category>
      
      
      <category domain="http://hanjuren.github.io/tags/Nodejs/">Nodejs</category>
      
      <category domain="http://hanjuren.github.io/tags/sequelize/">sequelize</category>
      
      <category domain="http://hanjuren.github.io/tags/Docker/">Docker</category>
      
      
      <comments>http://hanjuren.github.io/2022/01/01/sequelize/Sequelize-Migration/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Doker Mysql(sequelize)</title>
      <link>http://hanjuren.github.io/2021/12/30/docker/Doker-Mysql-sequelize/</link>
      <guid>http://hanjuren.github.io/2021/12/30/docker/Doker-Mysql-sequelize/</guid>
      <pubDate>Thu, 30 Dec 2021 08:56:46 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;Docker-MySQL-Express-연결하기&quot;&gt;&lt;a href=&quot;#Docker-MySQL-Express-연결하기&quot; class=&quot;headerlink&quot; title=&quot;Docker MySQL Express 연결하기&quot;&gt;&lt;/a&gt;Docker MySQL Express 연결하기&lt;/h2&gt;&lt;p&gt;이전 도커로 express앱을 띄운 후 연결 확인 후 데이터 베이스를 도커로 실행 한 후 express와 연결하는 테스트를 진행해보도록 하자.&lt;/p&gt;
&lt;p&gt;먼저 docker-compose.yml에 mysql이미지를 추가해준다.&lt;/p&gt;
&lt;figure class=&quot;highlight yml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;mysql:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;image:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;mysql:5.7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;command:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;string&quot;&gt;--default-authentication-plugin=mysql_native_password&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;string&quot;&gt;--character-set-server=utf8mb4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;string&quot;&gt;--collation-server=utf8mb4_unicode_ci&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;restart:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;always&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;environment:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;attr&quot;&gt;MYSQL_DATABASE:&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;# Database Name&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;attr&quot;&gt;MYSQL_USER:&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;# User name&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;attr&quot;&gt;MYSQL_PASSWORD:&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;# Password&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;attr&quot;&gt;MYSQL_ROOT_PASSWORD:&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;# Root Password&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;ports:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;bullet&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;3306:3306&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;volumes:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;bullet&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;./data:/var/lib/mysql&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;bullet&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;./mysql.conf:/etc/mysql/conf.d&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;docker-compose up&lt;/strong&gt; 명령 실행 후 mysql이 실행중인 것을 확인하고 docker exec -it #{name} bash 를 통해 mysql로 접근이 가능하다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="Docker-MySQL-Express-연결하기"><a href="#Docker-MySQL-Express-연결하기" class="headerlink" title="Docker MySQL Express 연결하기"></a>Docker MySQL Express 연결하기</h2><p>이전 도커로 express앱을 띄운 후 연결 확인 후 데이터 베이스를 도커로 실행 한 후 express와 연결하는 테스트를 진행해보도록 하자.</p><p>먼저 docker-compose.yml에 mysql이미지를 추가해준다.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">      <span class="string">--default-authentication-plugin=mysql_native_password</span></span><br><span class="line">      <span class="string">--character-set-server=utf8mb4</span></span><br><span class="line">      <span class="string">--collation-server=utf8mb4_unicode_ci</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="comment"># Database Name</span></span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="comment"># User name</span></span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="comment"># Password</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="comment"># Root Password</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data:/var/lib/mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./mysql.conf:/etc/mysql/conf.d</span></span><br></pre></td></tr></table></figure><p><strong>docker-compose up</strong> 명령 실행 후 mysql이 실행중인 것을 확인하고 docker exec -it #{name} bash 를 통해 mysql로 접근이 가능하다.</p><span id="more"></span><h2 id="express-sequelize-세팅"><a href="#express-sequelize-세팅" class="headerlink" title="express sequelize 세팅"></a>express sequelize 세팅</h2><blockquote><p>npm install sequelize mysql2 sequelize-cli</p></blockquote><blockquote><p>npx sequelize-cli init &lt;- 시퀄라이즈 초기 설정</p></blockquote><h3 id="config-수정"><a href="#config-수정" class="headerlink" title="config 수정"></a>config 수정</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;development&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;test&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;password&quot;</span>: <span class="string">&quot;1210ss&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;database&quot;</span>: <span class="string">&quot;test&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;host&quot;</span>: <span class="string">&quot;mysql&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;dialect&quot;</span>: <span class="string">&quot;mysql&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;test&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;root&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;password&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">&quot;database&quot;</span>: <span class="string">&quot;database_test&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;host&quot;</span>: <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;dialect&quot;</span>: <span class="string">&quot;mysql&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;production&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;root&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;password&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">&quot;database&quot;</span>: <span class="string">&quot;database_production&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;host&quot;</span>: <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;dialect&quot;</span>: <span class="string">&quot;mysql&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>데이터 베이스를 환경에 맞게 연결할 수 있는 옵션이 있다. 간단하게 dev 환경 세팅만 진행 후 연결을 해보도록 한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">sequelize.sync(&#123; <span class="attr">force</span>: <span class="literal">false</span> &#125;) <span class="comment">// force: false 실행시마다 테이블을 새로 재생성할건가에 대한 옵션 true or false</span></span><br><span class="line">  .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;데이터베이스 연결 성공!&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>다시 docker의 express를 실행해주면 데이터 베이스 연결이 완료된다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> ✘ hanjuryeon  ~/docker-test   main ±  docker-compose up docker-test</span><br><span class="line">Starting docker-node-app ... done</span><br><span class="line">Attaching to docker-node-app</span><br><span class="line">docker-node-app | [nodemon] 2.0.15</span><br><span class="line">docker-node-app | [nodemon] to restart at any time, enter `rs`</span><br><span class="line">docker-node-app | [nodemon] watching path(s): *.*</span><br><span class="line">docker-node-app | [nodemon] watching extensions: js,mjs,json</span><br><span class="line">docker-node-app | [nodemon] starting `node app.js`</span><br><span class="line">docker-node-app | express app start</span><br><span class="line">docker-node-app | Executing (default): SELECT 1+1 AS result</span><br><span class="line">docker-node-app | 데이터베이스 연결 성공!</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://hanjuren.github.io/categories/Nodejs/">Nodejs</category>
      
      <category domain="http://hanjuren.github.io/categories/Docker/">Docker</category>
      
      
      <category domain="http://hanjuren.github.io/tags/Nodejs/">Nodejs</category>
      
      <category domain="http://hanjuren.github.io/tags/Docker/">Docker</category>
      
      
      <comments>http://hanjuren.github.io/2021/12/30/docker/Doker-Mysql-sequelize/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Docker Node.js nodemon</title>
      <link>http://hanjuren.github.io/2021/12/19/docker/Docker-Node-js-nodemon/</link>
      <guid>http://hanjuren.github.io/2021/12/19/docker/Docker-Node-js-nodemon/</guid>
      <pubDate>Sun, 19 Dec 2021 08:03:31 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;도커를 활용하여 Express를 구동하기 위해 이전 포스팅을 통해 기본적인 앱을 띄워 보았다. 도커를 통해 express를 실행하였지만 코드의 수정이 있을 때 마다 빌드를 다시 해주어야 하는 문제점이 있었다.&lt;br&gt;node.js에서는 nodemo</description>
        
      
      
      
      <content:encoded><![CDATA[<p>도커를 활용하여 Express를 구동하기 위해 이전 포스팅을 통해 기본적인 앱을 띄워 보았다. 도커를 통해 express를 실행하였지만 코드의 수정이 있을 때 마다 빌드를 다시 해주어야 하는 문제점이 있었다.<br>node.js에서는 nodemon이라는 모듈을 사용하여 개발환경에서 코드의 변경사항이 감지되었을때 자동으로 코드의 반영사항을 포함하기 위해 서버를 재시동 해주며 개발을 진행한다.  </p><p>도커를 통해 띄운 express를 로컬에서 작업 후 변경사항을 반영해주기 위해서는 도커의 작업 디렉토리와 로컬 작업 디렉토리를 볼륨 연결 설정을 통해 연결해주고 nodemon으로 express를 구동해주면 된다.</p><ol><li>docker-compose.yml<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">      <span class="string">--default-authentication-plugin=mysql_native_password</span></span><br><span class="line">      <span class="string">--character-set-server=utf8mb4</span></span><br><span class="line">      <span class="string">--collation-server=utf8mb4_unicode_ci</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">test</span></span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">test</span></span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="string">1210ss</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">1210ss</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data:/var/lib/mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./mysql.conf:/etc/mysql/conf.d</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">docker-test:</span></span><br><span class="line">    <span class="attr">build:</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">      <span class="attr">args:</span></span><br><span class="line">        <span class="attr">PORT:</span> <span class="string">&quot;4000&quot;</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker-node-app</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">docker-node-app</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">.:/usr/src/app</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/src/app/node_modules</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;1210:4000&quot;</span></span><br></pre></td></tr></table></figure>docker-compose.yml 파일을 통해 여러 컨테이너를 한번에 관리해주는 방식으로 하나의 서비스를 위해 실행하거나 존재해야하는 이미지들을 한 파일을 통해 정의하는 방식이다.</li></ol><p>mysql은 이 후 사용할 예정이므로 넘어가도록 하고 volumes옵션이 중요한 부분이다.</p><p>volumes은 다음과 같이 작성해 주면된다. &lt;로컬 작업 디렉토리&gt;:&lt;도커 컨테이너 디렉토리&gt; 이것은 로컬 디렉토리와 도커의 디렉토리를 연결하겠다는 의미로 코드의 변경이나 생성 삭제와 같은 작업의 결과를 공유해준다.</p><p>이 후 nodemon을 통해 express 를 실행하고 로컬에서 작업 후 변경사항이 생기게 되면 도커에서 실행중인 express가 재시동 되며 수정 사항을 반영하게 된다.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ARG</span> PORT</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir -p /usr/src/app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /usr/src/app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># . 은 현재 디렉토리의 모든것을 /usr/src/app으로 복사한다는 의미다.</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /usr/src/app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm install</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm install -g nodemon</span></span><br><span class="line"><span class="comment"># Bundle app source</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> $PORT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 도커에서 nodemon을 실행하기 위해 필요한 옵션</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;nodemon&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;app.js&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>컨테이너를 다시 빌드 후 접속하고 코드를 수정하면 변경사항이 자동으로 반영되는 모습을 확인 할 수 있다.</p>]]></content:encoded>
      
      
      <category domain="http://hanjuren.github.io/categories/Nodejs/">Nodejs</category>
      
      <category domain="http://hanjuren.github.io/categories/Docker/">Docker</category>
      
      
      <category domain="http://hanjuren.github.io/tags/Nodejs/">Nodejs</category>
      
      <category domain="http://hanjuren.github.io/tags/Docker/">Docker</category>
      
      
      <comments>http://hanjuren.github.io/2021/12/19/docker/Docker-Node-js-nodemon/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Docker 개발환경 세팅하기</title>
      <link>http://hanjuren.github.io/2021/12/05/docker/Docker-%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD-%EC%84%B8%ED%8C%85%ED%95%98%EA%B8%B0/</link>
      <guid>http://hanjuren.github.io/2021/12/05/docker/Docker-%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD-%EC%84%B8%ED%8C%85%ED%95%98%EA%B8%B0/</guid>
      <pubDate>Sun, 05 Dec 2021 07:04:53 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;Docker-개발-환경-구축&quot;&gt;&lt;a href=&quot;#Docker-개발-환경-구축&quot; class=&quot;headerlink&quot; title=&quot;Docker 개발 환경 구축&quot;&gt;&lt;/a&gt;Docker 개발 환경 구축&lt;/h2&gt;&lt;p&gt;회사에서 처음 클론 받은 레포지토리의 개발 환경 구축을 위해 도커환경을 구축하며 사용하던 명령어들과 도커를 이용하여 프로젝트 환경을 세팅하는 기본적인 것들에 대해서 기록하고자 글을 남깁니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ifh.cc/g/J2xbO0.png,&quot; title=&quot;도커 로고&quot;&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="Docker-개발-환경-구축"><a href="#Docker-개발-환경-구축" class="headerlink" title="Docker 개발 환경 구축"></a>Docker 개발 환경 구축</h2><p>회사에서 처음 클론 받은 레포지토리의 개발 환경 구축을 위해 도커환경을 구축하며 사용하던 명령어들과 도커를 이용하여 프로젝트 환경을 세팅하는 기본적인 것들에 대해서 기록하고자 글을 남깁니다.</p><p><img src="https://ifh.cc/g/J2xbO0.png," title="도커 로고"></p><span id="more"></span><h3 id="도커란"><a href="#도커란" class="headerlink" title="도커란.."></a>도커란..</h3><p>도커는 <strong>컨테이너 기반으로 작동하는 오픈소스 가상화 플랫폼</strong>이다.</p><p>도커에서 말하는 컨테이너란 다향한 프로그램과 실행환경을 컨테이너 단위로 추상화하여 동일한 인터페이스를 제공하고 프로그램의 배포 및 관리를 단순하게 작업할 수 있도록 도와준다.<br>백엔드 서버 프로그램이나 데이터 조회를 위한 데이터베이스 서버 등 서비스 운영에 필요한 모든 것을 컨테이너로 추상화하여 사용이 가능하다.</p><p>도커를 운용하며 가장 중요한것 중 하나인 <strong>컨테이너</strong>는 독자적으로 격리된 공간에서 프로세스가 동작하는 방식으로 작동한다. 기존 가상화 서비스는 주로 OS를 가상화하여 사용했는데<br>흔히 VMware, VitrualBox같은 가상머신을 활용하여 사용자 OS위에 새로운 OS를 씌워 사용하는 방식인데 이는 매우 무거울 뿐만아니라 느리다는 단점이 존재한다.<br>도커는 이러한 단점에서 자유로우며 편리함을 제공한다.</p><p><strong>이미지</strong><br>컨테이너 실행에 필요한 설정값 등을 포함하고 있는 것이며 도커에서 제공하며 본인이 원하는 버전의 서비스 이미지를 사용한다면 상태값이 변하는 일이 없다.  </p><h3 id="사용법"><a href="#사용법" class="headerlink" title="사용법."></a>사용법.</h3><p>기본적인 이론시간은 거두절미하고 (사실 이론은 알면 좋지만? 몰라도 된다고 생각함.. 어치피 쓰다보면 아니까?) 그냥 바로 하나 만들어보자.</p><p>계획은 이렇다 Node.js기반으로 그냥 비어있는 express앱에서 간단한 crud가 가능한 정도의 express앱을 만들자. 회사에서 만들어져있는 도커 파일을 보면서<br>처음보고 이게 뭔가… 싶었지만 조금 노가다하고 하나하나 공부하는 맛이 있었다. 서비스를 위한 프로젝트는 아니니 간단하게 사용해보려 한다.</p><ol><li>Dockerfile 생성.<br>먼저 간단하게 도커파일을 생성 후 express앱을 띄워보는 테스트를 진행하자. 데이터베이스 연결은 나중에 작업하는걸로 하고 진행해보도록 하자.</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 어떤 환경에서 실행 할지 명시한다. 수많은 버전이 있다.</span><br><span class="line">FROM node:12</span><br><span class="line"></span><br><span class="line">WORKDIR /usr/app/src</span><br><span class="line"></span><br><span class="line"># . 은 현재 디렉토리의 모든것을 /usr/src/app으로 복사한다는 의미다.</span><br><span class="line">COPY . /usr/app/src</span><br><span class="line"></span><br><span class="line">RUN npm install</span><br><span class="line"></span><br><span class="line">EXPOSE 3000</span><br><span class="line"></span><br><span class="line">CMD npm start</span><br></pre></td></tr></table></figure><ol start="2"><li>app.js<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.send(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(port, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`http://localhost:<span class="subst">$&#123;port&#125;</span> ::: express app start`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;docker-node-app-test&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;app.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;node app.js&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;hanjuren&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;license&quot;</span>: <span class="string">&quot;MIT&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;axios&quot;</span>: <span class="string">&quot;^0.24.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;express&quot;</span>: <span class="string">&quot;^4.17.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;xlsx&quot;</span>: <span class="string">&quot;^0.17.4&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런식으로 파일을 간단하게 생성해준 후 먼저 도커 이미지를 만들어준다.</p><blockquote><p>docker build –tag=docker-node-app-test</p></blockquote><p>build명령어를 통해 이미지를 생성해주고 이미지가 생성되었는지 확인해본다.</p><blockquote><p>docker images</p></blockquote><p>해당 명령어는 도커로 사용중인 이미지 목록들을 보여주며 <strong>tag</strong>에 적었던 이름으로 이미지가 생성되면 정상적으로 생성이 된것이다.</p><p><img src="https://ifh.cc/g/q2SVOx.png," title="도커이미지 목록"></br><br>이미지 생성이 완료되었고 해당 이미지를 실행하면 express가 실행되며 접속이 가능하다. 실행하기 위한 명령어는 다음과 같다.</p><blockquote><p>docker run –name=test -p 4444:3000 docker-node-app-test</p></blockquote><p><strong>name</strong>옵션에 실행할 컨테이너의 이름을 지정해주고 <strong>-p</strong>옵션은 로컬 PC에서 4444 포트로 접속시 도커에서 실행중인 3333포트로 매핑하겠다는 옵션이다. 그리고 싷행하고자 하는 이미지 이름을 나열하여 명령어를 입력하면 실행이 된다.</p><p><img src="https://ifh.cc/g/mDcDCX.png," title="도커 실행 후 앱 작동화면"></br></p><p>정상적으로 3000포트에서 실행중인 express에 접근하여 작동하는 것이 확인되었다.  </p><p>다음은 데이터베이스 이미지와 함께 실행하며 express에서 mysql을 같이 사용하며 CRUD작업을 진행해보자.</p>]]></content:encoded>
      
      
      <category domain="http://hanjuren.github.io/categories/Nodejs/">Nodejs</category>
      
      <category domain="http://hanjuren.github.io/categories/Docker/">Docker</category>
      
      
      <category domain="http://hanjuren.github.io/tags/Nodejs/">Nodejs</category>
      
      <category domain="http://hanjuren.github.io/tags/Docker/">Docker</category>
      
      
      <comments>http://hanjuren.github.io/2021/12/05/docker/Docker-%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD-%EC%84%B8%ED%8C%85%ED%95%98%EA%B8%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>루비 시작하기</title>
      <link>http://hanjuren.github.io/2021/11/23/%EB%A3%A8%EB%B9%84-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/</link>
      <guid>http://hanjuren.github.io/2021/11/23/%EB%A3%A8%EB%B9%84-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/</guid>
      <pubDate>Tue, 23 Nov 2021 06:07:54 GMT</pubDate>
      
      <description>&lt;p&gt;자바스크립트 공부를 하며 Node.js 백엔드 개발을 경험해오며 개발자로 성장하기 위해 달려왔다. 면접을 보며 입사하기로 하게 된 기업에서 자바스크립트 스택을 보고 지원했는데 루비 온 레일스를 사용하는 기업이였고 그에 따라 새로운 언어를 배워야 하는 상황이다. 학교에서 자바를 잠깐 배운것 외에는 자바스크립트 외의 언어를 경험해보지 못했는데 새로운 언어와 프레임워크를 경험하게 되어 좋은 경험이 될것 같다는 생각이 든다.😂&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/hanjuren/RubyGuide&quot;&gt;📩 Ruby Git Repo&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://ifh.cc/g/jmG8MF.jpg&quot;&gt;&lt;/p&gt;

&lt;h2 id=&quot;루비는-어떤-언어인가&quot;&gt;&lt;a href=&quot;#루비는-어떤-언어인가&quot; class=&quot;headerlink&quot; title=&quot;루비는 어떤 언어인가?&quot;&gt;&lt;/a&gt;루비는 어떤 언어인가?&lt;/h2&gt;&lt;p&gt;루비를 공부 해봐야겠다고 생각한 후 루비는 어떤 언어인가를 가장 먼저 알아 보게 되었다. 루비 홈페이지를 찾아보니 루비에 대해 다음과 같이 설명해 주고 있었다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;루비는 순수 객체 지향 언어이다.&lt;/li&gt;
&lt;li&gt;루비의 모든 것은 객체로 분류된다.&lt;/li&gt;
&lt;li&gt;루비는 유연한 언어이다.&lt;/li&gt;
&lt;li&gt;다른 객체 지향 언어와 달리 의도적인 단일 상속만을 제공한다. 대신 모듈 기능을 이용하여 필요한 메서드를 사용할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;루비는 모든 것을 객체로 분류한다는 특징이 가장 생소하지만 흥미롭게 다가왔다. 자바스크립트 처럼 원시타입과 참조타입을 분류하지 않고 모든것을 객체로 분류한다는 것이 새로운 언어를 배우기 시작하는 단계에서 흥미를 불러와 주었다.&lt;/p&gt;
&lt;h2 id=&quot;그렇다면-왜-루비인가&quot;&gt;&lt;a href=&quot;#그렇다면-왜-루비인가&quot; class=&quot;headerlink&quot; title=&quot;그렇다면 왜 루비인가&quot;&gt;&lt;/a&gt;그렇다면 왜 루비인가&lt;/h2&gt;&lt;p&gt;왜 루비를 사용하는지 궁금했다. 웹개발이라 하면 자바스크립트, 파이썬, 자바 3가지를 생각하고 루비라는 언어를 들어만 봤지 실질적으로 접하는 기회가 없었기 때문이다.&lt;br&gt;루비를 사용하여 웹 개발을 진행 할 때 루비 온 레일스라는 프레임워크를 사용한다고 한다.&lt;br&gt;루비를 사용하는 가장 보편적인 이유는 쉽고 개발 생산성이 빠르다. 라고 많이 얘기를 하는 것 같다. 아직 루비 기본 문법을 보며 따라하는 단계에서는 느끼지 못했지만&lt;br&gt;Express를 사용하여 개발을 할때의 장점과 비슷한 느낌이지 않을까 넘겨짚어 생각하게 된다. 왜 루비를 사용하는지 회사에 물어보면 그럴듯한 답변이 올지 궁금한데 사실 못 물어 보겠다….&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>자바스크립트 공부를 하며 Node.js 백엔드 개발을 경험해오며 개발자로 성장하기 위해 달려왔다. 면접을 보며 입사하기로 하게 된 기업에서 자바스크립트 스택을 보고 지원했는데 루비 온 레일스를 사용하는 기업이였고 그에 따라 새로운 언어를 배워야 하는 상황이다. 학교에서 자바를 잠깐 배운것 외에는 자바스크립트 외의 언어를 경험해보지 못했는데 새로운 언어와 프레임워크를 경험하게 되어 좋은 경험이 될것 같다는 생각이 든다.😂</p><p><a href="https://github.com/hanjuren/RubyGuide">📩 Ruby Git Repo</a></p><p align="center"><img src="https://ifh.cc/g/jmG8MF.jpg"></p><h2 id="루비는-어떤-언어인가"><a href="#루비는-어떤-언어인가" class="headerlink" title="루비는 어떤 언어인가?"></a>루비는 어떤 언어인가?</h2><p>루비를 공부 해봐야겠다고 생각한 후 루비는 어떤 언어인가를 가장 먼저 알아 보게 되었다. 루비 홈페이지를 찾아보니 루비에 대해 다음과 같이 설명해 주고 있었다.</p><ol><li>루비는 순수 객체 지향 언어이다.</li><li>루비의 모든 것은 객체로 분류된다.</li><li>루비는 유연한 언어이다.</li><li>다른 객체 지향 언어와 달리 의도적인 단일 상속만을 제공한다. 대신 모듈 기능을 이용하여 필요한 메서드를 사용할 수 있다.</li></ol><p>루비는 모든 것을 객체로 분류한다는 특징이 가장 생소하지만 흥미롭게 다가왔다. 자바스크립트 처럼 원시타입과 참조타입을 분류하지 않고 모든것을 객체로 분류한다는 것이 새로운 언어를 배우기 시작하는 단계에서 흥미를 불러와 주었다.</p><h2 id="그렇다면-왜-루비인가"><a href="#그렇다면-왜-루비인가" class="headerlink" title="그렇다면 왜 루비인가"></a>그렇다면 왜 루비인가</h2><p>왜 루비를 사용하는지 궁금했다. 웹개발이라 하면 자바스크립트, 파이썬, 자바 3가지를 생각하고 루비라는 언어를 들어만 봤지 실질적으로 접하는 기회가 없었기 때문이다.<br>루비를 사용하여 웹 개발을 진행 할 때 루비 온 레일스라는 프레임워크를 사용한다고 한다.<br>루비를 사용하는 가장 보편적인 이유는 쉽고 개발 생산성이 빠르다. 라고 많이 얘기를 하는 것 같다. 아직 루비 기본 문법을 보며 따라하는 단계에서는 느끼지 못했지만<br>Express를 사용하여 개발을 할때의 장점과 비슷한 느낌이지 않을까 넘겨짚어 생각하게 된다. 왜 루비를 사용하는지 회사에 물어보면 그럴듯한 답변이 올지 궁금한데 사실 못 물어 보겠다….</p><span id="more"></span><p><strong>루비, 루비 온 레일스</strong>를 사용하면 다음과 같은 장점이 있다고 한다.</p><ol><li>배우기 쉽다<blockquote><p>순수 객체 지향언어로 객체에 대한 이해를 한다면 코드가 사람의 언어와 가깝게 설계되어 간단하여 배우기 쉽다는 장점이 있다.</p></blockquote></li><li>MVC 모델이 거의 대부분 구성되어있다.<blockquote><p>레일스는 추가적인 작업 없이도 대부분의 MVC모델 구현이 되어있어 편리하다.</p></blockquote></li><li>확장성, 이식성이 높다.<blockquote><p>시스템의 용량을 변경하거나 여러 OS에서 사용하게 되어도 추가 작업없이 사용이 가능하며(물론 Ruby를 지원하는 OS..) 다른언어로 개발된 라이브러리를 루비 위에서 쉽게 구현할 수 있다는 장점이 있다.</p></blockquote></li></ol><h2 id="그럼-어떤-단점이-있나"><a href="#그럼-어떤-단점이-있나" class="headerlink" title="그럼 어떤 단점이 있나"></a>그럼 어떤 단점이 있나</h2><p>가장 많이 보이는 단점은 실행속도가 느리다는 것이였다. 따라서 대규모 협업 프로젝트에서는 사용하기 어려운 점이 있다고 한다.</p><h2 id="결론"><a href="#결론" class="headerlink" title="결론?"></a>결론?</h2><p>빠른 생산성으로 개발이 가능하지만 대규모 프로젝트에서는 사용하기 어려운 부분이 있다는 것이 전체적인 의견인 것 같다. 정확한 이유는 직접 개발하다보면 느낄 수 있지 않을까 생각중이다.</p><h2 id="루비를-설치하고-실행해보자"><a href="#루비를-설치하고-실행해보자" class="headerlink" title="루비를 설치하고 실행해보자."></a>루비를 설치하고 실행해보자.</h2><p>루비 설치는 루비 홈페이지에서 현재 사용중인 OS에 맞게 설치하면 된다.<br>이후 터미널을 실행하고 루비가 설치 되었는지 간단한 명령어를 실행해서 테스트해보자.</p><ol><li><p>Ruby 설치 후 버전 확인 =&gt; <em>ruby -v</em><br><img src="https://ifh.cc/g/35SIrZ.png," title="루비 설치 버전 확인하기"></br></p></li><li><p>언어 공부 할때 가장 먼저 해야하는 “Hello World”출력해보기👀</p></li></ol><p><em>irb</em> 명령어를 실행해서 루비 환경 실행 후 문자열을 반환해주는 <em>puts</em> 명령어를 실행해서 “Hello World”를 출력하면 된다.<br><img src="https://ifh.cc/g/kCRKV2.png," title="hello world"></br><br>실행해보면 <em>nil</em>이 나오는데 <em>nil</em>은 <em>puts</em>에서 항상 반환하는 값이라고 한다. 또한 <em>nil</em>은 <em>null</em>을 의미한다. 이런 사소한 차이가 참 헷갈린다.. </p><p>계속해서 루비에대해 학습하며 기본을 익혀보자.. 물론 나는 자바스크립트 공부도 더 해야하는데 왠지 새로운게 끌리는 것 같기도 하고 자바스크립트가 그립기도하고..</p>]]></content:encoded>
      
      
      <category domain="http://hanjuren.github.io/categories/Ruby/">Ruby</category>
      
      
      <category domain="http://hanjuren.github.io/tags/Ruby/">Ruby</category>
      
      
      <comments>http://hanjuren.github.io/2021/11/23/%EB%A3%A8%EB%B9%84-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>javascript-생성자 함수를 사용하여 객체 생성하기</title>
      <link>http://hanjuren.github.io/2021/11/06/js/javascript-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%EA%B0%9D%EC%B2%B4-%EC%83%9D/</link>
      <guid>http://hanjuren.github.io/2021/11/06/js/javascript-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%EA%B0%9D%EC%B2%B4-%EC%83%9D/</guid>
      <pubDate>Sat, 06 Nov 2021 05:54:33 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;생성자-함수에-대한-객체-생성&quot;&gt;&lt;a href=&quot;#생성자-함수에-대한-객체-생성&quot; class=&quot;headerlink&quot; title=&quot;생성자 함수에 대한 객체 생성&quot;&gt;&lt;/a&gt;생성자 함수에 대한 객체 생성&lt;/h2&gt;&lt;p&gt;생성자 함수를 사용하여 객체를 생성 방식에는 Object 생성자 함수를 사용하는 방법이 있다.&lt;/p&gt;
&lt;h3 id=&quot;Object-생성자-함수를-사용하는-방법&quot;&gt;&lt;a href=&quot;#Object-생성자-함수를-사용하는-방법&quot; class=&quot;headerlink&quot; title=&quot;Object 생성자 함수를 사용하는 방법&quot;&gt;&lt;/a&gt;Object 생성자 함수를 사용하는 방법&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;new 연산자와 함께 Object 생성자 함수를 호출하여 빈 객체를 생성한다.&lt;br&gt;이때 객체를 생성하고 프로퍼티나 메서드를 추가하여 객체를 완성시키면 된다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; person = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// new Object 함수를 호출하면 빈객체가 생성된다.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(person); &lt;span class=&quot;comment&quot;&gt;// &amp;#123;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 빈객체에 프로퍼티를 추가한다.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;person.name = &lt;span class=&quot;string&quot;&gt;&amp;#x27;hanjuren&amp;#x27;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;person.getName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;`Hello My Name is &lt;span class=&quot;subst&quot;&gt;$&amp;#123;&lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;.name&amp;#125;&lt;/span&gt;`&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(person); &lt;span class=&quot;comment&quot;&gt;// &amp;#123; name: &amp;#x27;hanjuren&amp;#x27;, getName: f &amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(person.getName()); &lt;span class=&quot;comment&quot;&gt;// Hello My Name is hanjuren&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;생성자 함수에 의해 생성된 객체를 인스턴스라고 부른다.&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;생성자 함수의 종류는 다음과 같다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;String&lt;/li&gt;
&lt;li&gt;Number&lt;/li&gt;
&lt;li&gt;Boolean&lt;/li&gt;
&lt;li&gt;Function&lt;/li&gt;
&lt;li&gt;Array&lt;/li&gt;
&lt;li&gt;Date&lt;/li&gt;
&lt;li&gt;RegExp&lt;/li&gt;
&lt;li&gt;Promise&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;생성자 함수를 호출하여 객체를 생성하는 것은 객체 리터럴을 사용하여 생성하는 것보다는 비효율적이므로 필요한 상황이 아니라면 바람직 한 생성방식은 아니다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="생성자-함수에-대한-객체-생성"><a href="#생성자-함수에-대한-객체-생성" class="headerlink" title="생성자 함수에 대한 객체 생성"></a>생성자 함수에 대한 객체 생성</h2><p>생성자 함수를 사용하여 객체를 생성 방식에는 Object 생성자 함수를 사용하는 방법이 있다.</p><h3 id="Object-생성자-함수를-사용하는-방법"><a href="#Object-생성자-함수를-사용하는-방법" class="headerlink" title="Object 생성자 함수를 사용하는 방법"></a>Object 생성자 함수를 사용하는 방법</h3><blockquote><p>new 연산자와 함께 Object 생성자 함수를 호출하여 빈 객체를 생성한다.<br>이때 객체를 생성하고 프로퍼티나 메서드를 추가하여 객체를 완성시키면 된다.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// new Object 함수를 호출하면 빈객체가 생성된다.</span></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 빈객체에 프로퍼티를 추가한다.</span></span><br><span class="line">person.name = <span class="string">&#x27;hanjuren&#x27;</span>;</span><br><span class="line">person.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Hello My Name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123; name: &#x27;hanjuren&#x27;, getName: f &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(person.getName()); <span class="comment">// Hello My Name is hanjuren</span></span><br></pre></td></tr></table></figure><p><strong>생성자 함수에 의해 생성된 객체를 인스턴스라고 부른다.</strong>  </p><p>생성자 함수의 종류는 다음과 같다.</p><ol><li>String</li><li>Number</li><li>Boolean</li><li>Function</li><li>Array</li><li>Date</li><li>RegExp</li><li>Promise</li></ol><p>생성자 함수를 호출하여 객체를 생성하는 것은 객체 리터럴을 사용하여 생성하는 것보다는 비효율적이므로 필요한 상황이 아니라면 바람직 한 생성방식은 아니다.</p><span id="more"></span><hr><h3 id="생성자-함수"><a href="#생성자-함수" class="headerlink" title="생성자 함수"></a>생성자 함수</h3><p>생성자 함수를 사용한 객체 생성 방식의 장점</p><ol><li>동일한 구조를 가진 객체를 여러개 생성할떄 효율 적이다.</li></ol><p>예를 들어 원의 반지름을 가진 객체를 두개 이상 생성해야 할 때 원하는 만큼 객체 리터럴을 사용하여 하나하나 생성을 해주어야 한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> circle1 = &#123;</span><br><span class="line">  <span class="attr">radius</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="function"><span class="title">getDiameter</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">this</span>.radius;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> circle2 = &#123;</span><br><span class="line">  <span class="attr">radius</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="function"><span class="title">getDiameter</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">this</span>.radius;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>두 객체의 반지름은 5와 10으로 각각 다른 값을 가지지만 지름을 반환하는 메서드는 동일한 내용을 포함한다.<br>동일한 메서드나 구조를 가진 객체를 다수 생성할 때 생성자 함수를 통해 객체를 생성하는 것은 효율적인 방식으로 작동하게 된다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 동일한 구조를 가진 객체를 생성자 함수로 여러개 생성하기</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.radius = radius;</span><br><span class="line">  <span class="built_in">this</span>.getDiameter = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">this</span>.radius;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> circle1 = <span class="keyword">new</span> Circle(<span class="number">5</span>); <span class="comment">// 반지름이 5인 객체를 생성</span></span><br><span class="line"><span class="keyword">const</span> circle2 = <span class="keyword">new</span> Circle(<span class="number">10</span>); <span class="comment">// 반지름이 10인 객체를 생성</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(circle1); <span class="comment">// Circle &#123; radius: 5, getDiameter: [Function (anonymous)] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(circle2); <span class="comment">// Circle &#123; radius: 10, getDiameter: [Function (anonymous)] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(circle1.getDiameter()); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(circle2.getDiameter()); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><hr><h3 id="내부-메서드-Call-Construct"><a href="#내부-메서드-Call-Construct" class="headerlink" title="내부 메서드 [[Call]], [[Construct]]"></a>내부 메서드 [[Call]], [[Construct]]</h3><p>함수 객체는 일반 객체가 가지고 있는 내부슬롯, 내부 메서드를 모두 가지고 있기 때문에 일반 객체와 동일하게 작동이 가능하다.<br>하지만 객체는 호출이 불가능 하고 함수는 호출이 가능하다. 그 이유는 함수는 함수로서 동작하기 위한 내부 슬롯과 내부 메서드를 가지고 있기 때문이다.</p><p>함수가 동작하기 위한 내부슬롯</p><ol><li>[[Environment]]</li><li>[[FormalParameters]] …</li></ol><p>내부 메서드</p><ol><li>[[Call]]</li><li>[[Construct]]</li></ol><p>함수가 호출되어 동작하기 위해 [[Call]] 내부 메서드를 가진 함수를 <strong>callable</strong>이라 부르며 [[Construct]] 내부 메서드를 가진 함수를 <strong>constructor</strong> 없는 함수를 <strong>non-constructor</strong>이라고 부른다.</p><blockquote><p>constructor 함수 : 생성자 함수로서 호출이 가능한 함수<br>non-constructor 함수 : 생성자 함수로서 호출이 불가능한 함수</p></blockquote><p>constructor와 non-constructor을 구분하는 방식은 자바스크립트 엔진이 함수 정의를 평가하여 구분지어준다.</p><ul><li>constructor : 함수 선언문, 함수 표현식, 클래스</li><li>non-constructor : 화살표 함수, 메서드(Es6 메서드 축약 표현)</li></ul><blockquote><p>constructor</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> joo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> boo = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> foo());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> joo());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> boo.x());</span><br></pre></td></tr></table></figure><blockquote><p>non-constructor</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> aoo = <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> noo = &#123;</span><br><span class="line">  <span class="function"><span class="title">x</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> aoo()); <span class="comment">// Type Error</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> noo.x()); <span class="comment">// Type Error</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://hanjuren.github.io/categories/javascript/">javascript</category>
      
      
      <category domain="http://hanjuren.github.io/tags/javascript/">javascript</category>
      
      
      <comments>http://hanjuren.github.io/2021/11/06/js/javascript-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%EA%B0%9D%EC%B2%B4-%EC%83%9D/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>아파트 온도, 습도, 전력 실시간 데이터 관리 프로젝트 마무리하며.</title>
      <link>http://hanjuren.github.io/2021/11/02/project/apt/%EC%95%84%ED%8C%8C%ED%8A%B8-%EC%98%A8%EB%8F%84-%EC%8A%B5%EB%8F%84-%EC%A0%84%EB%A0%A5-%EC%8B%A4%EC%8B%9C%EA%B0%84-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B4%80%EB%A6%AC-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EB%A7%88%EB%AC%B4%EB%A6%AC%ED%95%98%EB%A9%B0/</link>
      <guid>http://hanjuren.github.io/2021/11/02/project/apt/%EC%95%84%ED%8C%8C%ED%8A%B8-%EC%98%A8%EB%8F%84-%EC%8A%B5%EB%8F%84-%EC%A0%84%EB%A0%A5-%EC%8B%A4%EC%8B%9C%EA%B0%84-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B4%80%EB%A6%AC-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EB%A7%88%EB%AC%B4%EB%A6%AC%ED%95%98%EB%A9%B0/</guid>
      <pubDate>Tue, 02 Nov 2021 06:14:59 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;아파트-실시간-데이터-관리-프로젝트를-마무리하며-느꼈던점&quot;&gt;&lt;a href=&quot;#아파트-실시간-데이터-관리-프로젝트를-마무리하며-느꼈던점&quot; class=&quot;headerlink&quot; title=&quot;아파트 실시간 데이터 관리 프로젝트를 마무리하며 느꼈던</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="아파트-실시간-데이터-관리-프로젝트를-마무리하며-느꼈던점"><a href="#아파트-실시간-데이터-관리-프로젝트를-마무리하며-느꼈던점" class="headerlink" title="아파트 실시간 데이터 관리 프로젝트를 마무리하며 느꼈던점"></a>아파트 실시간 데이터 관리 프로젝트를 마무리하며 느꼈던점</h3><p>Node.js를 기반으로한 협업을 통해? 사실 현업에 계신 분 2명과 취준생 2명이 모인 스터디라 현업 개발자 분들 께서 많은 정보와 팁을 알려주신 재능기부 현장느낌이였다. 하지마 어디서도 들을 수 없는… 그런 정보들을 얻는 기회였다고 생각한다. 물론 프로젝트를 그분들께 의존하지는 않았다. 기본적인 세팅과 아이디어를 제공해주시고 거의 2명이 만든 그런 느낌이였다.  </p><p>Mqtt라는 통신기법에 대해 처음 알게되었고 어떤 기능을 위해 여러가지 고려하여 다양한 선택을 하는 생각의 폭을 넓힐 수 있는 좋은 경험으로 생각된다. 무턱대고 기능을 위해 내가 아는 것만 활용하여 물론 아는것이 많지도 않다. 하지만 틀에 갖혀서 개발하는 것보다 기능을 위해 많은 것을 생각하고 고려하면 또다른 방향으로도 더 좋은 결과를 낳을 수 있다는 것을 느끼는 프로젝트 였다.  </p><p>또한 과연 내가 백엔드 개발자를 꿈꾸지만 그에 맞는 준비를 하고 있었는가 그냥 무턱대고 코드만 치며 내것이 되었다라고 생각하던 것은 아니였을까 라는 의문을 나에게 던지는 값진 시간이 되었다.  </p><p>좋은 결과물을 위해서는 많은 공부와 시간을 투자할 준비가 되어있어야 한다. 새로운 것에 대한 도전 그리고 알아가기 위해 노력하는 자세 또 그것을 내 것으로 만들 준비 이러한 덕목이 앞으로 개발자가 되기 위해 내가 준비하는 과정에서 가장 중요하지 않을까 라는 생각이 들었던 프로젝트였다. </p><p>지난 프로젝트들을 정리하며 그때 내가 생각했던것을 정리하고 다시 생각을 해보며 그때 생각한 것을 나는 지키고 있는가. 모든 다짐을 지키지는 못했지만 이때 다짐했던 하나의 결과를 위해 고민을 수없이 하고 의문을 가지고 기능 구현에 안주하지 않는 자세를 지금까지 갖고 있었구나 라는 생각을 하게 된다. 어쩌면 프로젝트를 진행하는 과정에서 사용하는 기술, 언어, 모듈에 대한 이해도 모두 중요하지만 이러한 과정에서 나를 발전시킨 것이 아니였을까. 또 아직 더 발전해야 하는 나의 모습을 더욱 앞으로 나아가게 하는 과정이라고 생각된다.</p>]]></content:encoded>
      
      
      <category domain="http://hanjuren.github.io/categories/Projects/">Projects</category>
      
      <category domain="http://hanjuren.github.io/categories/Projects/AptManagement/">AptManagement</category>
      
      
      <category domain="http://hanjuren.github.io/tags/express/">express</category>
      
      <category domain="http://hanjuren.github.io/tags/Projects/">Projects</category>
      
      <category domain="http://hanjuren.github.io/tags/Node-js/">Node.js</category>
      
      
      <comments>http://hanjuren.github.io/2021/11/02/project/apt/%EC%95%84%ED%8C%8C%ED%8A%B8-%EC%98%A8%EB%8F%84-%EC%8A%B5%EB%8F%84-%EC%A0%84%EB%A0%A5-%EC%8B%A4%EC%8B%9C%EA%B0%84-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B4%80%EB%A6%AC-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EB%A7%88%EB%AC%B4%EB%A6%AC%ED%95%98%EB%A9%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>아파트 온도, 습도, 전력 실시간 데이터 관리 프로젝트 Part 2.</title>
      <link>http://hanjuren.github.io/2021/11/02/project/apt/%EC%95%84%ED%8C%8C%ED%8A%B8-%EC%98%A8%EB%8F%84-%EC%8A%B5%EB%8F%84-%EC%A0%84%EB%A0%A5-%EC%8B%A4%EC%8B%9C%EA%B0%84-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B4%80%EB%A6%AC-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-Part-2/</link>
      <guid>http://hanjuren.github.io/2021/11/02/project/apt/%EC%95%84%ED%8C%8C%ED%8A%B8-%EC%98%A8%EB%8F%84-%EC%8A%B5%EB%8F%84-%EC%A0%84%EB%A0%A5-%EC%8B%A4%EC%8B%9C%EA%B0%84-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B4%80%EB%A6%AC-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-Part-2/</guid>
      <pubDate>Tue, 02 Nov 2021 05:52:13 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;스케줄러를-통한-이메일-보내기-기능-구현&quot;&gt;&lt;a href=&quot;#스케줄러를-통한-이메일-보내기-기능-구현&quot; class=&quot;headerlink&quot; title=&quot;스케줄러를 통한 이메일 보내기 기능 구현&quot;&gt;&lt;/a&gt;스케줄러를 통한 이메일 보내기 기능 </description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="스케줄러를-통한-이메일-보내기-기능-구현"><a href="#스케줄러를-통한-이메일-보내기-기능-구현" class="headerlink" title="스케줄러를 통한 이메일 보내기 기능 구현"></a>스케줄러를 통한 이메일 보내기 기능 구현</h3><p>사용자의 실시간 데이터를 서버로 전송받고 데이터베이스에 저장하여 쌓인 데이터를 연산하여 사용자에게 특정한 일자에 보내도록 하는 기능을 제공하기로 했다.</p><p>가장 먼저 생각한 방식이자 이상적인 방법이였던 카카오톡으로 전송하기는 토이 프로젝트이기에 사업자 번호 등 카카오에서 요구하는 조건에 부딧혀 포기하고 구글 이메일 보내기로 방향을 틀게 되었다.</p><p>구상하는 방식은 이렇다.</p><ol><li>매월 1일 자정에 모든 동 호수의 데이터를 그래프로 그린다.</li><li>각 호수별 사용자이자 입주민이라는 가정하에 그래프 이미지를 이메일로 매월 1일 00시 15분에 발송한다.</li></ol><h3 id="스케줄러-활용"><a href="#스케줄러-활용" class="headerlink" title="스케줄러 활용"></a>스케줄러 활용</h3><p>우리는 <em>node-schedule</em>모듈을 활용하여 스케줄러를 작성하여 메일을 발송하기로 했다.</p><ol><li>그래프 이미지 그리기</li></ol><ul><li>모든 집의 데이터를 각각 그래프로 그려 이미지로 파일로 저장</li></ul><details markdown="1"><summary>그래프 그리기</summary><!--summary 아래 빈칸 공백 두고 내용을 적는공간--><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> get_month = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">return</span> today.getMonth() + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 아파트 단지, 동, 호 일별 데이터 가져오기</span></span><br><span class="line"><span class="keyword">const</span> sensorData = <span class="keyword">async</span> (Complex, Dong, Ho) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> exData = <span class="keyword">await</span> apt_Info.sensorFind(Complex, Dong, Ho);</span><br><span class="line">    <span class="keyword">return</span> exData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 아파트의 모든 단지 동 호 정보 가져오기</span></span><br><span class="line"><span class="keyword">const</span> basename = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> aptInfo = <span class="keyword">await</span> apt_Info.aptFind();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; aptInfo.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 파일 이름 지정  =&gt; ex) 단지 동 호.png</span></span><br><span class="line">        <span class="keyword">let</span> fileName = <span class="string">`<span class="subst">$&#123;aptInfo[i].AptDong.apt_complex&#125;</span><span class="subst">$&#123;aptInfo[i].AptDong.apt_dong&#125;</span><span class="subst">$&#123;aptInfo[i].apt_ho&#125;</span>`</span>; </span><br><span class="line">        <span class="comment">// 단지, 동, 호의 센서 데이터 받아오기.</span></span><br><span class="line">        <span class="keyword">let</span> data = <span class="keyword">await</span> sensorData(aptInfo[i].AptDong.apt_complex, aptInfo[i].AptDong.apt_dong, aptInfo[i].apt_ho);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 차트를 그리기위한 날짜, 데이터 별 배열 분리</span></span><br><span class="line">        <span class="keyword">let</span> dateArray = []; </span><br><span class="line">        <span class="keyword">let</span> humiArray = [];</span><br><span class="line">        <span class="keyword">let</span> tempArray = [];</span><br><span class="line">        <span class="keyword">let</span> wattArray = [];</span><br><span class="line">        data.map(<span class="function">(<span class="params">sensor</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> newDate = <span class="keyword">new</span> <span class="built_in">Date</span>(sensor.dataValues.date);</span><br><span class="line">            dateArray.push(dateAndTime.format(newDate, <span class="string">&#x27;MM-DD&#x27;</span>));</span><br><span class="line">            tempArray.push(sensor.dataValues.humidityAVG);</span><br><span class="line">            humiArray.push(sensor.dataValues.temperatureAVG);</span><br><span class="line">            wattArray.push(sensor.dataValues.electricitySUM);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 차트 그리기 함수로 파일 이름과 데이터 배열 전달</span></span><br><span class="line">        humiChart(fileName, humiArray, dateArray);</span><br><span class="line">        tempChart(fileName, tempArray, dateArray);</span><br><span class="line">        wattChart(fileName, wattArray, dateArray);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;차트 그리기 시작&quot;</span>);</span><br><span class="line">    logger.info(<span class="string">&#x27;create chart&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 아파트 모든 세대의 전력 차트 그리기</span></span><br><span class="line"><span class="keyword">const</span> wattChart = <span class="function">(<span class="params">fileName, data, date</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> filewatt = fileName + <span class="string">&quot;watt.png&quot;</span>;</span><br><span class="line">    saveChart(filewatt, <span class="string">&quot;Watt&quot;</span>, data, date);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 아파트 모든 세대 온도 차트 그리기</span></span><br><span class="line"><span class="keyword">const</span> tempChart = <span class="function">(<span class="params">fileName, data, date</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> filetemp = fileName + <span class="string">&quot;temp.png&quot;</span>;</span><br><span class="line">    saveChart(filetemp, <span class="string">&quot;Temp&quot;</span>, data, date);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 아파트 모든 세대 습도 차트 그리기</span></span><br><span class="line"><span class="keyword">const</span> humiChart = <span class="function">(<span class="params">fileName, data, date</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> filehumi = fileName + <span class="string">&quot;humi.png&quot;</span>;</span><br><span class="line">    saveChart(filehumi, <span class="string">&quot;Humi&quot;</span>, data, date);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//차트그리기 스케줄러</span></span><br><span class="line"><span class="keyword">const</span> drawChart = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 매달 자정에 파일 생성</span></span><br><span class="line">    <span class="keyword">const</span> jobs = schedule.scheduleJob(<span class="string">&#x27;0 0 01 * *&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        basename();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>이미지 그리기 코드</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ChartJsImage = <span class="built_in">require</span>(<span class="string">&#x27;chartjs-to-image&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> chart = <span class="keyword">new</span> ChartJsImage();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> days = <span class="function"><span class="keyword">function</span>(<span class="params">month,year</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(year, month, <span class="number">0</span>).getDate();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> get_Month = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> today.getMonth() + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> makeFolder = <span class="function">(<span class="params">dir</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!fs.existsSync(dir)) &#123;</span><br><span class="line">fs.mkdirSync(dir)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line"><span class="built_in">console</span>.error(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> saveChart = <span class="keyword">async</span> (filename, type, data, date) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 차트 label 지정</span></span><br><span class="line"><span class="keyword">const</span> labels = date;</span><br><span class="line">    <span class="comment">// 차트 그리기</span></span><br><span class="line">chart.setConfig(&#123;</span><br><span class="line"><span class="attr">type</span>: <span class="string">&#x27;line&#x27;</span>,</span><br><span class="line"><span class="attr">data</span>: &#123; <span class="attr">labels</span>: labels, <span class="attr">datasets</span>: [&#123; <span class="attr">label</span>: type, data &#125;] &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 월별 / 데이터별 파일 구분하기</span></span><br><span class="line"><span class="keyword">const</span> folderName = <span class="string">&#x27;./data/&#x27;</span> + (get_Month() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">const</span> monthPath = folderName + <span class="string">&#x27;/&#x27;</span> + type;</span><br><span class="line"><span class="comment">// Write file to disk</span></span><br><span class="line">makeFolder(folderName);</span><br><span class="line">    makeFolder(monthPath);</span><br><span class="line"><span class="keyword">await</span> chart.toFile(monthPath + <span class="string">&quot;/&quot;</span> +  filename);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = saveChart;</span><br></pre></td></tr></table></figure><p>각각의 파일은 월별 / 데이터 종류로 구분되어 저장되고 저장된 이미지를 사용자에게 전송한다.</p></details><ol start="2"><li>이메일 보내기</li></ol><details markdown="1"><summary>이메일 보내기</summary><!--summary 아래 빈칸 공백 두고 내용을 적는공간--><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 이메일 보내기 스케줄러 시간 지정 </span></span><br><span class="line"><span class="keyword">const</span> mailResult = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> userinfo = <span class="keyword">await</span> User.findAll(&#123;</span><br><span class="line">        <span class="attr">attributes</span>: [<span class="string">&#x27;uemail&#x27;</span>, <span class="string">&#x27;apt_ho&#x27;</span>],</span><br><span class="line">        <span class="attr">include</span>: &#123;</span><br><span class="line">            <span class="attr">model</span>: AptHo,</span><br><span class="line">            <span class="attr">include</span>: &#123;</span><br><span class="line">                <span class="attr">model</span>: AptDong,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    userinfo.map(<span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> emailParam = &#123;</span><br><span class="line">            <span class="attr">toEmail</span>: <span class="string">`<span class="subst">$&#123;user.uemail&#125;</span>`</span>,</span><br><span class="line">            <span class="attr">subject</span>: <span class="string">`<span class="subst">$&#123;get_month() -<span class="number">1</span>&#125;</span>월 사용량입니다.`</span>,</span><br><span class="line">            <span class="attr">text</span>: <span class="string">`<span class="subst">$&#123;get_month() - <span class="number">1</span>&#125;</span>월 사용량입니다.`</span>,</span><br><span class="line">            <span class="comment">// ex)1단지101동101호</span></span><br><span class="line">            <span class="attr">name</span>: <span class="string">`<span class="subst">$&#123;user.AptHo.AptDong.apt_complex&#125;</span><span class="subst">$&#123;user.AptHo.AptDong.apt_dong&#125;</span><span class="subst">$&#123;user.AptHo.apt_ho&#125;</span>`</span>,</span><br><span class="line">            <span class="attr">month</span>: get_month() - <span class="number">1</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// const rule = new schedule.RecurrenceRule();</span></span><br><span class="line">        <span class="comment">// const m = 50;</span></span><br><span class="line">        <span class="comment">// rule.minute = m;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 매달 1일 0시 15분 이메일 보내기 실행</span></span><br><span class="line">        <span class="keyword">const</span> j = schedule.scheduleJob(<span class="string">&#x27;13 13 02 * *&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// const j = schedule.scheduleJob(rule, async function() &#123;</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;send mail&quot;</span>);</span><br><span class="line">            <span class="comment">// await basename();</span></span><br><span class="line">            logger.info(<span class="string">&#x27;send mail&#x27;</span>);</span><br><span class="line">            mailSender.sendGmail(emailParam);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>테스트를 위해 시간을 조정하여 진행하였고 스케줄러 시간 부분만 원하는 시간으로 조정하면 정상적으로 전송이 된다.</p></details><h3 id="결과"><a href="#결과" class="headerlink" title="결과"></a>결과</h3><p><img src="https://ifh.cc/g/8AgDwm.png" title="이메일 결과"> </br></p><hr>]]></content:encoded>
      
      
      <category domain="http://hanjuren.github.io/categories/Projects/">Projects</category>
      
      <category domain="http://hanjuren.github.io/categories/Projects/AptManagement/">AptManagement</category>
      
      
      <category domain="http://hanjuren.github.io/tags/express/">express</category>
      
      <category domain="http://hanjuren.github.io/tags/Projects/">Projects</category>
      
      <category domain="http://hanjuren.github.io/tags/Node-js/">Node.js</category>
      
      
      <comments>http://hanjuren.github.io/2021/11/02/project/apt/%EC%95%84%ED%8C%8C%ED%8A%B8-%EC%98%A8%EB%8F%84-%EC%8A%B5%EB%8F%84-%EC%A0%84%EB%A0%A5-%EC%8B%A4%EC%8B%9C%EA%B0%84-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B4%80%EB%A6%AC-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-Part-2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>아파트 온도, 습도, 전력 실시간 데이터 관리 프로젝트 Part 1.</title>
      <link>http://hanjuren.github.io/2021/11/02/project/apt/%EC%95%84%ED%8C%8C%ED%8A%B8-%EC%98%A8%EB%8F%84-%EC%8A%B5%EB%8F%84-%EC%A0%84%EB%A0%A5-%EC%8B%A4%EC%8B%9C%EA%B0%84-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B4%80%EB%A6%AC-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-Part-1/</link>
      <guid>http://hanjuren.github.io/2021/11/02/project/apt/%EC%95%84%ED%8C%8C%ED%8A%B8-%EC%98%A8%EB%8F%84-%EC%8A%B5%EB%8F%84-%EC%A0%84%EB%A0%A5-%EC%8B%A4%EC%8B%9C%EA%B0%84-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B4%80%EB%A6%AC-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-Part-1/</guid>
      <pubDate>Tue, 02 Nov 2021 04:54:57 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;아파트-실시간-데이터-관리-프로젝트&quot;&gt;&lt;a href=&quot;#아파트-실시간-데이터-관리-프로젝트&quot; class=&quot;headerlink&quot; title=&quot;아파트 실시간 데이터 관리 프로젝트&quot;&gt;&lt;/a&gt;아파트 실시간 데이터 관리 프로젝트&lt;/h2&gt;&lt;p&gt;아파트 실시간 데이터를 전송받아 저장하고 사용자에게 데이터를 제공하는 서비스를 만들어보았다.&lt;br&gt;Node.js, express를 기반으로 하여 서버를 구성하고 사용자가 데이터를 볼 수 있는 View는 기본적인 html로 구성하여 백엔드 구축을 중점으로 한 프로젝트이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;실시간 데이터를 전송받기 위해 선택한 통신방법은 MQTT통신을 사용하였다.&lt;/strong&gt;&lt;br&gt;소켓 통신을 통해 실시간 데이터 처리를 하려했던 과정에서 MQTt통신으로 방법을 변경하게 된 이유는 다음과 같은 이유였다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Socket 과 Mqtt 통신 모두 실시간으로 데이터를 전송 할 수 있지만 Socket은 데이터의 전송을 하고 응답을 기다리고 있다. &lt;/br&gt; 하지만 우리의 프로젝트는 실시간 데이터를 전송만 받을 뿐 다시 응답을 돌려 주지 않기 때문에 필요없는 자원이 소모된다. 그러나 Mqtt통신은 데이터의 전송을 하지만 응답을 대기하지 않는다.&lt;/li&gt;
&lt;li&gt;실시간 통신을 위한 서버와의 연결이 비정상적으로 해제 되었을 때 Socket은 재 연결 까지 전송 받아야 하는 데이터가 유실된다. 반면 Mqtt통신은 연결이 해제 되어도 데이터를 연결이 될 때까지 보관 후 연결시 순차적으로 전송해주기 때문에 유실 가능성이 적다.&lt;/li&gt;
&lt;li&gt;프로젝트에서 가공하는 데이터가 온도, 습도, 전력 과 같은 데이터이기 때문에 아두이노 같은 IOT기기에 적합한 통신 방법을 사용해 보기 위해서&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;그렇다면-WebSocket과-Mqtt는-무엇이-다른가&quot;&gt;&lt;a href=&quot;#그렇다면-WebSocket과-Mqtt는-무엇이-다른가&quot; class=&quot;headerlink&quot; title=&quot;그렇다면 WebSocket과 Mqtt는 무엇이 다른가???&quot;&gt;&lt;/a&gt;그렇다면 WebSocket과 Mqtt는 무엇이 다른가???&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;WebSocket이란 TCP기반 소켓 통신을 대체할 목적에서 등장한 양방향 통신기법이다.&lt;/li&gt;
&lt;li&gt;Mqtt란 저전력, 신뢰할 수 없는 네트워크 등의 상황에서 사용하는 메시징 프로토콜이다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;두가지 모두 실시간 통신이 가능하지만 두 방식을 직접 적으로 비교할 수는 없다고 한다. 이유를 알아보니 통신 레벨의 차이와 mqtt는 통신 프로토콜에 의존하지 않으며 패킷 구조로 데이터를 전송하는 차이점이 있다. 간단하게 두가지의 차이점을 알아보고 우리는 왜 Mqtt를 선택하여 실시간 온도 등의 데이터를 전송받기로 했는가에 대한 이유를 알아보자.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="아파트-실시간-데이터-관리-프로젝트"><a href="#아파트-실시간-데이터-관리-프로젝트" class="headerlink" title="아파트 실시간 데이터 관리 프로젝트"></a>아파트 실시간 데이터 관리 프로젝트</h2><p>아파트 실시간 데이터를 전송받아 저장하고 사용자에게 데이터를 제공하는 서비스를 만들어보았다.<br>Node.js, express를 기반으로 하여 서버를 구성하고 사용자가 데이터를 볼 수 있는 View는 기본적인 html로 구성하여 백엔드 구축을 중점으로 한 프로젝트이다.</p><p><strong>실시간 데이터를 전송받기 위해 선택한 통신방법은 MQTT통신을 사용하였다.</strong><br>소켓 통신을 통해 실시간 데이터 처리를 하려했던 과정에서 MQTt통신으로 방법을 변경하게 된 이유는 다음과 같은 이유였다.</p><ol><li>Socket 과 Mqtt 통신 모두 실시간으로 데이터를 전송 할 수 있지만 Socket은 데이터의 전송을 하고 응답을 기다리고 있다. </br> 하지만 우리의 프로젝트는 실시간 데이터를 전송만 받을 뿐 다시 응답을 돌려 주지 않기 때문에 필요없는 자원이 소모된다. 그러나 Mqtt통신은 데이터의 전송을 하지만 응답을 대기하지 않는다.</li><li>실시간 통신을 위한 서버와의 연결이 비정상적으로 해제 되었을 때 Socket은 재 연결 까지 전송 받아야 하는 데이터가 유실된다. 반면 Mqtt통신은 연결이 해제 되어도 데이터를 연결이 될 때까지 보관 후 연결시 순차적으로 전송해주기 때문에 유실 가능성이 적다.</li><li>프로젝트에서 가공하는 데이터가 온도, 습도, 전력 과 같은 데이터이기 때문에 아두이노 같은 IOT기기에 적합한 통신 방법을 사용해 보기 위해서</li></ol><h3 id="그렇다면-WebSocket과-Mqtt는-무엇이-다른가"><a href="#그렇다면-WebSocket과-Mqtt는-무엇이-다른가" class="headerlink" title="그렇다면 WebSocket과 Mqtt는 무엇이 다른가???"></a>그렇다면 WebSocket과 Mqtt는 무엇이 다른가???</h3><ol><li>WebSocket이란 TCP기반 소켓 통신을 대체할 목적에서 등장한 양방향 통신기법이다.</li><li>Mqtt란 저전력, 신뢰할 수 없는 네트워크 등의 상황에서 사용하는 메시징 프로토콜이다.</li></ol><p>두가지 모두 실시간 통신이 가능하지만 두 방식을 직접 적으로 비교할 수는 없다고 한다. 이유를 알아보니 통신 레벨의 차이와 mqtt는 통신 프로토콜에 의존하지 않으며 패킷 구조로 데이터를 전송하는 차이점이 있다. 간단하게 두가지의 차이점을 알아보고 우리는 왜 Mqtt를 선택하여 실시간 온도 등의 데이터를 전송받기로 했는가에 대한 이유를 알아보자.</p><span id="more"></span><h3 id="Why-Mqtt"><a href="#Why-Mqtt" class="headerlink" title="Why Mqtt?"></a>Why Mqtt?</h3><ol><li>데이터의 유실을 최소화 할 수 있다.<br>프로젝트에서 데이터를 3초에 한번씩 전송을 받는다는 가정으로 진행을 했다. 3초에 한번 모든 데이터가 서버로 들어오는 와중 서버와 소켓연결이 끊기고 1분뒤에 재연결이 되었다. 우리는 20번의 데이터를 찾을 수 없다. 물론 소켓연결 해제시 재연결과 유실되는 데이터를 중계하여 관리 한다면 유실 가능성이 적어 지지만 단적인 예로 중간에 비어버린 데이터를 찾을 수 없다.<br>하지만 Mqtt는 데이터를 전송 후 데이터의 전송 여부 패킷을 추적이 가능하며 비어있는 중간의 데이터를 받을 수 있다는 차이점이 있다.</li><li>데이터 크기가 적다.<br>Mqtt데이터는 패킷 구조로 이루어져 있고 크기가 비교적 다른 통신에 비해 작다는 장점이 있다. Mqtt통신이 저전력 환경에서 통신을 하는 환경에 사용하기 때문에 비교적 데이터의 패킷 크기가 작다.</li><li>사물인터넷에서는 주로 Mqtt를 이용한다.<br>Mqtt는 주로 사물인터넷 환경에서 사용하게 된다. mqtt는 저전력 환경에서 통신을 성공시키기 위해 구조가 잘 되어있다. 상시 전력이 들어오지 않을 수 있는 환경에서 사요하기 때문에 이러한 부분에서 발달이 되어있다.</li></ol><h3 id="Mqtt-Setting"><a href="#Mqtt-Setting" class="headerlink" title="Mqtt Setting"></a>Mqtt Setting</h3><p>실제 아두이노와 같은 기기를 활용하여 데이터를 받을 수 없기 때문에 테스트 코드를 사요하여 가상의 데이터를 생성하고 mqtt를 통해 데이터를 계속해서 전송해준다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mqtt = <span class="built_in">require</span>(<span class="string">&#x27;mqtt&#x27;</span>);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">&quot;Mqtt Test&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    before(<span class="string">&quot;connection&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;connection Success&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    it(<span class="string">&quot;public topic&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> mqttClient = mqtt.connect(<span class="comment">/* url */</span> );</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> data = &#123;</span><br><span class="line">                    <span class="attr">aptComplex</span>: <span class="string">&quot;1단지&quot;</span>, <span class="comment">// 아파트 단지</span></span><br><span class="line">                    <span class="attr">aptDong</span>: <span class="string">&quot;101동&quot;</span>, <span class="comment">// 아파트 동</span></span><br><span class="line">                    <span class="attr">number</span>: <span class="string">&quot;101호&quot;</span>, <span class="comment">// 아파트 호수</span></span><br><span class="line">                    <span class="attr">temperature</span>: rand(<span class="number">18</span>, <span class="number">38</span>),</span><br><span class="line">                    <span class="attr">humidity</span>: rand(<span class="number">30</span>, <span class="number">50</span>),</span><br><span class="line">                    <span class="attr">watt</span>: rand(<span class="number">1</span>, <span class="number">2</span>)/<span class="number">10</span>,</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// console.log(`send data = $&#123;JSON.stringify(data)&#125;`)</span></span><br><span class="line">                mqttClient.publish(<span class="comment">/*토픽 이름*/</span>, <span class="built_in">JSON</span>.stringify(data));</span><br><span class="line">            &#125;, <span class="number">2000</span>)</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>publish로 전송하고자 하는 토픽을 통해 데이터를 전송하게 된다. 이 데이터를 서버에서 받기 위해서는 같은 이름의 토픽을 구독하면 데이터가 들어온다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">... </span><br><span class="line">  <span class="built_in">this</span>.mqttClient.subscribe(<span class="built_in">this</span>.topic);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>subscribe(구독)을 통해 토픽이름으로 들어오는 데이터를 전송 받을 수 있다.</p><p><img src="https://ifh.cc/g/PUBo3N.png" title="mqtt데이터"> </br></p><hr><h3 id="Mqtt를-경험하며"><a href="#Mqtt를-경험하며" class="headerlink" title="Mqtt를 경험하며."></a>Mqtt를 경험하며.</h3><p>Mqtt통신에 대해 IOT분야에서 현업 활동중이신 팀원분의 의견으로 또다른 통신 방식에 대해 학습하고 습득할 수 있는 좋은 경험이 되었다. 기본적인 세팅이후 프로젝트 구조에 맞게 수정해가며<br>mqtt 모듈의 메서드 하나하나 어떤 이벤트가 발생하고 동작하는지 알아보는 시간을 가지며 좋은 경험을 했다. 버퍼 형태로 오는 데이터를 다시 문자로 바꾸고 어디서 부터 버퍼형태로 넘어왔는지 왜 버퍼형태였는지 삽질을 해가며 뜯던 시간 모두 영양가 있는 시간이였다.</p>]]></content:encoded>
      
      
      <category domain="http://hanjuren.github.io/categories/Projects/">Projects</category>
      
      <category domain="http://hanjuren.github.io/categories/Projects/AptManagement/">AptManagement</category>
      
      
      <category domain="http://hanjuren.github.io/tags/express/">express</category>
      
      <category domain="http://hanjuren.github.io/tags/Projects/">Projects</category>
      
      <category domain="http://hanjuren.github.io/tags/Node-js/">Node.js</category>
      
      
      <comments>http://hanjuren.github.io/2021/11/02/project/apt/%EC%95%84%ED%8C%8C%ED%8A%B8-%EC%98%A8%EB%8F%84-%EC%8A%B5%EB%8F%84-%EC%A0%84%EB%A0%A5-%EC%8B%A4%EC%8B%9C%EA%B0%84-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B4%80%EB%A6%AC-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-Part-1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>SQLD 정규화</title>
      <link>http://hanjuren.github.io/2021/10/17/sqld/SQLD-%EC%A0%95%EA%B7%9C%ED%99%94/</link>
      <guid>http://hanjuren.github.io/2021/10/17/sqld/SQLD-%EC%A0%95%EA%B7%9C%ED%99%94/</guid>
      <pubDate>Sun, 17 Oct 2021 05:00:13 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;정규화&quot;&gt;&lt;a href=&quot;#정규화&quot; class=&quot;headerlink&quot; title=&quot;정규화&quot;&gt;&lt;/a&gt;정규화&lt;/h3&gt;&lt;p&gt;정규화의 가장 쉬운 의미는 데이터 베이스 수행에 있어 성능 향상 전략중에 한가지이다.&lt;/p&gt;
&lt;p&gt;데이터 중복제거와 분</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="정규화"><a href="#정규화" class="headerlink" title="정규화"></a>정규화</h3><p>정규화의 가장 쉬운 의미는 데이터 베이스 수행에 있어 성능 향상 전략중에 한가지이다.</p><p>데이터 중복제거와 분류를 통해서 입력/수정/삭제 성능을 향상시켜준다. 하지만 계속되는 엔터티의 생성으로 조인이 빈번하게 일어나 데이터 조회 성능은 저하 될수도 있다.</p><p>가장 이해하기 쉬운 의미..</p><ol><li>1정규화 : 모든 속성은 하나의 값을 가져야 한다.(반복적이고 같은 의미를 담는 형태가 있어서는 안된다.)</li><li>2정규화 : 모든 속성은 기본키에 종속 되어야 한다.</li><li>3정규화 : 기본키가 아닌 모든 속성간에 서로를 종속 할 수 없다.</li></ol><p>예를 들어보자…</p><table><thead><tr><th><strong>주문 테이블</strong></th></tr></thead><tbody><tr><td>주문번호 (PK)</td></tr><tr><td>주문일자</td></tr><tr><td>품목코드</td></tr><tr><td>품목단가</td></tr><tr><td>주문수량</td></tr><tr><td>고객번호</td></tr><tr><td>고객명</td></tr></tbody></table><p>주문이라는 테이블에 주문에 대한 모든 데이터가 들어가있다. 예를 들어 내가 옷 두개를 한번에 주문한다. 그렇다면 데이터는 다음과 같이 저장이 될것이다.</p><table><thead><tr><th>주문번호</th><th>주문일자</th><th>품목코드</th><th>품목단가</th><th>주문수량</th><th>고객번호</th><th>고객명</th></tr></thead><tbody><tr><td>1</td><td>10/17</td><td>1</td><td>2000</td><td>1</td><td>1</td><td>한주련</td></tr><tr><td>1</td><td>10/17</td><td>2</td><td>3000</td><td>1</td><td>1</td><td>한주련</td></tr></tbody></table><p>1번이라는 주문번호로 주문한 상품의 수만큼 중복된 컬럼이 존재 하게 될것이다. 이 구조에서는 1정규화가 필요하다. 1번이라는 주문번호가 중복되지 않도록…</p><table><thead><tr><th><strong>주문</strong></th></tr></thead><tbody><tr><td>주문 번호 (PK)</td></tr><tr><td>주문일자</td></tr><tr><td>고객번호</td></tr><tr><td>고객명</td></tr></tbody></table><table><thead><tr><th><strong>주문품목</strong></th></tr></thead><tbody><tr><td>주문번호 (FK)</td></tr><tr><td>품목코드</td></tr><tr><td>품목단가</td></tr><tr><td>주문수량</td></tr></tbody></table><p>1차 정규화의 결과로 이제 1번이라는 하나의 기본키로 여러개의 상품을 중복없이 식별할 수 있다.</p><p>2차 정규화는 주문품목 테이블에서 필요성이 나타난다. 2차 정규화란 <em>복합키로 구성된 (여러개의 PK) 경우 2차 정규화의 대상이 된다</em> 이는 복합키의 일부에만 종속되는 속성이 있을 경우 이 속성을 분리해주는 것이다.</p><p>1차 정규화를 마친 주문 품목 테이블에서 품목단가라는 속성은 품목코드라는 키와만 관련이 있고 주문번호와는 관련이 없다 이때 품목단가 속성이 일부 키에만 종속되어 있으므로 해당 속성을 분리해주면 된다.</p><table><thead><tr><th><strong>주문품목</strong></th></tr></thead><tbody><tr><td>주문번호 (FK)</td></tr><tr><td>품목코드 (FK)</td></tr><tr><td>주문수량</td></tr></tbody></table><table><thead><tr><th><strong>품목</strong></th></tr></thead><tbody><tr><td>품목코드 (PK)</td></tr><tr><td>품목 단가</td></tr></tbody></table><p>2차 정규화를 통해 일부의 종속성을 가진 속성을 분리 해주었다.</p><p>마지막 3차 정규화는 일반 속성인 컬럼은 기본키에 의존해야 하는데 일반 속성에 의존하고 있는 속성들을 분리하는 것이다.</p><p>주문테이블을 살펴보면 고객명이라는 속성은 기본키인 주문 번호에 종속성을 가지고 있지 않고 고객번호 속성에 종속성을 가지고 있는 상태이다. 따라서 3차 정규화의 대상이 된다.</p><table><thead><tr><th><strong>주문</strong></th></tr></thead><tbody><tr><td>주문번호 (PK)</td></tr><tr><td>주문일자</td></tr><tr><td>고객번호 (FK)</td></tr></tbody></table><table><thead><tr><th><strong>화원</strong></th></tr></thead><tbody><tr><td>회원번호 (PK)</td></tr><tr><td>고객명</td></tr></tbody></table><p>솔직히 그동안 데이터베이스 설계하면서 정규화에대한 개념을 모르고 한번에 이과정을 수행했는데 그럼 된거 아닌가 싶지만… 시험을 보기위해서 과정을 나열하다보니 내가 해온 과정과 비슷하지만 다른.. 어떤 그런 어려운 느낌…</p>]]></content:encoded>
      
      
      <category domain="http://hanjuren.github.io/categories/SQLD/">SQLD</category>
      
      
      <category domain="http://hanjuren.github.io/tags/SQLD/">SQLD</category>
      
      
      <comments>http://hanjuren.github.io/2021/10/17/sqld/SQLD-%EC%A0%95%EA%B7%9C%ED%99%94/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>SQLD 데이터 모델링</title>
      <link>http://hanjuren.github.io/2021/10/17/sqld/SQLD-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AA%A8%EB%8D%B8%EB%A7%81/</link>
      <guid>http://hanjuren.github.io/2021/10/17/sqld/SQLD-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AA%A8%EB%8D%B8%EB%A7%81/</guid>
      <pubDate>Sun, 17 Oct 2021 04:27:58 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;데이터-모델링이란&quot;&gt;&lt;a href=&quot;#데이터-모델링이란&quot; class=&quot;headerlink&quot; title=&quot;데이터 모델링이란?&quot;&gt;&lt;/a&gt;데이터 모델링이란?&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;정보시스템을 구축하기 위한 데이터 관점의 업무 분석 기법&lt;/l</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="데이터-모델링이란"><a href="#데이터-모델링이란" class="headerlink" title="데이터 모델링이란?"></a>데이터 모델링이란?</h3><ul><li>정보시스템을 구축하기 위한 데이터 관점의 업무 분석 기법</li><li>데이터베이스를 구축하기 위한 분석/설계의 과정</li></ul><h3 id="모델링"><a href="#모델링" class="headerlink" title="모델링"></a>모델링</h3><ul><li>복잡하고 다향한 현상을 표기법에 의해 규칙을 가지고 표기하는 것을 의미한다.</li><li>가설적 또는 일정 양식에 맟춘 표현</li><li>어떤 것에 대한 에비표현으로 그로부터 최종대상이 구축되도록 하는 계획으로서 기여 하는 것</li></ul><h3 id="모델링의-특징"><a href="#모델링의-특징" class="headerlink" title="모델링의 특징"></a>모델링의 특징</h3><p>모델링은 추상화, 단순화, 명확화 3가지 특징이 있다.</p><ol><li>추상화는 현실세계를 일정한 형식에 맟추어 표현을 한다는 의미이다. </li><li>단순화는 복잡한 현실세계를 약속된 규약에 의해 제한된 표기법, 언어로 표현하여 쉽게 이해할 수 있도록 하는 개념을 의미한다.</li><li>명확화는 누구나 이해하기 쉽게 대상에 대한 애매모호함을 제거하고 정확하게 표기하는 것을 의미한다.</li></ol><h3 id="모델링의-세가지-관점"><a href="#모델링의-세가지-관점" class="headerlink" title="모델링의 세가지 관점"></a>모델링의 세가지 관점</h3><ol><li>데이터 관점 : 업무가 어떤 데이터와 관련이 있는지 또는 데이터간의 관계는 무엇인지에 대해 모델링 하는 방법</li><li>프로세스 관점 : 업무가 실제하고 있는 일은 무엇인지 또는 무엇을 해야 하는지를 모델링 하는 방법</li><li>데이터와 프로세스의 상관관점 : 업무가 처리하고 있는 일의 방법에 따라 데이터는 어떻게 영향을 받고 있는지 모델링 하는 방법</li></ol><h3 id="데이터-모델이-제공하는-기능"><a href="#데이터-모델이-제공하는-기능" class="headerlink" title="데이터 모델이 제공하는 기능"></a>데이터 모델이 제공하는 기능</h3><ol><li>시스템을 현재 또는 원하는 모습으로 가시화하도록 도와준다.</li><li>시스템의 구조와 행동을 명세화 할 수 있게 한다.</li><li>시슽템을 구축하는 구조화된 틀을 제공한다.</li><li>시스템을 구축하는 과정에서 결정한 것을 문서화 한다.</li><li>다양한 영역에 집중하기 위해 다른 영역의 세부 사항은 숨기는 다양한 관점을 제공한다.</li></ol><h3 id="중요성-및-유의점"><a href="#중요성-및-유의점" class="headerlink" title="중요성 및 유의점"></a>중요성 및 유의점</h3><ol><li>파급효과 : 시스템 구축이 완성되어 가는 과정에서 수많은 단위 테스트가 수행되고 이러한 과정이 반복된다. 이러한 테스트 과정에서 데이터 모델이 변경되는 상황은 프로젝트의 규모가 클수록 문제가 일어난다. 이러한 이유로 데이터 설계는 중요하다.</li><li>복잡한 정보 요구사항의 간결한 표현 : 데이터 모델은 정보요구사항을 파악하기 위해 유용하다. </li><li>데이터 품질 : 데이터로 이용할 수 있는 비즈니스 기회를 얻기 위해 데이터는 필요한 데이터만이 존재 해야 한다.</li></ol><h3 id="데이터-모델링의-3단계-진행"><a href="#데이터-모델링의-3단계-진행" class="headerlink" title="데이터 모델링의 3단계 진행"></a>데이터 모델링의 3단계 진행</h3><table><thead><tr><th>데이터 모델링</th><th>내용</th><th>수준</th></tr></thead><tbody><tr><td>개념적 데이터 모델링</td><td>추상화 수준이 높고 업무 중심적이며 포괄적인 수준의 모델링</td><td>추상적</td></tr><tr><td>논리적 데이터 모델링</td><td>시스템으로 구축하고자 하는 업무에 대하여 key 속성 관계 등을 정확하게 표현</td><td></td></tr><tr><td>물리적 데이터 모델링</td><td>실제로 데이터 베이스에 이식할 수 있도록 설계</td><td>구체적</td></tr></tbody></table>]]></content:encoded>
      
      
      <category domain="http://hanjuren.github.io/categories/SQLD/">SQLD</category>
      
      
      <category domain="http://hanjuren.github.io/tags/SQLD/">SQLD</category>
      
      
      <comments>http://hanjuren.github.io/2021/10/17/sqld/SQLD-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AA%A8%EB%8D%B8%EB%A7%81/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>SQLD 속성</title>
      <link>http://hanjuren.github.io/2021/10/16/sqld/SQLD-%EC%86%8D%EC%84%B1/</link>
      <guid>http://hanjuren.github.io/2021/10/16/sqld/SQLD-%EC%86%8D%EC%84%B1/</guid>
      <pubDate>Sat, 16 Oct 2021 07:02:13 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;속성이란-업무에서-필요로-하고-인스턴스에서-관리하고자-하는-의미상-더이상-분리되지-않는-최소의-데이터-단위이다&quot;&gt;&lt;a href=&quot;#속성이란-업무에서-필요로-하고-인스턴스에서-관리하고자-하는-의미상-더이상-분리되지-않는-최소의-데이터-단위</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="속성이란-업무에서-필요로-하고-인스턴스에서-관리하고자-하는-의미상-더이상-분리되지-않는-최소의-데이터-단위이다"><a href="#속성이란-업무에서-필요로-하고-인스턴스에서-관리하고자-하는-의미상-더이상-분리되지-않는-최소의-데이터-단위이다" class="headerlink" title="속성이란 업무에서 필요로 하고 인스턴스에서 관리하고자 하는 의미상 더이상 분리되지 않는 최소의 데이터 단위이다."></a>속성이란 업무에서 필요로 하고 인스턴스에서 관리하고자 하는 의미상 더이상 분리되지 않는 최소의 데이터 단위이다.</h3><p>속성의 개념은 다음과 같다.</p><ul><li>업무에서 필요로 한다.</li><li>의미상 더이상 분리 되지 않는다.</li><li>엔터티를 설명하고 인스턴스의 구성요소가 된다.</li></ul><h3 id="엔터티와-인스턴스-속성-속성값의-관계"><a href="#엔터티와-인스턴스-속성-속성값의-관계" class="headerlink" title="엔터티와 인스턴스, 속성, 속성값의 관계"></a>엔터티와 인스턴스, 속성, 속성값의 관계</h3><ol><li>하나의 엔터티는 두개 이상의 속성을 갖는다.</li><li>하나의 엔터티는 두개 이상의 인스턴스의 집합니다.</li><li>하나의 속성은 하나의 속성값을 가진다.</li></ol><h3 id="속성의-특징"><a href="#속성의-특징" class="headerlink" title="속성의 특징"></a>속성의 특징</h3><ol><li>업무에서 필요로 하는 정보이다.</li><li>정규화 이론에 의해 정해진 식별자에 함수적 종속성을 가진다.</li><li>하나의 속성에는 한개의 값만을 가지게 해야한다. 하나 이상의 값이 필요하다면 별도의 엔터티로 분리를 하는 것이 좋다.</li></ol><h3 id="속성의-분류"><a href="#속성의-분류" class="headerlink" title="속성의 분류"></a>속성의 분류</h3><ol><li>속성에 따른 분류</li></ol><ul><li>기본 속성 : 업무로부터 추출한 모든 속성이 여기에 해당된다.</li><li>설게 속성 : 업무상 필요한 속성 이외에 데이터 모델링을 위해 업무의 규칙화를 위해 속성을 새로 만들거나 변형하여 정의하는 속성.</li><li>파생 속성 : 다른 속성에 의해 영향을 받아 생성되며 보통 계산된 값으로 쓰이는 경우가 많다.</li></ul><ol start="2"><li>엔터티 구성 방식<br>엔터티를 구별하기 위해 주 식별자로 사용하는 속성을 PK 속성, 다른 엔터티와 관계를 포함한 속성을 FK 속성 나머지 속성을 일반 속성으로 구별한다.</li></ol><h3 id="도메인"><a href="#도메인" class="headerlink" title="도메인"></a>도메인</h3><p>각 속성이 가질 수 있는 범위를 도메인이라고 하는데 쉽게 이해하기 위해서 속성에 대한 값의 범위, 데이터 타입, 크기, 제약사항을 의미한다.</p><h3 id="속성의-명명"><a href="#속성의-명명" class="headerlink" title="속성의 명명"></a>속성의 명명</h3><ol><li>엔터티와 마찬가지로 현업에서 사용하는 이름을 사용한다.</li><li>약어 사용은 자제한다.</li><li>서술식 표현은 자제하며 명사를 사용한다.</li><li>유일한 속성 이름을 지정한다. 이는 반 정규화 적용시 안정적 적용이 가능한 장점을 가진다.</li></ol>]]></content:encoded>
      
      
      <category domain="http://hanjuren.github.io/categories/SQLD/">SQLD</category>
      
      
      <category domain="http://hanjuren.github.io/tags/SQLD/">SQLD</category>
      
      
      <comments>http://hanjuren.github.io/2021/10/16/sqld/SQLD-%EC%86%8D%EC%84%B1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>SQLD 엔터티의 개념</title>
      <link>http://hanjuren.github.io/2021/10/16/sqld/SQLD-%EC%9E%90%EA%B2%A9%EC%A6%9D-%EA%B3%B5%EB%B6%80-1%EC%9D%BC%EC%B0%A8/</link>
      <guid>http://hanjuren.github.io/2021/10/16/sqld/SQLD-%EC%9E%90%EA%B2%A9%EC%A6%9D-%EA%B3%B5%EB%B6%80-1%EC%9D%BC%EC%B0%A8/</guid>
      <pubDate>Sat, 16 Oct 2021 03:52:39 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;엔터티란&quot;&gt;&lt;a href=&quot;#엔터티란&quot; class=&quot;headerlink&quot; title=&quot;엔터티란?&quot;&gt;&lt;/a&gt;엔터티란?&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;사람, 장소, 물건, 사건, 개념 등의 명사에 해당&lt;/li&gt;
&lt;li&gt;업무상 관리가 필요한 관심사&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="엔터티란"><a href="#엔터티란" class="headerlink" title="엔터티란?"></a>엔터티란?</h3><ul><li>사람, 장소, 물건, 사건, 개념 등의 명사에 해당</li><li>업무상 관리가 필요한 관심사</li><li>저장이 되기 위한 어떤 것</li></ul><p>즉 엔터티란 업무에 필요하며 유용한 정보를 저장하고 관찰하기 위한 집합으로 지속적인 관심을 가지고 있어야 하는 대상이다. 또한 그 대상간의 동질성을 지닌 인스턴스나 그들이 행하는 행위의 집합이다.  </p><h3 id="엔터티의-특징"><a href="#엔터티의-특징" class="headerlink" title="엔터티의 특징"></a>엔터티의 특징</h3><ol><li>반드시 업무에 필요한 정보여야 한다.</li><li>유일한 식별자에 의해 식별이 되어야 한다.</li><li>영속성으로 존재하는 인스턴스의 집합이다.</li><li>업무 프로세서에 의해 이용되어야 한다.</li><li>반드시 속성이 존재해야 한다.</li><li>다른 엔터티와 최소 한개 이상의 관계를 가지고 있어야 한다.</li></ol><h3 id="엔터티의-분류"><a href="#엔터티의-분류" class="headerlink" title="엔터티의 분류?"></a>엔터티의 분류?</h3><p>엔터티는 자신의 성격, 실체 유형에 따라 구분하거나 업무를 구성하는 모습에 따라 구분이 되고 발생시점에 따라 구분이 가능하다.  </p><ol><li>유무형에 따른 분류<br>유/무형에 따라 유형, 개념, 사건 엔터티로 구분이 가능하다.</li></ol><ul><li>유형 엔터티 : 물리적인 형태가 있고 지속적으로 활용이 가능한 정보 <em>EX) 사원, 물품</em></li><li>개념 엔터티 : 물리적인 형태가 없고 관리해야 할 개념적 정보로 구분이 되는 엔터티 <em>EX) 조직, 보험상품</em></li><li>사건 엔터티 : 업무 수행에 있어 발생되는 엔터티 <em>EX) 주문, 청구, 미납</em></li></ul><ol start="2"><li>발생 시점에 따른 분류<br>엔터티의 발생 시점에 따라서 기본/키엔터티, 중심 엔터티, 행위 엔터티로 구분이 된다.</li></ol><ul><li>기본 엔터티 : 업무에 원래 존대하는 정보, 다른 엔터티에 의해 생성이 되지 않고 독립적으로 생성이 가능하며 다른 엔터티의 부모 역할 수행이 가능</li><li>중심 엔터티 : 기본 엔터티로부터 발생, 업무의 중심적 역할을 수행한다.</li><li>행위 엔터티 : 두개 이상의 부모 엔터티로부터 생성 주로 상세 설계 단계에서 도출된다.</li></ul><h3 id="엔터티의-네이밍"><a href="#엔터티의-네이밍" class="headerlink" title="엔터티의 네이밍"></a>엔터티의 네이밍</h3><ul><li>현업에서 사용하는 이름을 사용한다.</li><li>약어 사용은 자제한다.</li><li>단수명사를 사용한다.</li><li>유일한 이름을 부여한다.</li><li>생성 의미에 맞는 이름을 부여한다.</li></ul>]]></content:encoded>
      
      
      <category domain="http://hanjuren.github.io/categories/SQLD/">SQLD</category>
      
      
      <category domain="http://hanjuren.github.io/tags/SQLD/">SQLD</category>
      
      
      <comments>http://hanjuren.github.io/2021/10/16/sqld/SQLD-%EC%9E%90%EA%B2%A9%EC%A6%9D-%EA%B3%B5%EB%B6%80-1%EC%9D%BC%EC%B0%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>javascript-let, const, 블록레벨 스코프</title>
      <link>http://hanjuren.github.io/2021/10/12/js/let-const-%EB%B8%94%EB%A1%9D%EB%A0%88%EB%B2%A8-%EC%8A%A4%EC%BD%94%ED%94%84/</link>
      <guid>http://hanjuren.github.io/2021/10/12/js/let-const-%EB%B8%94%EB%A1%9D%EB%A0%88%EB%B2%A8-%EC%8A%A4%EC%BD%94%ED%94%84/</guid>
      <pubDate>Tue, 12 Oct 2021 06:48:26 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;let-const-키워드와-블록레벨-스코프&quot;&gt;&lt;a href=&quot;#let-const-키워드와-블록레벨-스코프&quot; class=&quot;headerlink&quot; title=&quot;let, const 키워드와 블록레벨 스코프&quot;&gt;&lt;/a&gt;let, const 키워드와 블록레벨 스코프&lt;/h2&gt;&lt;p&gt;ES5 까지 변수의 선언을 유일하게 할 수 있던 방법인 var키워드는 여러가지의 문제점들이 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;변수의 중복선언&lt;br&gt;var 키워드로 선언한 변수는 중복 선언이 가능하다.  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;함수레벨 스코프&lt;br&gt;var키워드로 선언한 변수는 오직 함수의 코드블록만이 지역 스코프로 인정된다. 따라서 외부 함수에서 var키워드로 선언한 전역 변수는 코드블록 내에서 선언해도 전역변수가 된다.  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;변수 호이스팅&lt;br&gt;var 키워드로 선언한 변수는 호이스팅에 의해 가장 위로 끌어 올려지고 할당이전에도 참조가 가능하다.&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 변수 호이스팅에 의해 이미 foo라는 변수는 선언이 되었다.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 아직 변수에 값이 할당된 상태가 아니기 때문에 undefined가 반환된다.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(foo); &lt;span class=&quot;comment&quot;&gt;// undefined&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 변수 호이스팅에 의해 foo변수가 선언되었고 값을 선언하면 foo의 값은 123이 된다.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;foo = &lt;span class=&quot;number&quot;&gt;123&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 값이 할당된 변수이기 때문에 변수의 값이 반환된다.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(foo); &lt;span class=&quot;comment&quot;&gt;// 123&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 런타임 이전에 foo 라는 변수가 선언이되고 undefined로 초기화 된다.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; foo;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;선언문 이전에 참조하는 것이 변수 호이스팅에 의해 에러가 발생하지는 않지만 코드의 가독성을 해치며 오류를 발생시킬 여지가 생긴다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="let-const-키워드와-블록레벨-스코프"><a href="#let-const-키워드와-블록레벨-스코프" class="headerlink" title="let, const 키워드와 블록레벨 스코프"></a>let, const 키워드와 블록레벨 스코프</h2><p>ES5 까지 변수의 선언을 유일하게 할 수 있던 방법인 var키워드는 여러가지의 문제점들이 있다.</p><ol><li><p>변수의 중복선언<br>var 키워드로 선언한 변수는 중복 선언이 가능하다.  </p></li><li><p>함수레벨 스코프<br>var키워드로 선언한 변수는 오직 함수의 코드블록만이 지역 스코프로 인정된다. 따라서 외부 함수에서 var키워드로 선언한 전역 변수는 코드블록 내에서 선언해도 전역변수가 된다.  </p></li><li><p>변수 호이스팅<br>var 키워드로 선언한 변수는 호이스팅에 의해 가장 위로 끌어 올려지고 할당이전에도 참조가 가능하다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 변수 호이스팅에 의해 이미 foo라는 변수는 선언이 되었다.</span></span><br><span class="line"><span class="comment">// 아직 변수에 값이 할당된 상태가 아니기 때문에 undefined가 반환된다.</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 변수 호이스팅에 의해 foo변수가 선언되었고 값을 선언하면 foo의 값은 123이 된다.</span></span><br><span class="line">foo = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 값이 할당된 변수이기 때문에 변수의 값이 반환된다.</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 런타임 이전에 foo 라는 변수가 선언이되고 undefined로 초기화 된다.</span></span><br><span class="line"><span class="keyword">var</span> foo;</span><br></pre></td></tr></table></figure><p>선언문 이전에 참조하는 것이 변수 호이스팅에 의해 에러가 발생하지는 않지만 코드의 가독성을 해치며 오류를 발생시킬 여지가 생긴다.</p></li></ol><span id="more"></span><h3 id="let-키워드"><a href="#let-키워드" class="headerlink" title="let 키워드"></a>let 키워드</h3><p>let 키워드는 ES6에서 도입된 변수 선언 키워드이다.<br>var키워드와의 차이점은 다음의 특징들이 있다.</p><ol><li><p>변수 중복 선언 금지<br>var키워드로 변수를 선언하면 같은 식별자이름의 변수를 중복 선언해도 에러가 발생하지 않는다. 하지만 let키워드는 같은 이름의 변수를 선언하면 문법 에러가 발생한다.</p></li><li><p>블록 레벨 스코프<br>var키워드로 선언한 변수는 오직 함수 코드 블록만을 지역 스코프로 인정하는 함수 레벨 스코프 방식이였다. 하지만 let키워드는 모든 코드블록을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다.</p></li></ol><p>동일한 코드로 var키워드와 let키워드의 스코프 레벨 차이를 확인해보자</p><p><em>var 키워드</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// 0, 1, 2, 3, 4</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">//10</span></span><br></pre></td></tr></table></figure><p><em>let 키워드</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">10</span>; <span class="comment">// 젼역 변수</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">100</span>; <span class="comment">// 함수 레벨 스코프의 지역 변수</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; <span class="comment">// 블록 레벨 스코프의 지역변수</span></span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// 0, 1, 2, 3, 4</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// 5 </span></span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><ol start="3"><li>변수 호이스팅<br>let 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는 것처럼 동작한다.</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 참조에러</span></span><br><span class="line"><span class="keyword">let</span> foo;</span><br></pre></td></tr></table></figure><p>let 키워드로 선언한 변수는 선언문 이전에 참조하면 참조에러가 발생한다.  </p><p>var 키워드는 런타임 이전 자바스크립트 엔진에 의해 변수가 선언되고 초기화 단게가 진행된다. 이때 undefined로 초기화가 되기 때문에 선언문 이전에도 참조가 가능하지만<br>let 키워드로 선언한 변수는 선언단계와 초기화 단계가 분리되어 실행된다. var 키워드의 변수와 마찬가지로 런타임 이전에 변수가 선언은 되지만 초기화 단계는 선언문에 도달 했을때 진행 되므로 선언 이전에 변수를 참조하면 참조 에러가 발생하는 것이다.  </p><p>이러한 변수의 선언단계인 스코프 시작 단계와 초기화 단계 사이에서 변수를 참조 할 수 없는 것을 <strong>일시적 사각지대</strong>라고 부른다.  </p><p><img src="https://ifh.cc/g/KorcRH.png," title="일시적 사각지대"></br></p><p><strong>그렇다면 let 키워드로 선언한 변수는 호이스팅이 발생하지 않을까?</strong>  </p><p>결론은 <em>아니다.</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>; <span class="comment">// 전역변수</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 참조 에러</span></span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1243</span>; <span class="comment">// 지역 변수</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>변수 호이스팅이 일어나지 않는다면 if문 내에서 참조하는 a변수는 상위 스코프의 a라는 변수를 참조해야 한다.<br>하지만 참조에러가 난다는 것은 지역 스코프내에 a라는 변수가 호이스팅에 의해 상위로 끌어 올려졌다는 것을 의미한다.  </p><p>ES6에서 도입된 let const를 포함 모든 선언은 호이스팅이 일어난다. 다만 let, const, class를 사용한 선언문은 호이스팅이 일어나지 않는 것 처럼 동작하게 되어있다.</p><h3 id="const-키워드"><a href="#const-키워드" class="headerlink" title="const 키워드"></a>const 키워드</h3><p>const 키워드는 상수를 선언하기 위해 사용하는 키워드이다.  </p><ol><li><p><strong>const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화가 진행되어야 한다.</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>; <span class="comment">// 👍</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b; <span class="comment">// 👎</span></span><br></pre></td></tr></table></figure><p>const 키워드로 선언한 변수는 let 키워드와 마찬가지로 블록 레벨 스코프를 가진다.</p></li><li><p>재할당이 금지된다.<br>const 키워드로 선언한 변수는 재할당이 금지된다.</p></li><li><p>상수?<br>상수란 재할당이 금지된 변수를 의미한다.<br>변수는 값의 재할당과 변경이 자유로운 반면 상수는 재할당이 불가능한 변수이다.</p></li></ol><p><strong>상수는 상태 유지와 가독성 측면, 유지보수를 위해 적극적인 사용이 좋다.</strong></p><ol start="4"><li>const 키워드와 객체<br>const 키워드로 선언한 변수에 객체를 할당시 객체의 프로퍼티 값은 변경이 가능하다.</li></ol><p><strong>이는 const 키워드가 재할당을 금지하는 것뿐 값의 불변성을 의미하지는 않는다는 것이다.</strong></p><h3 id="var-vs-let-const"><a href="#var-vs-let-const" class="headerlink" title="var vs let, const?"></a>var vs let, const?</h3><p>변수 선언에는 기본적으로 const 키워드를 사용하고 재할당이 필요한 값에 let키워드를 사용한다.  </p><p>일단 변수를 선언하고 값이 변경되어야 한다면 let 키워드로 바꿔도 무방하다. 일단 const 키워드를 사용해 변수를 선언하자.</p>]]></content:encoded>
      
      
      <category domain="http://hanjuren.github.io/categories/javascript/">javascript</category>
      
      
      <category domain="http://hanjuren.github.io/tags/javascript/">javascript</category>
      
      
      <comments>http://hanjuren.github.io/2021/10/12/js/let-const-%EB%B8%94%EB%A1%9D%EB%A0%88%EB%B2%A8-%EC%8A%A4%EC%BD%94%ED%94%84/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>javascript-전역변수의 문제점</title>
      <link>http://hanjuren.github.io/2021/10/12/js/javascript-%EC%A0%84%EC%97%AD%EB%B3%80%EC%88%98%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90/</link>
      <guid>http://hanjuren.github.io/2021/10/12/js/javascript-%EC%A0%84%EC%97%AD%EB%B3%80%EC%88%98%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90/</guid>
      <pubDate>Tue, 12 Oct 2021 06:47:26 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;전역변수의-문제점&quot;&gt;&lt;a href=&quot;#전역변수의-문제점&quot; class=&quot;headerlink&quot; title=&quot;전역변수의 문제점&quot;&gt;&lt;/a&gt;전역변수의 문제점&lt;/h2&gt;&lt;h3 id=&quot;변수의-생명주기&quot;&gt;&lt;a href=&quot;#변수의-생명주기&quot; class=&quot;headerlink&quot; title=&quot;변수의 생명주기&quot;&gt;&lt;/a&gt;변수의 생명주기&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;변수는 선언에 의해 생성되고 할당을 통해 값을 가진다.&lt;/li&gt;
&lt;li&gt;변수는 언젠가 소멸한다.&lt;/li&gt;
&lt;li&gt;전역변수의 생명주기는 애플리케이션의 생명주기와 같다.&lt;/li&gt;
&lt;li&gt;함수 내에서 생성된 지역변수는 함수 호출시 선언문이 실행되고 함수 종료시 소멸된다.&lt;/li&gt;
&lt;li&gt;즉 지역변수의 생명 주기는 함수의 생명 주기와 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;전역-변수의-문제점&quot;&gt;&lt;a href=&quot;#전역-변수의-문제점&quot; class=&quot;headerlink&quot; title=&quot;전역 변수의 문제점&quot;&gt;&lt;/a&gt;전역 변수의 문제점&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;암묵적 결합&lt;br&gt;전역변수의 의도는 코드 어디서든 참조할 수 있는 변수를 만든다는 의미이다. 이는 모든 코드가 이를 참조하고 값을 변경할 수 있는 암묵적 결합을 의미한다.&lt;br&gt;변수의 유효범위가 클수록 코드의 가독성이 나빠지고 의도치 않은 값 변경이 일어날 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;긴 생명 주기&lt;br&gt;전역 변수는 생명주기가 길다. 즉 메모리 소비 시간이 길다.&lt;br&gt;var 키워드로 생성된 변수는 중복을 혀용하므로 전역변수는 변수 이름이 중복될 가능성이 크다. 의도치 않게 변수가 중복되면 값이 변경된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;스코프 체인 상에서 종점에 존재&lt;br&gt;전역 변수는 스코프 상에서 종점에 존재한다. 이는 변수의 검색시 가장 마지막 단계에서 검색이 된다는 것이다. 따라서 검색 속도가 가장 느리다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;네임스페이스 오염&lt;br&gt;파일을 분리해도 하나의 전역 스코프를 공유 한다는 것에서 다른 파일 내에 동일한 변수가 스코프내에 존재할 수 있다는 문제점이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="전역변수의-문제점"><a href="#전역변수의-문제점" class="headerlink" title="전역변수의 문제점"></a>전역변수의 문제점</h2><h3 id="변수의-생명주기"><a href="#변수의-생명주기" class="headerlink" title="변수의 생명주기"></a>변수의 생명주기</h3><ul><li>변수는 선언에 의해 생성되고 할당을 통해 값을 가진다.</li><li>변수는 언젠가 소멸한다.</li><li>전역변수의 생명주기는 애플리케이션의 생명주기와 같다.</li><li>함수 내에서 생성된 지역변수는 함수 호출시 선언문이 실행되고 함수 종료시 소멸된다.</li><li>즉 지역변수의 생명 주기는 함수의 생명 주기와 같다.</li></ul><h3 id="전역-변수의-문제점"><a href="#전역-변수의-문제점" class="headerlink" title="전역 변수의 문제점"></a>전역 변수의 문제점</h3><ol><li><p>암묵적 결합<br>전역변수의 의도는 코드 어디서든 참조할 수 있는 변수를 만든다는 의미이다. 이는 모든 코드가 이를 참조하고 값을 변경할 수 있는 암묵적 결합을 의미한다.<br>변수의 유효범위가 클수록 코드의 가독성이 나빠지고 의도치 않은 값 변경이 일어날 수 있다.</p></li><li><p>긴 생명 주기<br>전역 변수는 생명주기가 길다. 즉 메모리 소비 시간이 길다.<br>var 키워드로 생성된 변수는 중복을 혀용하므로 전역변수는 변수 이름이 중복될 가능성이 크다. 의도치 않게 변수가 중복되면 값이 변경된다.</p></li><li><p>스코프 체인 상에서 종점에 존재<br>전역 변수는 스코프 상에서 종점에 존재한다. 이는 변수의 검색시 가장 마지막 단계에서 검색이 된다는 것이다. 따라서 검색 속도가 가장 느리다.</p></li><li><p>네임스페이스 오염<br>파일을 분리해도 하나의 전역 스코프를 공유 한다는 것에서 다른 파일 내에 동일한 변수가 스코프내에 존재할 수 있다는 문제점이 있다.</p></li></ol><span id="more"></span><h3 id="전역-변수의-사용을-억제하는-방법"><a href="#전역-변수의-사용을-억제하는-방법" class="headerlink" title="전역 변수의 사용을 억제하는 방법"></a>전역 변수의 사용을 억제하는 방법</h3><p><strong>전역 변수는 꼭 필요한 상황이 아니라면 지역변수를 활용해야 한다.</strong> 무조건 적인 지역변수으 사용을 권장하지 않지만 무분별한 전역 변수의 사용은 자제하는 것이 바람직하다.</p><ol><li><p>즉시 실행 함수<br>함수의 정의와 동시에 실행되는 즉시 실행 함수에서 모든 코드를 즉시 실행 함수로 감싸면 모든 변수가 즉시 실행 함수의 지역 변수로만 사용이 가능하다. 이방법은 주로 라이브러리 같은 곳에서 사용하는 모습을 볼 수 있다.</p></li><li><p>네임스페이스 객체<br>전역에 네임스페이스 역할을 담당할 객체를 생성하고 전역 변수처럼 사용하려하는 변수를 프로퍼티로 추가하는 방법.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MYAPP = &#123;&#125;; <span class="comment">// 전역 네임스페이스 객체</span></span><br><span class="line"></span><br><span class="line">MYAPP.name = <span class="string">&#x27;Lee&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(MYAPP.name); <span class="comment">// Lee</span></span><br></pre></td></tr></table></figure><p>이방법은 네임스페이스로 분리하여 식별자의 충돌을 억제하는 장점이 있지만 네임스페이스 객체 자체가 전역 변수에 할당되기 때문에 유용한 방법은 아니다.</p></li><li><p>모듈 패턴</p></li></ol><ul><li>모듈 패턴이란 클래스를 모방하여 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만드는 방식이다.</li><li>모듈 패턴은 전역 변수의 억제, 캡슐화 구현의 특징을 가진다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Counter = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">0</span>; <span class="comment">// private 변수</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">in</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ++num;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">out</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> --num;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Counter.num);</span><br><span class="line"><span class="built_in">console</span>.log(Counter.in());</span><br><span class="line"><span class="built_in">console</span>.log(Counter.out());</span><br><span class="line"><span class="built_in">console</span>.log(Counter.out());</span><br></pre></td></tr></table></figure><ol start="4"><li>ES6 모둘<br>ES6 모듈을 사용하게 되면 전역변수를 사용할 수 없다.</li></ol><ul><li>ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공한다.</li><li>ES6 모듈은 모던 브라우저( 크롬, 엣지16이상 )등에서 사용이 가능하며 IE를 포함한 구형 브라우저에서는 작동하지 않는다.</li></ul>]]></content:encoded>
      
      
      <category domain="http://hanjuren.github.io/categories/javascript/">javascript</category>
      
      
      <category domain="http://hanjuren.github.io/tags/javascript/">javascript</category>
      
      
      <comments>http://hanjuren.github.io/2021/10/12/js/javascript-%EC%A0%84%EC%97%AD%EB%B3%80%EC%88%98%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>javascript-스코프</title>
      <link>http://hanjuren.github.io/2021/10/11/js/javascript-%EC%8A%A4%EC%BD%94%ED%94%84/</link>
      <guid>http://hanjuren.github.io/2021/10/11/js/javascript-%EC%8A%A4%EC%BD%94%ED%94%84/</guid>
      <pubDate>Mon, 11 Oct 2021 06:41:47 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;스코프&quot;&gt;&lt;a href=&quot;#스코프&quot; class=&quot;headerlink&quot; title=&quot;스코프&quot;&gt;&lt;/a&gt;스코프&lt;/h2&gt;&lt;p&gt;스코프 (유효범위)는 javascript를 포함한 모든 프로그래밍 언어의 기본적이고 중요한 개념이다. &lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;add&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;x, y&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 매개변수는 함수 몸체 내에서만 참조가 가능하다.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 따라서 매개변수의 스코프는 함수 내부다.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(x, y);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; x + y;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;add (&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(x, y); &lt;span class=&quot;comment&quot;&gt;// Error 스코프 유효범위를 벗어남&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;변수는 코드의 가장 바깥쪽에 함수 내부에 또는 코드블록에서 선언될 수 있다. 이렇게 선언된 변수는 변수가 선언된 위치에 따라서 스코프가 결정된다. 모든 식별자가 자신의 선언된 위치에서 스코프를 결정한다.&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; x = &lt;span class=&quot;string&quot;&gt;&amp;#x27;global&amp;#x27;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; x = &lt;span class=&quot;string&quot;&gt;&amp;#x27;local&amp;#x27;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(x); &lt;span class=&quot;comment&quot;&gt;// local&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;foo();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(x); &lt;span class=&quot;comment&quot;&gt;// global&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;위의 예제를 보면 동일한 이름을 가진 변수 x를 선언했고 함수내부, 외부에서 각각 참조를 한다. 이때 자바스크립트 엔진은 같은 두이름 중 어떤 것을 참조할지 결정한다. 이를 식별자 결정이라고 한다. 이때 엔진은 스코프를 규칙으로 삼아 참조할 변수를 결정한다. 즉 스코프는 식별자를 검색할 때 사용하는 규칙이라고도 할 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;코드의 문맥과 환경&lt;br&gt;코드가 어디서 실행되는지 주변에 어떤 코드가 있는지를 렉시컬 환경이라고 부른다. &lt;/p&gt;
&lt;/blockquote&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="스코프"><a href="#스코프" class="headerlink" title="스코프"></a>스코프</h2><p>스코프 (유효범위)는 javascript를 포함한 모든 프로그래밍 언어의 기본적이고 중요한 개념이다. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 매개변수는 함수 몸체 내에서만 참조가 가능하다.</span></span><br><span class="line">  <span class="comment">// 따라서 매개변수의 스코프는 함수 내부다.</span></span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">add (<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x, y); <span class="comment">// Error 스코프 유효범위를 벗어남</span></span><br></pre></td></tr></table></figure><p>변수는 코드의 가장 바깥쪽에 함수 내부에 또는 코드블록에서 선언될 수 있다. 이렇게 선언된 변수는 변수가 선언된 위치에 따라서 스코프가 결정된다. 모든 식별자가 자신의 선언된 위치에서 스코프를 결정한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">&#x27;global&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="string">&#x27;local&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// local</span></span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// global</span></span><br></pre></td></tr></table></figure><p>위의 예제를 보면 동일한 이름을 가진 변수 x를 선언했고 함수내부, 외부에서 각각 참조를 한다. 이때 자바스크립트 엔진은 같은 두이름 중 어떤 것을 참조할지 결정한다. 이를 식별자 결정이라고 한다. 이때 엔진은 스코프를 규칙으로 삼아 참조할 변수를 결정한다. 즉 스코프는 식별자를 검색할 때 사용하는 규칙이라고도 할 수 있다.</p><blockquote><p>코드의 문맥과 환경<br>코드가 어디서 실행되는지 주변에 어떤 코드가 있는지를 렉시컬 환경이라고 부른다. </p></blockquote><span id="more"></span><h3 id="스코프의-종류"><a href="#스코프의-종류" class="headerlink" title="스코프의 종류"></a>스코프의 종류</h3><p>코드는 전역과 지역으로 구분할 수 있다.</p><table><thead><tr><th>구분</th><th>설명</th><th>스코프</th><th>변수</th></tr></thead><tbody><tr><td>전역</td><td>코드의 가장 바깥 영역</td><td>전역 스코프</td><td>전역 변수</td></tr><tr><td>지역</td><td>함수의 몸체 내부</td><td>지역 스코프</td><td>지역 변수</td></tr></tbody></table><ol><li>전역과 지역 스코프<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">&#x27;global 1&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="string">&#x27;global 2&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> z = <span class="string">&#x27;inner 1&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">  <span class="built_in">console</span>.log(z);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="string">&#x27;inner 2&#x27;</span>;</span><br><span class="line">      <span class="built_in">console</span>.log(x);</span><br><span class="line">      <span class="built_in">console</span>.log(y);</span><br><span class="line">      <span class="built_in">console</span>.log(z);</span><br><span class="line">  &#125;</span><br><span class="line">  inner();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outer();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"><span class="built_in">console</span>.log(y);</span><br><span class="line"><span class="built_in">console</span>.log(z);</span><br></pre></td></tr></table></figure>전역이란 코드의 가장 바깥 부분을 말한다. 해당 스크립트에서 전역 변수는 1,2줄에서 선언된 x,y 변수이다. 이렇게 전역으로 선언된 전역 변수는 어디에서든 참조가 가능하다.<br>따라서 outer()함수 inner()함수에서도 참조가 가능하여 해당 값이 출력된다.<br>outer함수내부에 선언된 z변수는 함수내부의 지역 변수이고 이 변수는 함수 몸체 내부에서만 참조가 가능하다. 코드의 마지막 줄에서 참조한 z라는 변수는 전역으로 선언되지 않았기 때문에 참조 에러가 난다.<br>inner함수또한 지역 변수로 x를 선언한다. inner함수에서 콘솔로 출력하는 x는 내부에 선언된 지역 변수 x를 출력하고 내부에 선언되진 않는 값들을 외부에서 찾아 출력한다.<br>이때 변수를 찾는 방식이 렉시컬 환경에 의해 내부 렉시컬 환경에서부터 전역 렉시컬 환경까지 확장되어 순차적으로 변수를 참조하게 된다.</li></ol><hr><h3 id="스코프-체인"><a href="#스코프-체인" class="headerlink" title="스코프 체인"></a>스코프 체인</h3><p>함수는 전역, 함수 몸체 내부에서 모두 선언이 가능하다. 함수는 중첩이 가능하므로 함수의 스코프 또한 중첩이 가능하다. 이는 스코프가 계층적 구조를 갖는다는 의미이다.<br>모든 스코프는 하나의 계층적 구조로 연결되며 최상위 스코프는 전역 스코프다. 이러한 구조를 <strong>스코프 체인</strong>이라 한다.</p><p>자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프부터 상위 스코프 방향으로 이동하여 변수를 검색한다.</p><h4 id="스코프-체인에-의한-변수-검색"><a href="#스코프-체인에-의한-변수-검색" class="headerlink" title="스코프 체인에 의한 변수 검색"></a>스코프 체인에 의한 변수 검색</h4><p>위에서 선언한 스크립트를 보면 전역 스코프로 선언한 변수를 지역 스코프에서 참조가 가능하지만 지역 스코프로 선언된 변수를 상위 스코프에서는 참조가 불가능하다.<br>계층적 구조를 갖는 스코프는 상위 스코프를 하위 스코프에서 참조하는 것은 가능하지만 하위 스코프에서 선언된 변수를 상위 스코프에서는 참조가 불가능 하다는 것을 의미한다.</p><h3 id="스코프-체인에-의한-함수-검색"><a href="#스코프-체인에-의한-함수-검색" class="headerlink" title="스코프 체인에 의한 함수 검색"></a>스코프 체인에 의한 함수 검색</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 전역 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;global function&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 중첩 함수</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;local function&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  foo();</span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure><p>bar함수에서 호출하는 foo함수는 전역으로 선언된 foo함수를 호출하는 것이 아닌 내부에 있는 foo함수를 먼저 호출하게 된다. 이는 변수와 마찬가지로 함수또한 식별자에 해당하기 때문에 스코프를 갖는다는 의미이다.</p><h3 id="렉시컬-스코프"><a href="#렉시컬-스코프" class="headerlink" title="렉시컬 스코프"></a>렉시컬 스코프</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure><p>위 스크립트의 상위스코프를 예측해보면 두가지 패턴이 예측된다.</p><ol><li>함수를 호출한 곳에서 상위스코프를 결정</li><li>함수를 정의한 곳에서 상위 스코프를 결정</li></ol><p>첫 번째 방식은 동적 스코프라고 부른다. 함수가 호출된 곳에서 상위 스코프를 결정한다면 bar함수가 호출된 foo함수가 bar함수의 상위 스코프가 될것이다.<br>두 번째 방식을 렉시컬 스코프, 정적 스코프라고 한다. 이는 함수가 정의되어 평가되는 시점에 스코프를 결정하는 방식이다.</p><p>대부분의 프로그래밍 언어는 렉시컬 스코프 방식을 따르고 있다.</p><p>따라서 해당 스크립트를 실행하면 전역 스코프로 선언된 변수의 값이 1이 두번 출력된다.<br>foo함수를 호출하면 젼역으로 선언한 함수인 bar함수를 호출하고 bar함수는 x라느 변수를 참조하기 위해 내부에서 검색한후 외부 스코프의 x를 참조하기 때문이다.  </p>]]></content:encoded>
      
      
      <category domain="http://hanjuren.github.io/categories/javascript/">javascript</category>
      
      
      <category domain="http://hanjuren.github.io/tags/javascript/">javascript</category>
      
      
      <comments>http://hanjuren.github.io/2021/10/11/js/javascript-%EC%8A%A4%EC%BD%94%ED%94%84/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>javascript-렉시컬환경</title>
      <link>http://hanjuren.github.io/2021/10/11/js/javascript-%EB%A0%89%EC%8B%9C%EC%BB%AC%ED%99%98%EA%B2%BD/</link>
      <guid>http://hanjuren.github.io/2021/10/11/js/javascript-%EB%A0%89%EC%8B%9C%EC%BB%AC%ED%99%98%EA%B2%BD/</guid>
      <pubDate>Mon, 11 Oct 2021 05:24:38 GMT</pubDate>
      
      <description>&lt;p&gt;javascript 책 공부중 렉시컬 환경? 이라는 단어를 보고 이게 어떤것을 의미하는지 궁금하여 알아보았다. 역시 처음들어보는 생소한 의미였고 새로운것을 배웠다.&lt;br&gt;렉시컬 환경에 대해 알아보자.&lt;/p&gt;
&lt;h3 id=&quot;👍렉시컬-환경&quot;&gt;&lt;a href=&quot;#👍렉시컬-환경&quot; class=&quot;headerlink&quot; title=&quot;👍렉시컬 환경&quot;&gt;&lt;/a&gt;👍렉시컬 환경&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;javascript에서 실행중인 함수, 코드 블록 { }, 스크립트는 렉시컬 환경이라 불리는 내부 숨김 연관 객체를 갖는다.&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;렉시컬 환경은 두가지로 나뉜다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;환경 레코드: 모든 지역변수를 프로퍼티로 저장하고 있는 객체.&lt;/li&gt;
&lt;li&gt;외부 렉시컬 환경에 대한 참조: 외부 코드와 연관&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;환경-레코드&quot;&gt;&lt;a href=&quot;#환경-레코드&quot; class=&quot;headerlink&quot; title=&quot;환경 레코드&quot;&gt;&lt;/a&gt;환경 레코드&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;모든 지역변수를 프로퍼티로 저장하는 객체&lt;/li&gt;
&lt;li&gt;this 값과 같은 기타 정보도 저장된다.&lt;/li&gt;
&lt;li&gt;변수는 특수 내부 객체인 환경 레코드의 프로퍼티의 의미일 뿐이다.&lt;/li&gt;
&lt;li&gt;변수를 가져오거나 변경하는 것은 환경 레코드의 프로퍼티를 가져오거나 변경하는 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;외부-렉시컬-환경&quot;&gt;&lt;a href=&quot;#외부-렉시컬-환경&quot; class=&quot;headerlink&quot; title=&quot;외부 렉시컬 환경&quot;&gt;&lt;/a&gt;외부 렉시컬 환경&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;외부 코드와 연결된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;전역-렉시컬-환경&quot;&gt;&lt;a href=&quot;#전역-렉시컬-환경&quot; class=&quot;headerlink&quot; title=&quot;전역 렉시컬 환경&quot;&gt;&lt;/a&gt;전역 렉시컬 환경&lt;/h3&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; a = &lt;span class=&quot;string&quot;&gt;&amp;#x27;hello&amp;#x27;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;위와 같이 선언된 변수는 코드 전체와 관련된 변수로 전역 렉시컬 환경이라고 부른다. 스크립트 전체와 관련된 전역 렉시컬 환경은 외부 참조를 가지지 않는다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>javascript 책 공부중 렉시컬 환경? 이라는 단어를 보고 이게 어떤것을 의미하는지 궁금하여 알아보았다. 역시 처음들어보는 생소한 의미였고 새로운것을 배웠다.<br>렉시컬 환경에 대해 알아보자.</p><h3 id="👍렉시컬-환경"><a href="#👍렉시컬-환경" class="headerlink" title="👍렉시컬 환경"></a>👍렉시컬 환경</h3><p><strong>javascript에서 실행중인 함수, 코드 블록 { }, 스크립트는 렉시컬 환경이라 불리는 내부 숨김 연관 객체를 갖는다.</strong>  </p><p>렉시컬 환경은 두가지로 나뉜다.</p><ol><li>환경 레코드: 모든 지역변수를 프로퍼티로 저장하고 있는 객체.</li><li>외부 렉시컬 환경에 대한 참조: 외부 코드와 연관</li></ol><h4 id="환경-레코드"><a href="#환경-레코드" class="headerlink" title="환경 레코드"></a>환경 레코드</h4><ul><li>모든 지역변수를 프로퍼티로 저장하는 객체</li><li>this 값과 같은 기타 정보도 저장된다.</li><li>변수는 특수 내부 객체인 환경 레코드의 프로퍼티의 의미일 뿐이다.</li><li>변수를 가져오거나 변경하는 것은 환경 레코드의 프로퍼티를 가져오거나 변경하는 것이다.</li></ul><h4 id="외부-렉시컬-환경"><a href="#외부-렉시컬-환경" class="headerlink" title="외부 렉시컬 환경"></a>외부 렉시컬 환경</h4><ul><li>외부 코드와 연결된다.</li></ul><h3 id="전역-렉시컬-환경"><a href="#전역-렉시컬-환경" class="headerlink" title="전역 렉시컬 환경"></a>전역 렉시컬 환경</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;hello&#x27;</span>;</span><br></pre></td></tr></table></figure><p>위와 같이 선언된 변수는 코드 전체와 관련된 변수로 전역 렉시컬 환경이라고 부른다. 스크립트 전체와 관련된 전역 렉시컬 환경은 외부 참조를 가지지 않는다.</p><span id="more"></span><h3 id="함수의-렉시컬-환경"><a href="#함수의-렉시컬-환경" class="headerlink" title="함수의 렉시컬 환경"></a>함수의 렉시컬 환경</h3><p>함수는 선언과 동시에 렉시컬 환경이 만들어지는 즉시 사용히 가능하다.<br>함수를 선언하면 함수는 젼역 렉시컬 환경이 된다.</p><p>이후 함수를 호출할때 함수를 위한 내부 렉시컬 환경과 내부 렉시컬 환경이 가르키는 외부 렉시컬 환경을 갖게 된다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 함수 내부에서 내부 렉시컬 환경이 만들어짐</span></span><br><span class="line">  <span class="comment">// 함수 호출시 내부 렉시컬 환경에는 name이라는 프로퍼티가 생성됨</span></span><br><span class="line">  <span class="comment">// 또한 외부 렉시컬 환경을 참조한다.</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;a&#125;</span> <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line">say(<span class="string">&#x27;jone&#x27;</span>);</span><br></pre></td></tr></table></figure><p>함수가 호출되고 내부 렉시컬 환경에 name이라는 프로퍼티를 생성하고 전역 렉시컬 환경을 외부 렉시컬 환경으로 참조한다.<br>이 후 함수는 변수에 접근할때 내부 렉시컬 환경에서 변수에 먼저 접근하고 내부 렉시컬 환경에 해당하는 변수를 찾지 못하면 참조하고 있는 외부 렉시컬 환경으로 넘어가 변수를 찾는다. 이 과정은 전역 렉시컬 환경으로 확장 될 때까지 반복된다.  </p><p>따라서 say함수는 <em>a</em>와 <em>name</em>변수를 찾아야한다. 이때 내부에서 먼저 name이라는 변수를 찾고 내부 렉시컬 환경에 존재하지 않는 <em>a</em>변수를 찾기위해 외부 렉시컬 환경에서 찾아 값을 참조하는 방식으로 진행된다.  </p><h3 id="함수를-반환하는-경우의-렉시컬-환경"><a href="#함수를-반환하는-경우의-렉시컬-환경" class="headerlink" title="함수를 반환하는 경우의 렉시컬 환경"></a>함수를 반환하는 경우의 렉시컬 환경</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> counter = makeCounter();</span><br></pre></td></tr></table></figure><p>makeCounter함수가 호출되면 함수의 새로운 렉시컬 환경이 생성된다.<br>makeCounter함수의 내부 렉시컬 환경에는 count라는 변수와 중첩함수가 만들어진다.</p><p>이때 생성한 중첩함수는 생성된 곳의 렉시컬 환경을 기억한다. 함수는 [[Environment]]이라는 숨김 프로퍼티를 가지는데 이것이 함수가 만들어진 곳의 렉시컬 환경에 대한 참조가 저장된다.</p><p>따라서 이 함수를 호출시 makeCounter의 내부 렉시컬 환경이 구성되고 내부의 중첩 함수는 자신이 생성된 외부 함수의 렉시컬 환경을 참조한다. 외부 함수의 내부 렉시컬 환경에 count라는 변수가 생성되고 중첩함수가 실행되는데 중첩 함수에서는 먼저 내부 렉시컬 환경에서 count라는 변수를 찾고 없기때문에 자신이 참조하는 외부 렉시컬 환경인 외부 함수의 렉시컬 환경에서 count변수를 찾아 증가시킨다.<br>이러한 방식으로 인해 makeCounter함수가 호출 될때마다 count의 값은 증가한다.</p>]]></content:encoded>
      
      
      <category domain="http://hanjuren.github.io/categories/javascript/">javascript</category>
      
      
      <category domain="http://hanjuren.github.io/tags/javascript/">javascript</category>
      
      
      <comments>http://hanjuren.github.io/2021/10/11/js/javascript-%EB%A0%89%EC%8B%9C%EC%BB%AC%ED%99%98%EA%B2%BD/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>javascript-함수</title>
      <link>http://hanjuren.github.io/2021/10/11/js/javascript-%ED%95%A8%EC%88%98/</link>
      <guid>http://hanjuren.github.io/2021/10/11/js/javascript-%ED%95%A8%EC%88%98/</guid>
      <pubDate>Mon, 11 Oct 2021 04:54:50 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;함수&quot;&gt;&lt;a href=&quot;#함수&quot; class=&quot;headerlink&quot; title=&quot;함수&quot;&gt;&lt;/a&gt;함수&lt;/h2&gt;&lt;h3 id=&quot;함수란&quot;&gt;&lt;a href=&quot;#함수란&quot; class=&quot;headerlink&quot; title=&quot;함수란?&quot;&gt;&lt;/a&gt;함수란?&lt;/h3&gt;&lt;p&gt;함수는 자바스크립트에서 중요한 핵심중 하나이다. 프로그래밍 언어의 함수는 일련의 과정을 문으로 구현하고 코드블록으로 감싸서 하나의 실행 단위로 정의 한것이다.&lt;br&gt;함수는 입력을 받아 출력을 내보낸다. 이때 함수 내부로 입력을 전달받는 변수를 매개변수 입력을 인수 출력을 반환값이라 한다. 또한 함수는 값이고 여러개 존재할 수 있기 때문에 특정 함수를 구별하기 위해 식별자인 함수 이름을 사용할 수 있다.&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 함수 정의&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; 함수이름(&lt;span class=&quot;params&quot;&gt;매개변수&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, 매개변수&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; 매개변수&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; + 매개변수&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// 반환값&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;함수이름(값&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, 값&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// 함수 호출&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;함수는 함수 정의로 생성하며 다양한 방법으로 정의할 수 있다.&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 함수 정의&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;add&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;x, y&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; x + y;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;함수를 정의하고 나서 실행을 하기 위해서는 인수를 매개변수를 통해 함수에 전달하며 함수의 실행을 지시해야한다. 이 과정을 &lt;strong&gt;함수 호출&lt;/strong&gt;이라고 한다.&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 함수 호출&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; result = add(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 인수를 전달하면 반환값이 반환된다.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(result); &lt;span class=&quot;comment&quot;&gt;// 7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;함수는-왜-사용할까&quot;&gt;&lt;a href=&quot;#함수는-왜-사용할까&quot; class=&quot;headerlink&quot; title=&quot;함수는 왜 사용할까?&quot;&gt;&lt;/a&gt;함수는 왜 사용할까?&lt;/h3&gt;&lt;p&gt;함수는 필요할 때마다 호출하여 실행이 가능하다. 실행 시점은 개발자가 결정하기도 하고 재사용이 가능하다. 동일한 작업을 반복적으로 실행해야 한다면 같은 코드를 중복하여 작성하는 것이 아닌 함수를 재사용하는 것이 효율적이다. 함수는 코드의 재사용 측면에서 매우 유용한 기능이다.&lt;/p&gt;
&lt;p&gt;함수는 재사용성을 높여주고 유지보수 측면에서 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높이는 효과가 있다. 이러한 함수를 정의할때 함수이름 즉 식별자를 붙일 수 있다. 함수이름은 함수의 역할을 이해하기 쉽게 네이밍해주는 것이 좋다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="함수"><a href="#함수" class="headerlink" title="함수"></a>함수</h2><h3 id="함수란"><a href="#함수란" class="headerlink" title="함수란?"></a>함수란?</h3><p>함수는 자바스크립트에서 중요한 핵심중 하나이다. 프로그래밍 언어의 함수는 일련의 과정을 문으로 구현하고 코드블록으로 감싸서 하나의 실행 단위로 정의 한것이다.<br>함수는 입력을 받아 출력을 내보낸다. 이때 함수 내부로 입력을 전달받는 변수를 매개변수 입력을 인수 출력을 반환값이라 한다. 또한 함수는 값이고 여러개 존재할 수 있기 때문에 특정 함수를 구별하기 위해 식별자인 함수 이름을 사용할 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 정의</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> 함수이름(<span class="params">매개변수<span class="number">1</span>, 매개변수<span class="number">2</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> 매개변수<span class="number">1</span> + 매개변수<span class="number">2</span> <span class="comment">// 반환값</span></span><br><span class="line">&#125;</span><br><span class="line">함수이름(값<span class="number">1</span>, 값<span class="number">2</span>); <span class="comment">// 함수 호출</span></span><br></pre></td></tr></table></figure><p>함수는 함수 정의로 생성하며 다양한 방법으로 정의할 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 정의</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>함수를 정의하고 나서 실행을 하기 위해서는 인수를 매개변수를 통해 함수에 전달하며 함수의 실행을 지시해야한다. 이 과정을 <strong>함수 호출</strong>이라고 한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 호출</span></span><br><span class="line"><span class="keyword">var</span> result = add(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인수를 전달하면 반환값이 반환된다.</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure><h3 id="함수는-왜-사용할까"><a href="#함수는-왜-사용할까" class="headerlink" title="함수는 왜 사용할까?"></a>함수는 왜 사용할까?</h3><p>함수는 필요할 때마다 호출하여 실행이 가능하다. 실행 시점은 개발자가 결정하기도 하고 재사용이 가능하다. 동일한 작업을 반복적으로 실행해야 한다면 같은 코드를 중복하여 작성하는 것이 아닌 함수를 재사용하는 것이 효율적이다. 함수는 코드의 재사용 측면에서 매우 유용한 기능이다.</p><p>함수는 재사용성을 높여주고 유지보수 측면에서 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높이는 효과가 있다. 이러한 함수를 정의할때 함수이름 즉 식별자를 붙일 수 있다. 함수이름은 함수의 역할을 이해하기 쉽게 네이밍해주는 것이 좋다.</p><span id="more"></span><h3 id="함수-리터럴"><a href="#함수-리터럴" class="headerlink" title="함수 리터럴?"></a>함수 리터럴?</h3><p>자바스크립트의 함수는 객체 타입의 값이다. 따라서 함수도 함수 리터럴로 생성할 수 있다. 함수 리터럴은 function키워드, 함수 이름, 매개변수 목록, 함수 몸체로 구성된다.</p><h4 id="함수-리터럴의-구성요소"><a href="#함수-리터럴의-구성요소" class="headerlink" title="함수 리터럴의 구성요소"></a>함수 리터럴의 구성요소</h4><table><thead><tr><th>구성요소</th><th>설명</th></tr></thead><tbody><tr><td>함수이름</td><td>함수이름은 식별자다. <br> 함수이름은 함수 몸체 내에서만 참조할수 있는 식별자이다. <br> 함수이름은 생략이 가능하다 이를 무명함수라 한다.</td></tr><tr><td>매개변수 목록</td><td>0개이상의 매개변수를 소괄호 내에 정의한다. <br> 각 매개변수는 함수 호출시 전달한 인자의 순서대로 할당된다.</td></tr><tr><td>함수 몸체</td><td>함수가 호출되었을 때 일괄적으로 실행될 문들을 하나의 실행단위로 정의한 것이다. <br> 함수 몸체는 함수의 호출로 실행된다.</td></tr></tbody></table><h3 id="함수-정의"><a href="#함수-정의" class="headerlink" title="함수 정의"></a>함수 정의</h3><p>함수 정의란 함수를 호출하기 전에 전달받을 매개변수들 실행할 문들 반환값을 정의하는 것을 말한다. 정의된 함수는 자바스크립트 엔진에 의해 함수 객체가 된다. </p><h4 id="함수-정의-방식"><a href="#함수-정의-방식" class="headerlink" title="함수 정의 방식"></a>함수 정의 방식</h4><table><thead><tr><th>정의 방식</th><th>예시</th></tr></thead><tbody><tr><td>함수 선언문</td><td><code>function add(x, y) &#123; return x + y &#125;</code></td></tr><tr><td>함수 표현식</td><td><code> var add = function (x, y) &#123; return x + y &#125;</code></td></tr><tr><td>Function 생성자함수</td><td><code>var add = new Function(&#39;x&#39;, &#39;y&#39;, &#39;return x + y&#39;);</code></td></tr><tr><td>화살표 함수</td><td><code>var add = (x, y) =&gt; x + y;</code></td></tr></tbody></table><h4 id="함수-선언문"><a href="#함수-선언문" class="headerlink" title="함수 선언문"></a>함수 선언문</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>함수 선언문은 함수 리터럴과 형태가 동일하다. 단 함수 선언문은 함수 이름을 생략할 수 없다.</p><p><em>함수 선언문은 표현식이 아닌 문이다.</em><br>자바스크립트 엔진은 함수 선언문을 해석하여 함수 객체를 생성한다. 이때 함수이름과 동일한 이름의 식별자를 임의로 생성하고 거기에 함수 객체를 할당한다.<br>즉 함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출하는 것이다.</p><h4 id="함수-생성-시점과-호이스팅"><a href="#함수-생성-시점과-호이스팅" class="headerlink" title="함수 생성 시점과 호이스팅"></a>함수 생성 시점과 호이스팅</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 참조</span></span><br><span class="line"><span class="built_in">console</span>.log(add);</span><br><span class="line"><span class="built_in">console</span>.log(sub);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 호출</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>, <span class="number">5</span>));</span><br><span class="line"><span class="built_in">console</span>.log(sub(<span class="number">2</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 선언문</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//함수 표현식</span></span><br><span class="line"><span class="keyword">var</span> sub = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>위의 코드처럼 함수 선언문으로 선언한 함수는 함수 선언이전에 호출이 가능하다. 하지만 함수 표현식으로 정의한 함수는 정의 이전에 호출이 불가능하다. 이는 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르기 때문이다.</p><p>함수 선언문은 코드가 실행되는 시점인 런타임 이전에 실행이 된다. 따라서 런타임 이전에 함수가 생성이 되는 것이다. 이처럼 함수선언문이 코드의 위로 끌어 올려져 먼저 생성된 이후 실행되는 것처럼 보이는 것을 함수 호이스팅이라고 한다.<br>var 키워드를 사용한 변수는 선언문 이전에 참조시 undefined로 평가되지만 함수는 호이스팅에 의해 호출이 가능한 차이점이 있다.</p><p>이에 반해 함수 표현식은 변수에 할당되는 값이 함수 리터럴인 문이다. 변수 선언은 런타임 이전에 undefined로 초기화 되지만 할당문은 값이 할당되는 시점에 평가되므로 런타임에서 함수 객체가 된다. 따라서 함수 표현식은 함수 정의 이전에 참조하게 되면 undefined로 평가되는 것이다.</p><h4 id="화살표-함수"><a href="#화살표-함수" class="headerlink" title="화살표 함수"></a>화살표 함수</h4><p>ES6에서 도입된 화살표 함수는 function 키워드 대신 화살표 =&gt; 를 사용하여 좀더 간략한 방법으로 함수를 정의할 수 있다.</p><h3 id="함수-호출"><a href="#함수-호출" class="headerlink" title="함수 호출"></a>함수 호출</h3><h4 id="매개변수와-인수"><a href="#매개변수와-인수" class="headerlink" title="매개변수와 인수"></a>매개변수와 인수</h4><p>함수를 실행하기 위해 필요한 값을 함수 외부에서 전달해야 할경우 매개변수를 통해 인자를 전달한다. 이때 인수는 값으로 평가될 수 있는 표현식이여야 한다. 인수는 함수를 호출할때 지정하고 개수와 타입에 제한이 없다.</p><p>매개변수는 함수를 정의할때 선언하며 함수 몸체 내부에서 변수와 동일하게 취급된다. 따라서 함수가 호출되면 암묵적으로 매개변수가 생성되고 undefined로 초기화된 이후 인수가 순서대로 할당된다.  </p><blockquote><p>함수의 호출시 실행 단계<br>함수정의 -&gt; 호출 (호출시 인수 전달) -&gt; 정의된 함수에서 매개변수 생성 후 인자 할당 -&gt; 정의된 문 실행 후 반환 -&gt; 호출시 지정한 변수에 값 할당</p></blockquote><h3 id="반환문"><a href="#반환문" class="headerlink" title="반환문"></a>반환문</h3><p>함수는 return 키워드와 함께 표현식으로 이뤄진 반환문을 사용해 실행 결과를 외부로 반환 할 수 있다.  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y; <span class="comment">// 반환문</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>함수 호출은 표현식이다. 따라서 return 키워드가 반환한 평가결과를 값으로 평가한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y; <span class="comment">// 반환문</span></span><br><span class="line">  cosole.log(<span class="string">&#x27;hi&#x27;</span>); <span class="comment">// 무시됨</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>return 키워드 이후의 실행문들은 실행되지 않고 무시된다.</p><h3 id="참조에-의한-전달과-외부-변경-상태의-변경"><a href="#참조에-의한-전달과-외부-변경-상태의-변경" class="headerlink" title="참조에 의한 전달과 외부 변경 상태의 변경"></a>참조에 의한 전달과 외부 변경 상태의 변경</h3><p><em>원시값은 값에 의한 전달 객체는 참조에 의한 전달방식으로 동작한다.</em><br>매개변수 또한 함수 몸체 내부에서는 변수와 동일하게 취급되므로 값에 의한 전달 참조에 의한 전달 방식을 사용한다.  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeVal</span> (<span class="params">primitive, obj</span>) </span>&#123;</span><br><span class="line">  primitive += <span class="number">100</span>;</span><br><span class="line">  obj.name = <span class="string">&#x27;Kim&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;Lee&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">changeVal(num , person);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 100 원시값은 원본이 바뀌지 않는다.</span></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123; name: &#x27;Kim&#x27; &#125; 객체는 원본이 훼손된다.</span></span><br></pre></td></tr></table></figure><p>위 경우 함수는 원시타입 인수와 객체 타입 인수를 전달받아 값을 변경하는데 원시값은 값의 변경이 불가능 하므로 원시값을 재할당해 새로운 값으로 변경하고 객체타입은 변경이 가능하므로 재할당없이 직접 값을 변경해준다.</p><p>이처럼 함수가 외부상태의 어떤 값을 변경하게 되면 상태변화를 추적하기 어려움이 있다. 이러한 문제점을 해결하기 위한 방법 중 한가지는 객체를 <em>불변객체</em>로 만들어 사용하는 것이다.<br>객체를 깊은 복사를 통해 완전히 새로운 객체를 생성하여 재할당을 통해 교체하면 된다.</p><h3 id="다양한-함수의-형태"><a href="#다양한-함수의-형태" class="headerlink" title="다양한 함수의 형태"></a>다양한 함수의 형태</h3><h4 id="즉시-실행-함수"><a href="#즉시-실행-함수" class="headerlink" title="즉시 실행 함수"></a>즉시 실행 함수</h4><p>함수는 정의와 동시에 실행되는 함수를 의미한다. 이 함수는 한번만 호출되며 다시 실행할 수 없다.</p><ol><li>익명 즉시 실행 함수<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>즉시 실행 함수는 일반적으로 함수이름이 없는 익명 함수를 사용하는 것이 일반적이다. 함수이름이 있는 기명 함수도 실행은 가능하지만 그룹연산자 **(…)**로 선언해야하기 때문에 함수 선언문이 아닌 리터럴로 평가되어 다시 호출이 불가능하다.</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>즉시 실행 함수는 반드시 그룹연산자로 감싸야 한다는 특징을 가지고 있다. 그룹연산자로 함수를 묶는 이유는 함수 리터럴을 평가하여 함수 객체를 생성하기 위해서이다. 이렇게 즉시 실행 함수에 코드를 모아두게 되면 혹시 있을 변수의 충돌이나 함수이름의 충돌을 방지 할 수 있다.</p><h3 id="재귀함수"><a href="#재귀함수" class="headerlink" title="재귀함수"></a>재귀함수</h3><p>함수가 자기 자신을 호출하는것을 재귀함수라 한다. 재귀함수는 반복되는 처리를 위해 사용한다.</p><ol><li>반복문을 사용하여 10부터 0까지 출력하는 함수<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = a; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>재귀함수를 사용하여 10부터 0까지 출력하는 방법<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 재귀함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fac</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(n);</span><br><span class="line">  fac(n -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">fac(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>동일한 실행결과를 반복문 없이도 구현이 가능하다. 하지만 재귀함수는 반복되는 처리를 무한 반복하기 때문에 탈출조건을 반드시 정의해야하며 무한 반복에 빠질경우 스택 오버플로를 일으킬수 있으므로 주의하여 사용해야한다. 또한 재귀함수는 반복문을 사용하는 것보다 직관적으로 이해하기 편하기 때문에 사용하는 것이므로 한정적으로 사용하는 것이 좋다.</li></ol><h3 id="중첩-함수"><a href="#중첩-함수" class="headerlink" title="중첩 함수"></a>중첩 함수</h3><p>함수 내부에 정의된 함수를 중첩 함수, 내부 함수라고 한다. 중첩 함수를 가지고 있는 함수를 외부 함수라고 부른다. 중첩 함수의 호출은 외부 함수에서만 가능하며 중첩 함수는 자신을 호출하는 외부 함수를 돕는 헬퍼 함수 역할을 하는 특징이 있다.  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 중첩 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 중첩 함수</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 중첩 함수는 외부 함수의 변수를 참조할 수 있다.</span></span><br><span class="line">    <span class="built_in">console</span>.log(x + y);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  inner();</span><br><span class="line">&#125;</span><br><span class="line">outer();</span><br></pre></td></tr></table></figure><h3 id="콜백-함수"><a href="#콜백-함수" class="headerlink" title="콜백 함수"></a>콜백 함수</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">re</span> (<span class="params">n , f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">    f(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> logAll = <span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line">re(<span class="number">5</span>, logAll);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logOdds = <span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(i%<span class="number">2</span>) <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">re (<span class="number">5</span>, logOdds);</span><br></pre></td></tr></table></figure><p>re함수의 경우에 따라 바뀌는 실행 결과를 f로 추상화하여 이를 외부에서 전달한다. js의 함수는 일급 객체이므로 함수의 매개변수를 통해 함수가 전달이 된다.<br>re 함수는 실행할 횟수인 인수를 전달받고 실행결과를 출력할 함수로 전달받은 함수를 호출한다. 따라서 위 실행결과는 하나의 함수에서 여러가지의 실행결과를 출력할 수 있다.<br><strong>이러한 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백함수라고 하며 매개변수를 통해 함수의 외부에서 콜백함수를 전달받은 함수를 고차 함수라고 한다.</strong>  </p><p>이전의 중첩 함수가 외부 함수의 헬퍼 함수역할을 하는 것처럼 콜백 함수도 고차 함수의 헬퍼 함수역할을 한다. 고차 함수는 매개변수를 통해 전달받은 콜백함수의 호출 시점을 결정해서 호출한다. 따라서 콜백함수는 고차 함수에 의해 호출되며 고차 함수는 필요에 따라 콜백 함수에 인수를 전달 할 수 있다.</p><ol><li>콜백 함수를 사용하는 예제<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// [2, 4, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fil = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].filter(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item % <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(fil); <span class="comment">// [1, 3]</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="순수-함수와-비순수-함수"><a href="#순수-함수와-비순수-함수" class="headerlink" title="순수 함수와 비순수 함수"></a>순수 함수와 비순수 함수</h3><p>함수형 프로그래밍에서 어떠한 외부 상태에도 의존하지 않고 변경하지도 않는 함수를 순수 함수라고 하고 외부 상태에 의존하거나 외부 상태를 변경하는 함수를 비순수 함수라고 한다.<br>순수 함수는 동일한 인수가 전달되면 언제나 동일한 값을 반환하는 함수이다. 즉 순수 함수는 오직 매개변수를 통해 함수 내부에 전달된 인수에게 의존하여 반환값을 만드는 함수이다.</p><ol><li>순수 함수<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increase</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ++n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 순수 함수가 반환한 값을 변수에 재할당하여 상태를 변경</span></span><br><span class="line">count = increase(count);</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 1 </span></span><br><span class="line">count = increase(count);</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li></ol><p>순수 함수의 의미와 반대된 개념으로 비순수 함수는 외부 상태에 의존하는 함수이다.</p><ol start="2"><li>비순수 함수<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increase</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ++count; <span class="comment">// 외부 상태에 의존하여 외부 상태를 변경한다.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">increse();</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 1</span></span><br><span class="line">increse();</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li></ol><hr><p>함수형 프로그래밍은 순수 함수와 보조 함수의 적절한 조합으로 외부 상태를 변경하는 부수효과를 최소화하여 불변성을 지향하는 프로그래밍이다.</p>]]></content:encoded>
      
      
      <category domain="http://hanjuren.github.io/categories/javascript/">javascript</category>
      
      
      <category domain="http://hanjuren.github.io/tags/javascript/">javascript</category>
      
      
      <comments>http://hanjuren.github.io/2021/10/11/js/javascript-%ED%95%A8%EC%88%98/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>javascript 원시값과 객체의 비교</title>
      <link>http://hanjuren.github.io/2021/09/28/js/javascript-%EC%9B%90%EC%8B%9C%EA%B0%92%EA%B3%BC-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EB%B9%84%EA%B5%90/</link>
      <guid>http://hanjuren.github.io/2021/09/28/js/javascript-%EC%9B%90%EC%8B%9C%EA%B0%92%EA%B3%BC-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EB%B9%84%EA%B5%90/</guid>
      <pubDate>Tue, 28 Sep 2021 05:44:55 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;원시값과-객체의-비교&quot;&gt;&lt;a href=&quot;#원시값과-객체의-비교&quot; class=&quot;headerlink&quot; title=&quot;원시값과 객체의 비교&quot;&gt;&lt;/a&gt;원시값과 객체의 비교&lt;/h2&gt;&lt;p&gt;원시 타입과 객체 타입의 차이점&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;원시 타입의 값은 변경 불가능한 값이다. 객체 타입의 값은 변경가능한 값이다.&lt;/li&gt;
&lt;li&gt;원시 값을 변수에 할당하면 변수에는 실제 값이 저장된다. 객체를 변수에 할당하면 변수에는 참조 값이 저장된다.&lt;/li&gt;
&lt;li&gt;원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달된다. 이를 값에 의한 전달이라 한다. 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 참조에 의한 전달이라 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;원시-값&quot;&gt;&lt;a href=&quot;#원시-값&quot; class=&quot;headerlink&quot; title=&quot;원시 값&quot;&gt;&lt;/a&gt;원시 값&lt;/h3&gt;&lt;h4 id=&quot;변경-불가능한-값&quot;&gt;&lt;a href=&quot;#변경-불가능한-값&quot; class=&quot;headerlink&quot; title=&quot;변경 불가능한 값&quot;&gt;&lt;/a&gt;변경 불가능한 값&lt;/h4&gt;&lt;p&gt;원시타입 : 변경 불가능한 값&lt;br&gt;변경이 불가능한 값이라는 것은 변수란 값을 저장하기 위한 메모리의 공간 자체 또는 공간을 식별하기 위한 이름이고 값은 저장된 데이터이다. 즉 변경 불가능하다는 것은 변수가 아닌 값에대한 이야기이다.&lt;/p&gt;
&lt;p&gt;변경이 불가능한것은 상수와 같은 맥락이긴 하지만 원시값은 재할당시 값이 바뀌지 않고 새로운 공간에 값을 저장하지만 상수는 재할당이 안되므로 둘의 개념이 완벽히 일치하는 것은 아니다.&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; a = &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a.first = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// const 키워드를 사용하여 선언한 변수에 할당한 값은 변경이 불가능하다.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 하지만 const 키워드를 사용한 변수에 할당한 객체는 변경이 가능하다.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;변수에 할당한 값은 원시 값으로 한번 할당하면 그 값의 변경이 불가능하다. 변수에 값을 재할당시 기존에 값이 저장되어있던 메모리 주소에 새로운 값을 갱신하는 것이 아닌 새로운 메모리 공간에 저장하고 그 메모리 주소를 가리키게 되는데 값의 이러한 특성을 &lt;em&gt;불변성&lt;/em&gt;이라고 한다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="원시값과-객체의-비교"><a href="#원시값과-객체의-비교" class="headerlink" title="원시값과 객체의 비교"></a>원시값과 객체의 비교</h2><p>원시 타입과 객체 타입의 차이점</p><ol><li>원시 타입의 값은 변경 불가능한 값이다. 객체 타입의 값은 변경가능한 값이다.</li><li>원시 값을 변수에 할당하면 변수에는 실제 값이 저장된다. 객체를 변수에 할당하면 변수에는 참조 값이 저장된다.</li><li>원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달된다. 이를 값에 의한 전달이라 한다. 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 참조에 의한 전달이라 한다.</li></ol><h3 id="원시-값"><a href="#원시-값" class="headerlink" title="원시 값"></a>원시 값</h3><h4 id="변경-불가능한-값"><a href="#변경-불가능한-값" class="headerlink" title="변경 불가능한 값"></a>변경 불가능한 값</h4><p>원시타입 : 변경 불가능한 값<br>변경이 불가능한 값이라는 것은 변수란 값을 저장하기 위한 메모리의 공간 자체 또는 공간을 식별하기 위한 이름이고 값은 저장된 데이터이다. 즉 변경 불가능하다는 것은 변수가 아닌 값에대한 이야기이다.</p><p>변경이 불가능한것은 상수와 같은 맥락이긴 하지만 원시값은 재할당시 값이 바뀌지 않고 새로운 공간에 값을 저장하지만 상수는 재할당이 안되므로 둘의 개념이 완벽히 일치하는 것은 아니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">a.first = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// const 키워드를 사용하여 선언한 변수에 할당한 값은 변경이 불가능하다.</span></span><br><span class="line"><span class="comment">// 하지만 const 키워드를 사용한 변수에 할당한 객체는 변경이 가능하다.</span></span><br></pre></td></tr></table></figure><p>변수에 할당한 값은 원시 값으로 한번 할당하면 그 값의 변경이 불가능하다. 변수에 값을 재할당시 기존에 값이 저장되어있던 메모리 주소에 새로운 값을 갱신하는 것이 아닌 새로운 메모리 공간에 저장하고 그 메모리 주소를 가리키게 되는데 값의 이러한 특성을 <em>불변성</em>이라고 한다.</p><span id="more"></span><h4 id="문자열과-불변성"><a href="#문자열과-불변성" class="headerlink" title="문자열과 불변성"></a>문자열과 불변성</h4><p>자바스크립트에서 문자열은 원시타입으로 제공된다. 문자열 타입은 원시 타입이며 변경이 불가능하다. 이것은 문자열이 생성된 이후에는 변경이 불가능하다는 것이다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">str = <span class="string">&#x27;world&#x27;</span>;</span><br></pre></td></tr></table></figure><p>위의 코드는 str이라는 변수를 생성하고 hello라는 값을 할당하여 str이 hello가 저장된 메모리공간을 참조하게 된다. 이후 str에 world라는 값을 재할당시 str은 새로 할당한 값의 주소를 가리키게 된다.</p><p>문자열은 유사 배열 객체로도 사용이 가능하다.<br>유사 배열 객체란 배열처럼 인덱스로 프로퍼티에 접근이 가능하며 length프로퍼티를 가지는 객체를 의미한다. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str.length); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str[<span class="number">0</span>]); <span class="comment">// h</span></span><br></pre></td></tr></table></figure><p>이처럼 각 인덱스로 프로퍼티에 접근이 가능하다. 하지만 문자열은 원시 값이기 때문에 프로퍼티의 값을 변경 할 수 없다. 오로지 재할당으로만 값을 변경할 수 있는것이다.</p><h4 id="값에-의한-전달"><a href="#값에-의한-전달" class="headerlink" title="값에 의한 전달"></a>값에 의한 전달</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">80</span>;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"></span><br><span class="line">a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br></pre></td></tr></table></figure><p>a라는 변수에 80을 할당하고 b에 a가 참조하는 값을 할당해준다. a와 b는 모두 80이라는 값을 가진 변수가 된다. 이후 a의 값을 100으로 재할당시 a는 100의 값을 가지고 b는 80값을 그대로 유지한다.<br>할당되는 변수의 값이 원시 값이기 때문에 새로 할당하는 모든 값들은 각각 다른 메모리 공간에 저장되며 참조하기 때문이다.<br>a와 b가 같은 80의 값을 가지더라도 두 변수가 가리키는 메모리의 주소는 다르다는 의미이다.</p><p>또다른 의미로는 변수에 값이 전달되는 것이 아닌 메모리 주소가 전달된다라고 볼 수도 있다.  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br></pre></td></tr></table></figure><p>a에 100이라는 값을 할당하고 a는 100이 저잗되어있는 메모리 주소를 가리킨다.<br>b에 a가 가리키는 메모리 주소를 전달하여 b도 a가 가리키는 메모리 주소를 같이 공유한다.<br>이렇게 되면 두 변수의 값이 재할당 되는 시점 전까지는 두 변수는 각자의 식별자를 통해 한 곳의 메모리 주소를 가리키게 되어 값이 같다.</p><p><strong>이처럼 값에 의한 전달도 값을 전달하는 것이 아니라 메모리 주소를 전달한다 단 전달된 메모리 주소를 통해서 메모리 공간에 접근하여 값을 참조한다.</strong></p><h3 id="객체"><a href="#객체" class="headerlink" title="객체"></a>객체</h3><h4 id="자바스크립트의-객체-관리-방식"><a href="#자바스크립트의-객체-관리-방식" class="headerlink" title="자바스크립트의 객체 관리 방식"></a>자바스크립트의 객체 관리 방식</h4><p>객체는 프로퍼티 키를 인덱스로 사용하는 해시 테이블이라고 생각하면된다. 자바스크립트에서는 높은 성능을 위해 일반적인 해시테이블보다 나은 방법으로 객체를 구현해낸다.</p><blockquote><p>해시테이블이란 키 값으로 데이터를 저장하는 자료구조중 하나이다. </p></blockquote><p><img src="https://ifh.cc/g/yCTwsg.png" title="해시테이블"></br></p><h4 id="변경-가능한-값"><a href="#변경-가능한-값" class="headerlink" title="변경 가능한 값"></a>변경 가능한 값</h4><p>객체 타입의 값은 변경이 가능한 값이다. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>객체를 변수에 할당하면 변수가 기억하는 메모리의 주소를 통해 접근하면 참조 값에 의해 객체에 접근이 가능해진다.<br>원시값을 할당한 변수를 참조하게 될때 메모리에 저장되어있는 참조 값을 통해 실제 객체에 접근하게 되는 것이다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 할당이 이루어 지는 시점에 객체 리터럴이 생성되고 그 결과로 객체가 생성된다.</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// person 변수에 저장되어있는 참조 값으로 객체에 접근한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123; name: &#x27;Lee&#x27; &#125;</span></span><br></pre></td></tr></table></figure><p>원시값은 재할당 외에는 변경할 수 있는 방법이 없다. 하지만 객체는 재할당없이 객체를 직접 변경할 수 있다. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Lee&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 프로퍼티 값 변경</span></span><br><span class="line">person.name = <span class="string">&#x27;Kim&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 프로퍼티 동적 생성</span></span><br><span class="line">person.address = <span class="string">&#x27;seoul&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123; name: &#x27;Kim&#x27;, address: &#x27;seoul&#x27; &#125;</span></span><br></pre></td></tr></table></figure><p>객체는 메모리의 효율적인 사용을 위해 값을 변경이 가능하게 설계가 되어있다. 하지만 이러한 객체의 단점은 여러 식별자가 하나의 객체를 공유 할 수 있다는 것이다.</p><blockquote><p>앝은 복사, 깊은 복사</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o = &#123; <span class="attr">x</span>: &#123; <span class="attr">y</span>: <span class="number">1</span> &#125; &#125;;</span><br><span class="line">&gt;<span class="comment">// 얕은 복사</span></span><br><span class="line"><span class="keyword">const</span> c1 = &#123; ...o &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(o);</span><br><span class="line"><span class="built_in">console</span>.log(c1);</span><br><span class="line"><span class="built_in">console</span>.log(c1 === o);</span><br><span class="line"><span class="built_in">console</span>.log(c1.x === o.x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 깊은 복사</span></span><br><span class="line"><span class="keyword">const</span> c2 = _.cloneDeep(o);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(o);</span><br><span class="line"><span class="built_in">console</span>.log(c2);</span><br><span class="line"><span class="built_in">console</span>.log(c2 === o);</span><br><span class="line"><span class="built_in">console</span>.log(c2.x === o.x);</span><br></pre></td></tr></table></figure><p>실행결과</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123; x: &#123; y: 1 &#125; &#125;</span><br><span class="line">&#123; x: &#123; y: 1 &#125; &#125;</span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&#123; x: &#123; y: 1 &#125; &#125;</span><br><span class="line">&#123; x: &#123; y: 1 &#125; &#125;</span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure><p>얕은 복사와 깊은 복사로 생성된 객체는 원본과는 다른 객체이다. 하지만 얕은 복사는 객체에 중첩되어있는 객체의 참조값을 복사하고 깊은 복사는 모두 복사하여 새로운 복사본을 만드는 차이점이 있다.</p></blockquote><h4 id="참조에-의한-전달"><a href="#참조에-의한-전달" class="headerlink" title="참조에 의한 전달"></a>참조에 의한 전달</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> copy = person;</span><br></pre></td></tr></table></figure><p>객체를 가리키는 변수 <em>person</em>을 <em>copy</em>라는 변수에 할당하면 원본의 참조값이 복사되어 전달 된다. 이를 참조에 의한 전달이라고 한다.</p><p><em>person</em>과 <em>copy</em>는 다른 메모리 주소를 가지고 있지만 동일한 참조값을 가진다. 이렇게 되면 한 곳에서 프로퍼티의 값을 추가 삭제 변경 할때 다른 곳도 영향을 받게 된다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> copy = person;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(copy); <span class="comment">// &#123; name: &#x27;Lee&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line">copy.name = <span class="string">&#x27;Kim&#x27;</span>;</span><br><span class="line">copy.address = <span class="string">&#x27;seoul&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123; name: &#x27;Kim&#x27;, address: &#x27;seoul&#x27; &#125;</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://hanjuren.github.io/categories/javascript/">javascript</category>
      
      
      <category domain="http://hanjuren.github.io/tags/javascript/">javascript</category>
      
      
      <comments>http://hanjuren.github.io/2021/09/28/js/javascript-%EC%9B%90%EC%8B%9C%EA%B0%92%EA%B3%BC-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EB%B9%84%EA%B5%90/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>javascript 객체 리터럴</title>
      <link>http://hanjuren.github.io/2021/09/15/js/javascript-%EA%B0%9D%EC%B2%B4-%EB%A6%AC%ED%84%B0%EB%9F%B4/</link>
      <guid>http://hanjuren.github.io/2021/09/15/js/javascript-%EA%B0%9D%EC%B2%B4-%EB%A6%AC%ED%84%B0%EB%9F%B4/</guid>
      <pubDate>Wed, 15 Sep 2021 05:31:06 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;객체-리터럴&quot;&gt;&lt;a href=&quot;#객체-리터럴&quot; class=&quot;headerlink&quot; title=&quot;객체 리터럴&quot;&gt;&lt;/a&gt;객체 리터럴&lt;/h2&gt;&lt;p&gt;자바스크립트는 객체기반 프로그래밍 언어이며 자바스크립트를 구성하는 거의 대부분이 원시값을 제외한 객체이다.&lt;/p&gt;
&lt;p&gt;원시타입은 단 하나의 값을 나타내지만 객체 타입은 다양한 타입의 값을 하나의 단위로 가지고있는 복합적 자료구조이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;원시 타입의 값은 변경이 불가능 하지만 객체 타입의 값 즉 객체는 변경이 가능한 값이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;객체 : 0개이상의 프로퍼티로 구성된 집합이며 키와 값으로 구성된다.&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// key: value&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;age&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;25&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&amp;#x27;han&amp;#x27;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="객체-리터럴"><a href="#객체-리터럴" class="headerlink" title="객체 리터럴"></a>객체 리터럴</h2><p>자바스크립트는 객체기반 프로그래밍 언어이며 자바스크립트를 구성하는 거의 대부분이 원시값을 제외한 객체이다.</p><p>원시타입은 단 하나의 값을 나타내지만 객체 타입은 다양한 타입의 값을 하나의 단위로 가지고있는 복합적 자료구조이다.</p><blockquote><p>원시 타입의 값은 변경이 불가능 하지만 객체 타입의 값 즉 객체는 변경이 가능한 값이다.</p></blockquote><p>객체 : 0개이상의 프로퍼티로 구성된 집합이며 키와 값으로 구성된다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="comment">// key: value</span></span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;han&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><span id="more"></span><p>자바스크립트에서 사용할 수 있는 모든 값은 프로퍼티가 될 수 있다. 프로퍼티의 값이 함수일 경우 일반 함수와 구분하기 위해 메서드라고 부른다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>, <span class="comment">// 프로퍼티</span></span><br><span class="line">  <span class="attr">increase</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 메서드</span></span><br><span class="line">    <span class="built_in">this</span>.age++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>프로퍼티와 메서드의 역할</p><ul><li>프로퍼티 : 객체의 상태를 나타내는 값</li><li>메서드 : 프로퍼티를 참조하고 조작할 수 있는 동작</li></ul></blockquote><p>✔ 객체와 함수</p><blockquote><p>자바스크립트는 함수로 객체를 생성하기도 하고 함수 자체가 객체이기도 하다.</p></blockquote><h3 id="객체-리터럴에-의한-객체-생성"><a href="#객체-리터럴에-의한-객체-생성" class="headerlink" title="객체 리터럴에 의한 객체 생성"></a>객체 리터럴에 의한 객체 생성</h3><p>C, JAVA같은 클래스 기반 객체지향 언어는 클래스를 정의하고 new 연산자와 생성자를 호출하여 객체를 생성하는 방식이다. 자바스크립트에서는 프로토타입 기반 객체지향 언어로서 여러가지의 객체 생성 방식을 지원한다.</p><ul><li>객체 리터럴</li><li>Object생성자 함수</li><li>생성자 함수</li><li>Object.create메서드</li><li>클래스</li></ul><p>이 방법들중 가장 많이 사용하는 객체 리터럴 방법은 객체를 생성하기 위한 표기법중 하나이다.</p><h4 id="객체-생성해보기"><a href="#객체-생성해보기" class="headerlink" title="객체 생성해보기"></a>객체 생성해보기</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name = <span class="string">&#x27;lee&#x27;</span>,</span><br><span class="line">  <span class="attr">sayHello</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hello My Name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> personn); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123; name: &#x27;lee&#x27;, sayHello: f &#125;</span></span><br></pre></td></tr></table></figure><h3 id="프로퍼티"><a href="#프로퍼티" class="headerlink" title="프로퍼티"></a>프로퍼티</h3><p><strong>객체는 프로퍼티의 집합이며 프로퍼티는 키와 값으로 구성된다.</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="comment">// 프로퍼티 키는 name, 값은 &#x27;Lee&#x27;</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">  <span class="comment">// 프로퍼티 키는 age, 값은 &#x27;20</span></span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>프로퍼티를 나열할 때는 쉼표로 구분한다. 일반적으로 마지막 프로퍼티에는 쉼표를 사용하지 않지만 해도 무방하다.</p><p>문자열 또는 문자열로 평가할 수 있는 표현식을 사용하여 프로퍼티 키를 동적으로 생성할 수 있다. 이때는 키로 사용할 표현식을 대괄호[]로 묶어줘야 한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> key = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line">obj[key] = <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; hello: &#x27;world&#x27; &#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>프로퍼티 키 네이밍</p><ul><li>빈문자열로 생성해도 에러는 발생하지 않는다 하지만 키로서의 의미를 갖지 못한다.</li><li>문자열이나 심벌값 외의 값을 사용하면 암묵적 타입 변환으로 문자열이 된다.</li><li>예약어를 사용해도 에러는 발생하지 않느다 하지만 예상치 못한 에러가 발생할 수 있다.</li><li>중복선언시 나중에 선언한 프로퍼티가 기존의 값을 덮어씌운다.</li></ul></blockquote><h3 id="메서드"><a href="#메서드" class="headerlink" title="메서드"></a>메서드</h3><p>자바스크립트에서 함수는 일급 객체이다. 즉 함수는 값으로 취급이 되기때문에 프로퍼티 값으로 사용할 수 있다.<br>프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위해 메서드라 부른다. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> circle = &#123;</span><br><span class="line">  <span class="attr">radius</span>: <span class="number">5</span>, <span class="comment">// 프로퍼티</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 원의 지름을 구하는 함수</span></span><br><span class="line">  <span class="attr">getDiameter</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 메서드</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">this</span>.radius; <span class="comment">// this는 circle을 가르킨다.</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(circle.getDiameter()); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><h3 id="프로퍼티-접근"><a href="#프로퍼티-접근" class="headerlink" title="프로퍼티 접근"></a>프로퍼티 접근</h3><p>프로퍼티에 접근하는 방법은 다음과 같이 두 가지다.</p><ol><li>마침표 프로퍼티 접근 연산자를 사용하는 법</li><li>대괄호 프로퍼티 접근 연산자를 사용하는 법</li></ol><p>프로퍼티 키가 식별자 네이밍 규칙을 준수하는 이름이라면 두가지 방법을 모두 사용할 수 있다.</p><h4 id="프로퍼티-접근해보기"><a href="#프로퍼티-접근해보기" class="headerlink" title="프로퍼티 접근해보기"></a>프로퍼티 접근해보기</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Han&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// Han</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.age); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure><p>이때 대괄호 표기법으로 프로퍼티에 접근시 접근 연산자 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싸줘야 한다.</p><h3 id="프로퍼티-값-갱신"><a href="#프로퍼티-값-갱신" class="headerlink" title="프로퍼티 값 갱신"></a>프로퍼티 값 갱신</h3><p>이미 존재하는 프로퍼티 값에 새로운 값을 할당하면 값이 갱신된다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;lee&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.name = <span class="string">&#x27;han&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123; name: &#x27;han&#x27; &#125;</span></span><br></pre></td></tr></table></figure><h3 id="프로퍼티-동적-생성"><a href="#프로퍼티-동적-생성" class="headerlink" title="프로퍼티 동적 생성"></a>프로퍼티 동적 생성</h3><p>존재한지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당 된다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">v</span><br></pre></td></tr></table></figure><h3 id="프로퍼티-삭제"><a href="#프로퍼티-삭제" class="headerlink" title="프로퍼티 삭제"></a>프로퍼티 삭제</h3><p>delete 연산자는 객체의 프로퍼티를 삭제한다. 이때 delete 연산자의 피연산자가 프로퍼티에 접근이 가능한 표현식이여야 한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.age = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123; name: &#x27;Lee&#x27;, age: 20 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person.age;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123; name: &#x27;Lee&#x27; &#125;</span></span><br></pre></td></tr></table></figure><h3 id="ES6에서-추가된-객체-리터럴의-확장-기능"><a href="#ES6에서-추가된-객체-리터럴의-확장-기능" class="headerlink" title="ES6에서 추가된 객체 리터럴의 확장 기능"></a>ES6에서 추가된 객체 리터럴의 확장 기능</h3><h4 id="프로퍼티-축약-표현"><a href="#프로퍼티-축약-표현" class="headerlink" title="프로퍼티 축약 표현"></a>프로퍼티 축약 표현</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es5</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>, y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">x</span>: x,</span><br><span class="line">  <span class="attr">y</span>: y,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; x: 1, y: 2 &#125;</span></span><br></pre></td></tr></table></figure><p>ES6에서는 프로퍼티 키와 값으로 변수를 사용할때 둘의 이름이 동일하다면 키를 생략할 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>, y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; x, y &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; x: 1, y: 2 &#125;</span></span><br></pre></td></tr></table></figure><h4 id="계산된-프로퍼티-이름"><a href="#계산된-프로퍼티-이름" class="headerlink" title="계산된 프로퍼티 이름"></a>계산된 프로퍼티 이름</h4><p>문자열 또는 문자열로 타입 변활할 수 있는 값으로 평가되는 표현식을 사용해 키를 동적으로 생성하기 위해서는 대괄호 표현식으로 묶어줘야 한다. 이를 계산된 프로퍼티 이름이라고 한다.</p><p>ES5에서는 계산된 프로퍼티 이름으로 키를 생성하려면 객체 리터럴 외부에서 대괄호 표기번을 사용해야 했다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pre = <span class="string">&#x27;prop&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj[pre = <span class="string">&#x27;-&#x27;</span> + ++i] = i;</span><br><span class="line">obj[pre = <span class="string">&#x27;-&#x27;</span> + ++i] = i;</span><br><span class="line">obj[pre = <span class="string">&#x27;-&#x27;</span> + ++i] = i;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; prop-1: 1, prop-2: 2, prop-3: 3 &#125;</span></span><br></pre></td></tr></table></figure><p>ES6에서는 객체 리터럴 내부에서도 계산된 프로퍼티 이름으로 프로퍼티 키를 동적 생성할 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pre = <span class="string">&#x27;prop&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [<span class="string">`<span class="subst">$&#123;prop&#125;</span>-<span class="subst">$&#123;++i&#125;</span>`</span>]: i,</span><br><span class="line">  [<span class="string">`<span class="subst">$&#123;prop&#125;</span>-<span class="subst">$&#123;++i&#125;</span>`</span>]: i,</span><br><span class="line">  [<span class="string">`<span class="subst">$&#123;prop&#125;</span>-<span class="subst">$&#123;++i&#125;</span>`</span>]: i,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; prop-1: 1, prop-2: 2, prop-3: 3 &#125;</span></span><br></pre></td></tr></table></figure><h3 id="메서드-축약-표현"><a href="#메서드-축약-표현" class="headerlink" title="메서드 축약 표현"></a>메서드 축약 표현</h3><p>ES5에서 메서드를 정의하기 위해서는 프로퍼티 값으로 함수를 할당한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">  <span class="attr">sayHi</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hi &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.sayHi(); <span class="comment">// Hi Lee</span></span><br></pre></td></tr></table></figure><p>ES6에서 메서드를 정의할 때 function 키워드를 생략하는 축약 표현이 가능하다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hi <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.sayHi(); <span class="comment">// Hi Lee</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://hanjuren.github.io/categories/javascript/">javascript</category>
      
      
      <category domain="http://hanjuren.github.io/tags/javascript/">javascript</category>
      
      
      <comments>http://hanjuren.github.io/2021/09/15/js/javascript-%EA%B0%9D%EC%B2%B4-%EB%A6%AC%ED%84%B0%EB%9F%B4/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
